[{"title":"AI和AIGC","url":"/2023/11/22/AI%E5%92%8CAIGC/","content":"AI 的定义AI，英文名称为：Artificial Intelligence，即人工智能。\nAI的核心定义；由人制造出来的智能，让机器像人一样思考和行动，例如学习、推理、解决问题等。\nAI 的分类人工智能大致可以分为两类：\n\n窄人工智能 (Narrow AI)\n\n通用人工智能 (General AI)\n\n\n窄人工智能也称为弱人工智能，是目前最常见的AI类型。        主要用于在特定领域或任务中，且不懂该领域之外的任务。比如语音识别软件只擅长处理语音，而不懂其他任务。        这些系统通常基于大数据的学习和模式识别。\n通用人工智能也称为最强人工智能，是一种理论上的AI，可以像人类一样执行任何智能任务，目前还未实现。\n其他子领域机器学习是AI的一个分支，能让机器从数据中学习，而不是完全依靠预设的规则\n深度学习是机器学习的子集，通过模拟人脑的神经网络结构来学习数据。\n自然语言处理(NLP)是AI在语言理解和生成方面的应用。\nAIGCAIGC 是AI的一个重要分支，全程是 AI generated content，在国内被称为生成式AI；即指利用人工智能技术自动生成各种类型的内容。\n主要应用领域文本生成利用AIGC生成连贯、自然的文本内容，如：谷歌的Bard、百度的文心一言等\n图像生成利用AIGC生成逼真的图像\n视频生成合成和编辑视频，生成具有特定场景、角色和动作的视频片段，如日本流行的虚拟偶像初音未来。\n其他应用领域如音频合成、数据可视化、自动编程等。\n参考学习资料每个人的AI学习手册 (xiaobot.net)\n第01讲：什么是AI？ (xiaobot.net)\n第02讲：什么是AIGC？ (xiaobot.net)\n","categories":["小灰","AI学习笔记"],"tags":["AI","AIGC"]},{"title":"ChatGPT学习","url":"/2023/11/22/ChatGPT%E5%AD%A6%E4%B9%A0/","content":"ChatGPT 介绍ChatGPT是一款由OpenAI开发的先进人工智能助手，基于强大的GPT架构，旨在为用户提供丰富的、高质量的语言理解和生成服务。\nGPT 架构GPT 是一种自然语言处理模型。        自然语言处理模型，即可以实现人与计算机之间通过自然语言进行有效通信；自然语言俗称即为人类语言。\nGPT 全称为 Generative Pre-trained Transformer\n\nGenerative：翻译为“生成式”，即GPT具有生成新文本能力。\nPre-trained：翻译为“预训练”，即在使用ChatGPT之前，GPT模型已经通过海量的文本数据进行了预训练，学习掌握了语言结构、语法、语义等方面知识，在处理提问时，有强大的迁移学习能力，即可以做到举一反三。\nTransformer：翻译为“转换器”，这里指Transformer架构，即一种专门的深度学习架构，是专为自然语言处理任务设计的深度学习架构。\n\nGPT 也被归类到大语言模型(Large Language Model，简称LLM)中，\n图灵测试是一种评估机器是否具有智能的方法；基本思想是：计算机程序在与人类的自然语言对话中，让人类无法区分它与另外一位真实的人类之间的差别，那这个计算机程序就可以被认为具有智能。\n模型参数模型参数是指模型学习和存储知识的核心部分。\n人工智能，采用的模型参数越多，输出的结果也就精准，并且模型会根据海量的数据来不断调整和优化自己的参数，这个自我优化过程就是模型的训练过程\nGPT 3.5在GPT3强大的零样本学习能力的基础上，增加了代码训练和指令微调。\n\n零样本学习：即让模型在没有特定任务训练数据的情况下，通过推理完成任务。\n代码训练：让GPT 3-5模型具备更好的代码生成和代码理解能力，间接拥有了使用思维链进行复杂推理的能力。\n指令微调：使具备更好的模型泛化能力，同时模型的生成结果更加符合人类的预期。\n\nGPT4\n拥有比GPT 3-5多得多的模型参数，大大提升了生成文本的质量和准确。\n模型架构从自然语言处理模型升级成了多模态模型。\n支持更长的文字输入，最大长度：25000字。\n\n多模态是指同时处理和理解多种类型数据的技术\nChatGPT 的应用场景\n文案创作\n语言翻译\n金融分析\n知识搜索\n聊天工具\n专业咨询\n辅助编程\n辅助AI绘画\n等等……\n\n参考学习文章每个人的AI学习手册 (xiaobot.net)\n第03讲：什么是ChatGPT？ (xiaobot.net)\n第04讲：ChatGPT的发展历程 (xiaobot.net)\n第05讲：GPT-4强大在哪里？ (xiaobot.net)\n第06讲：ChatGPT的应用场景 (xiaobot.net)\n","categories":["小灰","AI学习笔记"],"tags":["AI","ChatGPT"]},{"title":"ChatGPT的使用","url":"/2023/11/23/ChatGPT%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"如何对ChatGPT进行提问提问词工程(Prompt Engineering )提示词，是指用户向AI模型提供的输入文本，用以引导AI模型生成特定类型的文本输出，这些输入可以是问题、任务描述或场景描述。\n向AI询问问题，最首先的就是要把问题说清楚。\n因此，我们为了让AI模型输出更准确的答案，所使用的那些提问题的技巧和方法就是提示词工程。合适的提示词，能够引导GPT模型生成有针对性且高质量的回复。\n常用的提示词六大类信息检索类Prompt向ChatGPT询问某些固有的知识，比如输入：“乔治·华盛顿是哪一年出生的？”\n\n文本生成类Prompt让ChatGPT根据特定要求来生成文本，比如：“我今天发烧40度，无法去上班，请向我的领导写一封请假信，要求字数在300字以内”\n\n机器翻译类Prompt给定某种语言的内容，让ChatGPT翻译成另一种语言，比如：“请将‘the secret of a happy old age is nothing else but a decent agreement with loneliness.’从英语翻译成中文”\n\n创意写作类Prompt提出具有开放性的要求，让ChatGPT创作，比如：“写一个以美国南北战争为历史背景的短篇爱情小说，要求字数2000字以内。”\n\n文本摘要类Prompt指定一篇文章，让ChatGPT提炼出文章的核心要点，比如以刚刚输出的故事文章进行提炼。\n\n咨询建议类Prompt列举现实情况，向ChatGPT提供咨询建议，比如：“我是一个21岁的北京女大学生，我喜欢上了同班爱打篮球的男同学，我应该怎样向他表白？”\n\n总结想要提出好的问题，首先明确提示词的种类，然后对症下药。\nPrompt需要包含的四大组成部分任务即用户希望模型完成的具体工作，如回答问题、提供建议。\n上下文有助于模型理解任务的背景信息，如相关领域知识、具体场景等。\n指令引导模型以特定方式完成任务的具体要求，如答案格式、回答深度等。\n角色设定模型在互动中扮演的身份，如专家、助手等。\n应用示例输入内容：“作为一个项目组的负责人，当你遇到项目组成员因工资待遇问题发生冲突时，请给出有效的解决办法。解决方法列举5条以上，总字数在200~300之间。”\n分析：\n\n任务部分是“给出有效的解决方法”\n上下文部分是“当你遇到项目组成员因工资待遇问题发生冲突时”\n指令部分是“解决方法列举5条以上，总字数在200~300之间”\n角色是“目组的负责人”\n\n示例结果如下：\n\n参考学习文章每个人的AI学习手册 (xiaobot.net)\n第10讲：如何更好地提问？ (xiaobot.net)\n","categories":["小灰","AI学习笔记"],"tags":["AI","ChatGPT"]},{"title":"Elasticsearch入门","url":"/2024/03/25/Elasticsearch%E5%85%A5%E9%97%A8/","content":"入门官网\n简介\n一个分布式的、Restful风格的搜索引擎。\n支持对各种类型的数据的检索。\n搜索速度快，可以提供实时的搜索服务。\n便于水平扩展，每秒可以处理PB级海量数据。\n\n常用术语\n索引：与MySQL数据库中的Database相对应\n类型：与MySQL数据库中的Table相对应\n文档: 相当于MySQL中的一条数据，采用JSON结构\n字段：对应MySQL数据库中的一列\n\n在ES6.0之后，前两个术语与MySQL对应逐步发生变化，删除了类型，变成一个索引对应一张表，但是保留了类型这个单词。\n在ES7.0之后，逐步删除类型。\n\n集群：多台服务器组合在一起，分布式部署，提高整体性能\n节点：集群中的每台服务器，称呼为节点\n分片：一个索引相当于一张表，分片则是对这个索引进行划分，提高并发能力。\n副本：对分片进行备份，一个分片可以有多个备份，提高系统可用性。\n\n安装与配置对于Elasticsearch的下载，最好在对应项目中，找到父级依赖所确定的版本，因为这是经过测试，与当前Spring Boot版本最匹配的版本。\n往期版本下载地址\n下载完成后，解压到不含有中文的目录，目录结果如下图所示：\n\n版本不一致，目录结构可能会有所区别。\n配置配置文件配置主要是配置config目录下的elasticsearch.yml文件；配置内容如下所示：\n# 集群名字cluster.name: my-application# 数据存储位置path.data: E:\\Data\\elasticsearch\\es-7.15.2\\data# 运行时产生日志 存储位置path.logs: E:\\Data\\elasticsearch\\es-7.15.2\\logs\n\n配置结果如下图所示：\n\n配置环境变量进入配置环境变量界面步骤：系统-&gt;系统信息-&gt;高级系统设置-&gt;环境变量\n在系统变量的Path中新建环境变量；如下图所示：\n\n安装中文分词插件ES默认进行英文分词，需要安装中文分词插件来对中文进行分词，即可对中文关键词进行检索。\n对应Elasticsearch版本来下载对应的中文分词插件。\n下载地址\n首先在Elasticsearch安装目录下的，plugins目录下，新建一个ik文件夹，然后将分词插件解压到ik目录下，如下图所示：\n\n在config目录下，有许多dic字典文件，里面包含很多中文词语，除此之外，若需要新增当前流行的”网络词语”，需要在IKAnalyzer.cfg.xml文件中进行配置。\n安装ApiPost该工具在操作和界面上与postman类似，但是功能比postman更多，主要用来进行API设计、调试、测试等；且支持中文。\n\nApiPost官网\nPostman官网\n\n因为ES服务器，通过命令行存储某些数据；过长不方便，可以用ApiPost模拟网页，发送HTTP请求，往ES服务器中添加数据更为方便。\n除此之外，当需要查询某些复杂数据时，也可以用ApiPost来简化数据查询。\n运行Elasticsearch可以通过双击bin目录下的elasticsearch.bat文件直接启动，也可以在命令行启动。\n若出现如下报错：\n[DESKTOP-CO3SKTG] error updating geoip database [GeoLite2-ASN.mmdb]\n则在配置文件中添加如下配置，再重新启动即可。\ningest.geoip.downloader.enabled: false\n即禁止geoip数据库的更新。\n启动后结果如下：\n\n常见命令操作因为配置过环境变量，所以可以直接在任意位置的命令行中，执行ES命令。\n查询ES健康状况curl -X GET \"localhost:9200/_cat/health?v\"\nES默认端口为9200，v表示显示标题，使用GET请求获取数据；执行结果如下所示：\n\n第一行是标题，第二行是显示的数据。\n\ntimestamp：表示事件\ncluster：集群名\nstatus：状态；green表示很健康\nnode.total：集群的节点个数\nnode.data：集群数据节点个数\n\n查询节点执行如下命令，查看集群节点；\ncurl -X GET \"localhost:9200/_cat/nodes?v\"\n结果如下：\n\n查看索引执行如下命令；\ncurl -X GET \"localhost:9200/_cat/indices?v\"\n结果如下：\n结果显示当前并未有索引。\n新建索引新建索引采用的是PUT请求，执行命令如下：\ncurl -X PUT \"localhost:9200/test\"\n表示新建test索引；执行结果如下图：\n返回结果为JSON格式。\n此时再次查询索引，则会显示出一条索引，且因为没有给索引进行分片和备份，所以健康状况会显示yellow，结果如下图：\n\n删除索引删除索引，使用DELETE请求，执行命令如下所示：\ncurl -X DELETE \"localhost:9200/test\"\n删除名为test的索引；执行结果如下图所示：\n\n此时再次查询索引则不存在名为test的索引，如下图所示：\n\n使用ApiPost访问ES查询索引如图所示：\n新建索引如图所示：\n\n再次查询索引即可查到名为test的索引，如下图所示：\n\n删除索引如图所示：\n插入数据如下图所示：\n\n使用PUT请求，插入数据，会自动创建索引test，_doc插入数据类型，表示占位，1则是插入数据的id；插入数据格式为JSON。\n查询数据如下图所示：\n查询使用GET请求，表示查询索引为test，占位为_doc下id为1的数据。\n修改数据如下图所示：\n\n修改数据其实与插入数据一致，在同样的位置修改数据，在底层就是先删除该位置原先存在的数据，并插入新的数据。\n删除数据如下图所示：\n\n删除数据使用的是DELETE请求，返回结果确认删除；此时再次查询，则数据不存在，如下图所示：\n\n查询索引对应所有数据如图所示：\n\ntest表示索引名。\n根据索引的单字段条件查询如图所示：\n\nq表示查询的条件，title:互联网则表示含有title字段，且字段内容含有互联网的数据。\n且ES在查询时，会先将条件分割为多个词条，然后去查询包含对应字条的数据。\n根据索引的多字段条件查询如图所示：\n\n多字段查询格式如图所示；**query表示条件，multi_match表示多个匹配，fields则表示匹配条件的字段。**\nSpring整合Elasticsearch引入依赖&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置Elasticsearch在配置文件application.properties中配置如下内容：\n# 连接集群节点spring.elasticsearch.uris=localhost:9200\n\n出现Redis与Elasticsearch发生Netty冲突主要是Redis与Elasticsearch都调用了NettyRuntime类的setAvailableProcessors方法。\n解决办法在Application启动类中，添加如下内容：\n@PostConstruct    // 所注解的方法 会在构造器调用完以后调用    public void init() {        // 解决Netty启动冲突问题        // 由Netty4Utils.setAvailableProcessors()得        System.setProperty(\"es.set.netty.runtime.available.processors\", \"false\");    }\n\n配置实体即配置项目实体与ElasticSearch相对应；即可自动生成与某实体相对应的索引；具体实体类配置如下所示：\n/** * @author 花木凋零成兰 * @date 2024/3/4 20:16 */@Document(indexName = \"discusspost\")    // 与Elasticsearch关联 设置索引 注意不能出现大写字母public class DiscussPost {    @Id // 与ES索引对应字段    private int id;    @Field(type = FieldType.Integer)    // type字段类型    private int userId;    /**     * analyzer时候的解析器   ik_max_word 尽可能的拆分     * searchAnalyzer搜索时候的解析器   ik_smart 灵活的拆分     */    @Field(type = FieldType.Text, analyzer = \"ik_max_word\", searchAnalyzer = \"ik_smart\")    private String title;    @Field(type = FieldType.Text, analyzer = \"ik_max_word\", searchAnalyzer = \"ik_smart\")    private String content;    @Field(type = FieldType.Integer)    private int type;    @Field(type = FieldType.Integer)    private int status;    @Field(type = FieldType.Date)    private Date createTime;    @Field(type = FieldType.Integer)    private int commentCount;    @Field(type = FieldType.Double)    private double score;}\n\n配置接口配置完实体类后，还需要配置对ES操作接口，即接口内自动包含了与ES有关的API；接口配置如下所示：\n/** * ES操作接口 * @author 花木凋零成兰 * @date 2024/3/25 21:14 */@Repositorypublic interface DiscussPostRepository extends ElasticsearchRepository&lt;DiscussPost, Integer&gt; {}\n\n自定义接口继承ElasticsearchRepository&lt;K, V&gt;类，自定义接口内即有关于ES操作的API，K指操作的数据实体类型，V指数据实体类型的id类型。\n测试在ES7中，ElasticsearchRepository主要用来实现简单的对数据增删改查，即主要用于实现简单操作；ElasticsearchRestTemplate类则主要用来实现对数据的复杂查询等；即主要用户复杂的数据操作。\n测试代码如下：\n/** * @author 花木凋零成兰 * @date 2024/3/25 21:15 */@SpringBootTest@ContextConfiguration(classes = Application.class)        // 使用Application类的配置public class ElasticsearchTests {    @Autowired    private DiscussPostMapper discussPostMapper;    @Autowired()    private DiscussPostRepository discussPostRepository;    @Autowired    private ElasticsearchRestTemplate elasticsearchRestTemplate; // 多用于复杂查询    @Test    public void insertTest() {        // 测试插入数据 若不存在索引 会自动创建        discussPostRepository.save(discussPostMapper.selectDiscussPostById(241));   // 每次插入一条数据        discussPostRepository.save(discussPostMapper.selectDiscussPostById(242));        discussPostRepository.save(discussPostMapper.selectDiscussPostById(243));    }    @Test    public void insertListTest() {        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(101, 0, 100));   // 一次性插入多条数据        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(102, 0, 100));   // 一次性插入多条数据        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(103, 0, 100));   // 一次性插入多条数据        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(111, 0, 100));   // 一次性插入多条数据        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(112, 0, 100));   // 一次性插入多条数据        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(131, 0, 100));   // 一次性插入多条数据        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(132, 0, 100));   // 一次性插入多条数据        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(133, 0, 100));   // 一次性插入多条数据        discussPostRepository.saveAll(discussPostMapper.selectDiscussPosts(134, 0, 100));   // 一次性插入多条数据    }    @Test    public void updateTest() {        DiscussPost discussPost = discussPostMapper.selectDiscussPostById(231);        discussPost.setContent(\"我是Java程序员，我要好好学Java!\");        discussPostRepository.save(discussPost);    // 在同样id处重新插入数据 覆盖原先数据    }    @Test    public void deleteTest() {        discussPostRepository.deleteById(231);  // 根据id删除数据    }    @Test    public void deleteAllTest() {        discussPostRepository.deleteAll();  // 一次性删除所有数据    }    @Test    public void testSearch() {        // 构造搜索条件        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(\"互联网寒冬\", \"title\", \"content\"))    // 构建搜索条件 多字段查询内容                .withSorts(                        SortBuilders.fieldSort(\"type\").order(SortOrder.DESC), // 构建排序顺序 先按照type倒序排                        SortBuilders.fieldSort(\"score\").order(SortOrder.DESC), // 再按score倒序排                        SortBuilders.fieldSort(\"createTime\").order(SortOrder.DESC)  // 再按创建时间 倒序排                )                .withPageable(PageRequest.of(0, 10))    // 分页查询 第几页, 该页显示数据数量                .withHighlightFields(   // 配置字段高亮显示                        new HighlightBuilder.Field(\"title\").preTags(\"&lt;em&gt;\").postTags(\"&lt;/em&gt;\"),                        new HighlightBuilder.Field(\"content\").preTags(\"&lt;em&gt;\").postTags(\"&lt;/em&gt;\")                )                .build();        SearchHits&lt;DiscussPost&gt; searchHits = elasticsearchRestTemplate.search(searchQuery, DiscussPost.class);        if (searchHits.getTotalHits() &lt;= 0) {      // 若查询无数据            new PageImpl&lt;DiscussPost&gt;(null, PageRequest.of(0, 20), 0);        }        List&lt;DiscussPost&gt; discussPostList = searchHits.stream().map(SearchHit::getContent).collect(Collectors.toList());    // 将查询的数据转化为List集合        Page&lt;DiscussPost&gt; page = new PageImpl&lt;&gt;(discussPostList, searchQuery.getPageable(), searchHits.getTotalHits());        System.out.println(page.getTotalElements());  // 获取总数        System.out.println(page.getNumber());    // 获取页码        System.out.println(page.getSize());  // 获取每页个数        System.out.println(page.getTotalPages());    // 分页总数        for (DiscussPost discussPost : page) {            System.out.println(discussPost);    // 输出查询结果        }    }    @Test    public void testSearchByTemplateHighLight() {   // 按条件查询数据 实现高亮        NativeSearchQuery searchQuery = new NativeSearchQueryBuilder()                .withQuery(QueryBuilders.multiMatchQuery(\"互联网寒冬\", \"title\", \"content\"))    // 构建搜索条件 多字段查询内容                .withSorts(                        SortBuilders.fieldSort(\"type\").order(SortOrder.DESC), // 构建排序顺序 先按照type倒序排                        SortBuilders.fieldSort(\"score\").order(SortOrder.DESC), // 再按score倒序排                        SortBuilders.fieldSort(\"createTime\").order(SortOrder.DESC)  // 再按创建时间 倒序排                )                .withPageable(PageRequest.of(0, 10))    // 分页查询 第几页, 该页显示数据数量                .withHighlightFields(                        new HighlightBuilder.Field(\"title\").preTags(\"&lt;em&gt;\").postTags(\"&lt;/em&gt;\"),                        new HighlightBuilder.Field(\"content\").preTags(\"&lt;em&gt;\").postTags(\"&lt;/em&gt;\")                )   // 配置字段高亮显示                .build();        SearchHits&lt;DiscussPost&gt; searchHits = elasticsearchRestTemplate.search(searchQuery, DiscussPost.class);        // SearchPage&lt;DiscussPost&gt; page = SearchHitSupport.searchPageFor(searchHits, searchQuery.getPageable());        // 获取高亮结果集        List&lt;DiscussPost&gt; list = new ArrayList&lt;&gt;();        for (SearchHit&lt;DiscussPost&gt; searchHit : searchHits) {            DiscussPost discussPost = searchHit.getContent();            if (searchHit.getHighlightFields().get(\"title\") != null) {                discussPost.setTitle(searchHit.getHighlightFields().get(\"title\").get(0));                // discussPost.setContent(searchHit.getHighlightField(\"content\").toString());            }            if (searchHit.getHighlightFields().get(\"content\") != null) {                discussPost.setContent(searchHit.getHighlightFields().get(\"content\").get(0));                // discussPost.setContent(searchHit.getHighlightField(\"content\").toString());            }            list.add(discussPost);        }        // 组装分页对象        Page&lt;DiscussPost&gt; pageInfo = new PageImpl&lt;&gt;(list, searchQuery.getPageable(), searchHits.getTotalHits());        System.out.println(pageInfo.getTotalElements());    // 获取查询得到数据总数        System.out.println(pageInfo.getTotalPages());   // 获取总页数        System.out.println(pageInfo.getNumber());   // 获取当前页码        System.out.println(pageInfo.getSize());     // 获取当前页面个数        // 输出分页结果        for (DiscussPost discussPost : pageInfo) {            System.out.println(discussPost);        }    }}\n\n因测试数据过多，此处只展示最后一个测试方法执行成功结果；如下所示：\n\n","categories":["开发学习","Elasticsearch"],"tags":["Spring","Spring Boot","Elasticsearch"]},{"title":"Kafka快速入门","url":"/2024/03/19/Kafka%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","content":"入门官网\n简介\nKafka是一个分布式的流媒体平台\n应用：\n消息系统\n日志收集\n用户行为追踪\n流式处理\n\n\n\n特点\n高吞吐量\n消息持久化\n高可靠性\n高扩展性\n\n常用术语\nBroker：集群中的服务器\nZookeeper：服务管理\nTopic：主题，Kafka发送消息为发布订阅模式，用来存放消息的空间为Topic\nPartition：分区，对Topic进行分区，可以多线程读写Topic\nOffset：消息在分区内存放的索引序列\nLeader Replica：主副本，对数据做备份；提高容错率，响应读取\nFollower Replica：随从副本，从主副本做备份；主副本出问题时，从 从副本中随机选取一个作为主副本\n\n安装下载地址：\nKafka不分平台，虽然压缩包格式为tgz，但是解压后，一样可以在Windows运行。\n配置压缩包解压到不含中文的目录下后，在config包中进行配置；\n\n配置Zookeeper.properties对Zookeeper相关的集群做配置；配置Zookeeper数组存放位置；如下所示：\n\n配置server.properties主要配置Kafka日志文件存放位置；在配置文件中的第62行如下图所示：\n\n运行kafka进入config同层级目录的bin目录中，因为是Windows系统，所以进入windows包中，执行命令。\n先启动Zookeeper在初级目录(解压后可以看到bin以及config的目录)下；执行如下命令启动Zookeeper：\nbin\\windows\\zookeeper-server-start.bat config\\zookeeper.properties\n\n即使用config目录下的zookeeper配置文件，启动zookeeper；启动结果如下：\n再启动Kafka进入kafka_2.13-3.2.3后；执行如下命令启动kafka；\nbin\\windows\\kafka-server-start.bat config\\server.properties\n启动后结果如下：\n\n启动成功启动成功后可以在之前，在配置文件中，配置的Zookeeper数据目录和Kafka日志保存目录中查看自动创建的文件；如下图所示：\n\n使用Kafka进入包含命令的Windows命令包目录(kafka_2.13-3.2.3\\bin\\windows)下\n创建主题因为Kafka作为一个消息队列；采用的是发布订阅模式；需要将消息发布到某个主题下，首先需要创建主题;\n主题：\n\n代表一个位置\n代表一种消息的类别\n\n使用如下命令创建主题:\nkafka-topics.bat --create --创建主题的服务器 地址:端口 --创建副本 副本数 --分区 分区数 --topic 主题名\n\n执行成功案例如下图所示：\n\n运行如下命令查看主题：\nkafka-topics.bat --list --指定主题所在服务器 地址:端口\n\n执行示例如下：\n\n发送消息主题创建成功后，需要再往主题上发送消息；发送消息是以生产者模式身份发送；执行如下命令：\nkafka-console-producer.bat --服务器列表 服务器地址:端口 --topic 主题名\n\n执行上述命令后，即可输入需要发布的消息；执行示例如下：\n\n接收消息在新的命令行窗口，重新进入目录(kafka_2.13-3.2.3\\bin\\windows)下；以消费者身份接收消息；执行命令如下：\nkafka-console-consumer.bat --指定服务器 读取消息的服务器地址:端口 --topic 读取消息的主题名 --从头开始读取消息\n\n执行示例如下所示：\n\nSpring整合Kafka引入依赖在项目pom文件中引入以下依赖：\n&lt;!-- https://mvnrepository.com/artifact/org.springframework.kafka/spring-kafka --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;&lt;/dependency&gt;\n\n配置Kafka在application.properties文件中，进行如下配置：\n# 配置服务器列表spring.kafka.bootstrap-servers=localhost:9092# 消费者分组id   在Kafka的消费者配置文件中有# 可在配置文件中 更改分组id 更改后需要重新启动kafkaspring.kafka.consumer.group-id=test-consumer-group# 是否自动提交 消费者的偏移量spring.kafka.consumer.enable-auto-commit=true# 自动提交频率 此处配置3000msspring.kafka.consumer.auto-commit-interval=3000\n\n访问Kafka主要是通过生产者发送消息；消费者监听消息，测试在Spring中使用Kafka代码如下：\n/** * @author 花木凋零成兰 * @date 2024/3/23 23:41 */@SpringBootTest@ContextConfiguration(classes = Application.class)        // 使用Application类的配置public class KafkaTests {    @Autowired    private KafkaProducer kafkaProducer;    @Test    public void testKafka() {        // 发送消息        kafkaProducer.send(\"test\", \"你好\");        kafkaProducer.send(\"test\", \"在干嘛\");        try {            Thread.sleep(1000 * 20);    // 阻塞主线程 用户观察消费者是否接收到消息        } catch (InterruptedException e) {            throw new RuntimeException(e);        }    }}/** * 生产者 */@Componentclass KafkaProducer {    @Autowired    private KafkaTemplate kafkaTemplate;    /**     * 发送消息方法     * @param topic 主题     * @param content 发送消息的内容     */    public void send(String topic, String content) {        kafkaTemplate.send(topic, content);    }}/** * 消费者 */@Componentclass KafkaConsumer {    /**     * 监听主题发送的消息     * @param record    消息自动封装为ConsumerRecord     */    @KafkaListener(topics = {\"test\"})   // 需要监听的主题    public void handleMessage(ConsumerRecord record) {        System.out.println(record.value()); // 读取消息    }}\n\n运行测试后，成功结果如下所示，可观察到消费者读取到生产者发送的消息\n\n","categories":["开发学习","Kafka"],"tags":["Spring","Spring Boot","Kafka"]},{"title":"KamaCoder_54_替换数字","url":"/2023/12/18/KamaCoder-54-%E6%9B%BF%E6%8D%A2%E6%95%B0%E5%AD%97/","content":"替换数字题目页面 (kamacoder.com)\n时间限制：1.000S  空间限制：128MB\n题目描述给定一个字符串 s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。 例如，对于输入字符串 “a1b2c3”，函数应该将其转换为 “anumberbnumbercnumber”。\n输入描述输入一个字符串 s,s 仅包含小写字母和数字字符。\n输出描述打印一个新的字符串，其中每个数字字符都被替换为了number\n输入示例a1b2c3\n\n输出示例anumberbnumbercnumber\n\n提示信息数据范围：。\n解法一(模拟)思路分析：\n\n根据题目意思，直接暴力模拟即可，首先读取输入的字符串，然后对字符串进行遍历，若发现字符串属于数字字符，则将其替换为number\n\n遍历完读取的字符串后，返回结果字符串\n\n\n实现代码如下：\nimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.Scanner;import java.util.StringTokenizer;/** * 54. 替换数字（第八期模拟笔试） * @author 花木凋零成兰 * */public class Main{    public static void main(String[] args) throws IOException {//        Scanner scanner = new Scanner(System.in);        String s = Reader.nextLine();  // 读取字符串        int n = s.length();     // 字符串的长度        // StringBuilder ans = new StringBuilder();  // 返回结果字符串        int count = 0;      // 记录数字字符个数        for (int i = 0; i &lt; n; ++i) {            char ch = s.charAt(i);            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {   // 若为数字字符 则计数                ++ count;            }        }        int len = n + count*5;        char[] ans = new char[len];        int index = 0;        for (int i = 0; i &lt; n; ++i) {            char ch = s.charAt(i);            if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') {   // 若为数字字符 则替换为number                ans[index++] = 'n';                ans[index++] = 'u';                ans[index++] = 'm';                ans[index++] = 'b';                ans[index++] = 'e';                ans[index++] = 'r';            } else {                ans[index++] = ch;            }        }        // System.out.println(new String(ans));        PrintWriter out = new PrintWriter(System.out);  // 快速输出        out.println(new String(ans));        out.flush();    }}/** * 快读 */class Reader {    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));    static StringTokenizer tokenizer = new StringTokenizer(\"\");    static String nextLine() throws IOException {// 读取下一行字符串        return reader.readLine();    }    static String next() throws IOException {   // 读取下一个字符串        while (!tokenizer.hasMoreTokens()) {            tokenizer = new StringTokenizer(reader.readLine());        }        return tokenizer.nextToken();    }    static int nextInt() throws IOException {// 读取下一个int型数值        return Integer.parseInt(next());    }    static double nextDouble() throws IOException {// 读取下一个double型数值        return Double.parseDouble(next());    }}\n\n提交结果如下：\ntime_space_table:/1064/sample.in:AC mem=11264k time=114ms/1064/test1.in:AC mem=11352k time=116ms/1064/test2.in:AC mem=11352k time=113ms/1064/test3.in:AC mem=11364k time=115ms/1064/test4.in:AC mem=11364k time=110ms/1064/test5.in:AC mem=11376k time=115ms/1064/test6.in:AC mem=11376k time=111ms/1064/test7.in:AC mem=11376k time=113ms/1064/test8.in:TLE mem=11428k time=117ms\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["卡码网","第八期模拟笔试"],"tags":["刷题"]},{"title":"KamaCoder_55_右旋字符串","url":"/2023/12/18/KamaCoder-55-%E5%8F%B3%E6%97%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"右旋字符串时间限制：1.000S  空间限制：128MB\n题目描述字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串 s 和一个正整数 k，请编写一个函数，将字符串中的后面 k 个字符移到字符串的前面，实现字符串的右旋转操作。 \n例如，对于输入字符串 “abcdefg” 和整数 2，函数应该将其转换为 “fgabcde”。\n输入描述输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串 s，代表需要旋转的字符串。\n输出描述输出共一行，为进行了右旋转操作后的字符串。\n输入示例2abcdefg\n\n输出示例fgabcde\n\n提示信息数据范围：,;\n解法一(模拟)思路分析：\n\n读取字符串，然后将字符串转化为字符数组，再在该字符数组的基础上进行旋转\n\n由k将字符串分成两部分[0, n-k]和[n-k+1, n-1]两部分，而最终得到的结果将第二部分移动到第一部分前面\n\n可以先将整个字符串反转，然后再将这两部分分别反转，即可完成\n\n\n实现代码如下：\nimport java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.io.PrintWriter;import java.util.StringTokenizer;public class Main {    public static void main(String[] args) throws IOException {        // 读取k        int k = Reader.nextInt();        // 读取字符串        String s = Reader.nextLine();        // 将字符串转化为字符数组        char[] str = s.toCharArray();        // 先反转整个字符串        reverseString(str, 0, str.length-1);        // 再反转原先的第二部分        reverseString(str, 0, k-1);        // 反转原先的第一部分        reverseString(str, k, str.length-1);        // 输出右旋转后的字符串        PrintWriter out = new PrintWriter(System.out);        out.println(new String(str));        out.flush();    // 刷新快速输出流    }    // 相向双指针 实现字符串反转    public static void reverseString(char[] str, int left, int right) {        while (left &lt; right) {            str[left] ^= str[right];            str[right] ^= str[left];            str[left] ^= str[right];            ++ left;            -- right;        }    }}class Reader {        static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));        static StringTokenizer tokenizer = new StringTokenizer(\"\");        static String nextLine() throws IOException {       // 读取下一行字符串            return reader.readLine();        }        static String next() throws IOException {      // 读取下一个单词            while (!tokenizer.hasMoreTokens()) {                tokenizer = new StringTokenizer(reader.readLine());            }            return tokenizer.nextToken();        }        static int nextInt() throws IOException {       // 读取一个Int型整数值            return Integer.parseInt(next());        }}\n\n提交结果如下：\ntime_space_table:/1065/sample.in:AC mem=11296k time=108ms/1065/test1.in:AC mem=11328k time=115ms/1065/test2.in:AC mem=11372k time=115ms/1065/test3.in:AC mem=11372k time=113ms/1065/test4.in:AC mem=11372k time=114ms/1065/test5.in:AC mem=11372k time=116ms/1065/test6.in:AC mem=11372k time=112ms/1065/test7.in:AC mem=11372k time=114ms\n\n复杂度分析：\n\n时间复杂度：，遍历字符串数组\n\n空间复杂度：，使用了一个字符串数组进行反转\n\n\n","categories":["卡码网","第八期模拟笔试"],"tags":["刷题"]},{"title":"LC100.相同的树","url":"/2024/01/05/LC100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","content":"100. 相同的树给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。\n如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n示例 1：\n\n\n输入： p = [1,2,3], q = [1,2,3]输出： true\n\n示例 2：\n\n\n输入： p = [1,2], q = [1,null,2]输出： false\n\n示例 3：\n\n\n输入： p = [1,2,1], q = [1,1,2]输出： false\n\n提示：\n\n两棵树上的节点数目都在范围 [0, 100] 内\n\n\n解法一(递归)思路分析：\n\n采用与LC101.对称二叉树相同的思路来解决\n\n实现代码如下：\nclass Solution {    public boolean isSameTree(TreeNode p, TreeNode q) {        if (p == null &amp;&amp; q == null)            return true;        if (p == null || q == null)            return false;        return p.val == q.val                &amp;&amp; isSameTree(p.left, q.left)                &amp;&amp; isSameTree(p.right, q.right);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.2 MB,击败了5.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(迭代)思路分析：\n\n依旧是与LC101.对称二叉树相同的思路来解决，但是此处使用一个双端队列来代替两个栈\n\n即第一个二叉树 主要进队出队在队列左端；第二个二叉树 主要进队出队在队列右端\n\n\n实现代码如下：\nclass Solution {    public boolean isSameTree(TreeNode p, TreeNode q) {        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offerFirst(p);        deque.offerLast(q);        while (!deque.isEmpty()) {            TreeNode left = deque.pollFirst();            TreeNode right = deque.pollLast();            if (left == null &amp;&amp; right == null) continue;            if (left == null || right == null) return false;            if (left.val != right.val) return false;            // 两者采用一样的遍历顺序 中左右 所以 右指针先进栈 再左指针进栈            deque.offerFirst(left.right);            deque.offerFirst(left.left);            deque.offerLast(right.right);            deque.offerLast(right.left);        }        return true;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40 MB,击败了5.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC1005.K次取反后最大化的数组和","url":"/2024/03/19/LC1005-K%E6%AC%A1%E5%8F%96%E5%8F%8D%E5%90%8E%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8C/","content":"1005.K 次取反后最大化的数组和给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：\n\n选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。\n\n重复这个过程恰好 k 次。可以多次选择同一个下标 i 。\n以这种方式修改数组后，返回数组 可能的最大和 。\n示例 1：\n\n输入： nums = [4,2,3], k = 1输出： 5解释： 选择下标 1 ，nums 变为 [4,-2,3] 。\n\n示例 2：\n\n输入： nums = [3,-1,0,2], k = 3输出： 6解释： 选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。\n\n示例 3：\n\n输入： nums = [2,-3,-1,5,-4], k = 2输出： 13解释： 选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。\n\n提示：\n\n\n\n\n\n解法一(贪心)思路分析：\n\n首先题目要求 求可能的最大和，考虑进行贪心\n即贪心策略：要求数组元素和最大，即将数组元素中为负数的最小的值依次反转，即可得到最大值\n即局部策略为：每次反转数组元素中，最小的元素；从而得到全局最优，数组元素和最大\n那么如何得到最小的元素的位置呢？\n首先可以每次对数组元素进行寻找，找到数组元素的最小值位置，然后进行反转，但是这样复杂度过高，十分麻烦\n因为题目是反转数组元素，且没有强制要求数组元素位置不能更改，即我们可以先对数组元素按照从小到大进行排序，如此最小值的元素位置便可以确定了\n\n\n使用指针index来指向每次反转需要反转的元素位置，那么index指针指向的数组元素会有以下三种情况：\nnums[index] &gt; 0，此时说明指针index前存在的数组元素，均已大于0，因为数组元素是按从小到大排序，出现这种情况有两种可能；\nindex == 0 ，即数组元素均大于0，此时大于0的数已经是最小元素，只需重复反转此时的元素，即可得到最终的元素和最大值\nindex != 0，此时说明，该元素前存在负数，且已经反转，因为负数反转后可能大于正数，所以需要进行判断；从而得到最小的元素\n\n\nnums[index] == 0，此时指向元素为0时，若前面存在存在元素则必定大于0，即只需重复反转此时的元素0，即可得到最终的元素和最大值\nnums[index] &lt; 0，此时index指向的元素，是最小的负数，所以进行反转即可最大程度增加元素和，直接进行反转，反转后++ index即移到下一个负数或需要判断是否需要反复反转的元素。\n\n\n最终需要注意，在反转过程中，注意index指针的变化，始终指向的是数组中的元素，当index越界时，应该-- index，避免越界，出现越界则说明数组元素全为负数，反转后，最小的元素肯定在index-1或index位置上。因为反转后均为正数，所以会出现情况一来进行处理\n\n实现代码如下：\nclass Solution {    public int largestSumAfterKNegations(int[] nums, int k) {        Arrays.sort(nums);\t// 对数组进行从小到大排序        int index = 0;\t// 确定需要反转的数组元素索引        int len = nums.length;        for (int i = 1; i &lt;= k; ++i) {\t// 进行反转            if (index == len)\t// 保证反转的过程中 不越界                -- index;            if (nums[index] &gt; 0) {\t// 当index此时指向的数组元素大于0时 说明前面元素均大于0                if (index != 0) {\t// 若数组大于0的元素不是第一个                    if (nums[index-1] &lt; nums[index])\t// 则判断前一个是否小于当前index指向的元素                        index = index-1;\t// 若前一个元素更小 则移动index 对更小的元素进行反转                }                k = (k-i+1) % 2;\t// 计算当前还需反转元素的次数                if (k == 1) nums[index] = -nums[index];\t// 若剩余次数为奇数 则再反转一次                break;            } else if (nums[index] == 0) {\t// 当index指向元素为0时 说明index前和index后元素均大于0                break;\t//  只需重复反转此时为0的元素即可得到最大可能值 0反转无数次为0 即直接结束反转            } else {                nums[index] = - nums[index];\t// 若此时index指向负数 反转即可                ++ index;\t// 继续尝试反转下一个元素            }        }        int ans = 0;        for (int num : nums) {\t// 对反转后的数组进行求和            ans += num;        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了98.81% 的Java用户    内存消耗:41.3 MB,击败了55.10% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，需要注意对数组排序的时间消耗\n空间复杂度：\n\n","categories":["leetcode"],"tags":["贪心","数组","排序"]},{"title":"LC102.二叉树的层序遍历","url":"/2023/12/31/LC102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"102. 二叉树的层序遍历给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。\n示例 1：\n\n输入： root = [3,9,20,null,null,15,7]输出：[[3],[9,20],[15,7]]\n示例 2：\n输入： root = [1]输出：[[1]]\n示例 3：\n输入： root = []输出：[]\n提示：\n\n树中节点数目在范围 [0, 2000] 内\n\n\n解法一(BFS+队列)思路分析：\n\n对于层序遍历二叉树，可以 采用辅助队列\n\n即根据队列先进先出，每次将一层二叉树结点保存到队列中\n\n然后根据队列中保存的二叉树结点，获取下一层二叉树的结点\n\n然后再继续往下层遍历二叉树\n\n\n实现代码如下：\nclass Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        if (root == null)    // 边界条件            return ans;        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();    // 辅助队列        queue.offer(root);    // 将第一层入队        while (!queue.isEmpty()) {            int size = queue.size();    // 获取该层的节点数            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();    // 保存该层的节点值            for (int i = 0; i &lt; size; ++ i) {    // 对每层结点进行遍历 以及获取下一层                TreeNode node = queue.poll();                level.add(node.val);                if (node.left != null)                    queue.offer(node.left);                if (node.right != null)                    queue.offer(node.right);            }            ans.add(level);    // 保存 每层的结点的遍历结果        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了92.36% 的Java用户    内存消耗:44 MB,击败了5.02% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(递归)思路分析：\n\n首先思考递归的参数，因为需要遍历二叉树并保存二叉树的节点值，所以需要传递二叉树的结点和保存结果参数，同时对于二叉树的层序遍历，需要一层一层进行，因此参数中需要包括二叉树的某结点所属层数，保证可以将其添加到对应的层中\n\n对于递归的返回值，不需要返回值\n\n递归的边界条件；当该结点为空时，则不需要继续往下操作\n\n递归的过程；首先需要判断当前结点是否为某一层的第一个结点，是则需要新建列表并保存该节点。然后将该列表保存到结果中，若不是第一个结点，则将其添加的对应的层的列表中\n\n\n实现代码如下：\nclass Solution {    // 递归    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        BFS(root, 0, ans);        return ans;    }    private void BFS(TreeNode node, int deeply, List&lt;List&lt;Integer&gt;&gt; ans) {        if (node == null)    // 已经遍历到最后一层结束            return ;        if (deeply &gt;= ans.size()) {    // 出现新层            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();            level.add(node.val);            ans.add(level);        } else {    // 该结点在已经建立的层中            ans.get(deeply).add(node.val);        }        BFS(node.left, deeply+1, ans);    // 继续向左遍历        BFS(node.right, deeply+1, ans);    // 继续向右遍历    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.6 MB,击败了9.20% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","广度优先搜索","二叉树"]},{"title":"LC101.对称二叉树","url":"/2024/01/05/LC101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"101. 对称二叉树给你一个二叉树的根节点 root ， 检查它是否轴对称。\n示例 1：\n\n输入： root = [1,2,2,3,4,4,3]输出： true\n示例 2：\n\n输入： root = [1,2,2,null,3,null,3]输出： false\n提示：\n\n树中节点数目在范围 [1, 1000] 内\n\n\n进阶： 你可以运用递归和迭代两种方法解决这个问题吗？\n解法一(递归)思路分析：\n\n对于该题使用递归思路比较简单，即比较对称位置的两个节点是否相等\n\n对于递归的参数，则传递需要比较的两个节点，同时返回值则返回比较结果，相等则继续返回true，不相等则返回false\n\n对于递归的边界条件，需要注意的是，当对称位置两个节点均为null时，也算相等，所以两个节点存在且只有一个节点为null时，显然直接返回false\n\n至于递归过程，则是判断当前 对称位置的两个节点是否相等，然后继续往下递归\n\n\n实现代码如下：\nclass Solution {    public boolean isSymmetric(TreeNode root) {        // 注意题目条件 root != null        return doIsSymmetric(root.left, root.right);    }    private boolean doIsSymmetric(TreeNode left, TreeNode right) {        if (left == null &amp;&amp; right != null)            return false;        if (left != null &amp;&amp; right == null)            return false;        if (left == null &amp;&amp; right == null)            return true;        // 相等比较 节点值        然后接着判断其余节点        return left.val == right.val &amp;&amp; doIsSymmetric(left.left, right.right) &amp;&amp; doIsSymmetric(left.right, right.left);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.4 MB,击败了13.09% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，对二叉树的节点进行遍历\n\n空间复杂度：，考虑递归对栈的消耗\n\n\n解法二(迭代+栈)思路分析：\n\n根据递归，在计算机底层使用栈来实现，所以对于该题可以使用栈来进行迭代求解\n\n因为题目给出二叉树至少有一个根节点，且对于根节点是否对称不需判断，因此可以使用两个栈，分别对二叉树的左右子树进行遍历。\n\n根据对称，对二叉树的左子树采用中左右的顺序进行遍历，对于二叉树的右子树采用中右左的顺序进行遍历，然后判断是否对称。\n\n\n实现代码如下：\nclass Solution {    public boolean isSymmetric(TreeNode root) {        // 注意题目条件 root != null        if  (root.left == null &amp;&amp; root .right != null)            return false;    // 边界        if (root.left == null &amp;&amp; root.right == null)            return true;    // 边界特殊情况        if (root.left != null &amp;&amp; root.right == null)            return false;        Deque&lt;TreeNode&gt; leftSt = new LinkedList&lt;&gt;();    // 对左子树按 中左右 进行遍历        Deque&lt;TreeNode&gt; rightSt = new LinkedList&lt;&gt;();    // 对右子树按 中右左 进行遍历        leftSt.push(root.left);        // 左子树第一个节点进栈        rightSt.push(root.right);    // 右子树第一个节点进栈        while (!leftSt.isEmpty() &amp;&amp; !rightSt.isEmpty()) {            TreeNode left = leftSt.pop();            TreeNode right = rightSt.pop();            if (left == null &amp;&amp; right == null)                continue;            if (left == null &amp;&amp; right != null)                return false;            if (left != null &amp;&amp; right == null)                return false;            if (left.val != right.val)                return false;            // 左子树 先进右节点 再进左节点            leftSt.push(left.right);            leftSt.push(left.left);            // 右子树 先进左节点 再进右节点            rightSt.push(right.left);            rightSt.push(right.right);        }        // 左右遍历栈 均为空 则说明对每个节点均完成对比        return leftSt.isEmpty() &amp;&amp; rightSt.isEmpty();    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了18.71% 的Java用户    内存消耗:40.7 MB,击败了5.07% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n总结：可进一步优化，使用一个双端队列，模拟两个栈\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC104.二叉树的最大深度","url":"/2024/01/03/LC104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","content":"104. 二叉树的最大深度给定一个二叉树 root ，返回其最大深度。\n二叉树的 最大深度 是指从根节点到最远叶子节点的最长路径上的节点数。\n示例 1：\n\n输入： root = [3,9,20,null,null,15,7]输出： 3\n示例 2：\n输入： root = [1,null,2]输出： 2\n提示：\n\n树中节点的数量在 区间内。\n\n\n解法一(BFS+队列)思路分析：\n\n使用层序遍历对二叉树进行遍历，在遍历二叉树的过程中，记录遍历的层数\n\n实现代码如下：\nclass Solution {    public int maxDepth(TreeNode root) {        int ans = 0;        if (root == null)            return ans;        // 边界条件        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            ++ ans;        // 记录层数            for (int i = 0; i &lt; size; ++ i) {                TreeNode node = queue.poll();                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            }        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了22.08% 的Java用户    内存消耗:41.6 MB,击败了8.86% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(前序求深度+递归)思路分析：\n\n根据dfs递归遍历二叉树，并在遍历的过程标记某二叉树的节点所在层数\n\n即递归参数主要有两个，一个是二叉树结点，另一个是该节点所在层数\n\n递归边界条件，即为结点为空时，不再往下遍历\n\n递归过程，即比较该层是否为最大深度即可\n\n\n实现代码如下：\nclass Solution {    int ans = 0;    public int maxDepth(TreeNode root) {        getMaxDepth(root, 1);        return ans;    }    private void getMaxDepth(TreeNode node, int depth) {        if (node == null)            return ;        ans = Math.max(ans, depth);        getMaxDepth(node.left, depth+1);        getMaxDepth(node.right, depth+1);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:41.3 MB,击败了16.72% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：，考虑递归对栈的消耗\n\n\n解法三(后序求高度+递归)思路分析：\n\n对于该题，首先注意一个细节，对于该题求根节点的高度即等同于求根节点的最大深度\n\n所以，可以使用 后序遍历求二叉树的最大高度，即根节点的高度来得到二叉树的最大深度。\n\n然后思考递归的参数和返回值；对于该题递归的参数只有二叉树的节点，返回值即为该节点的高度\n\n然后思考递归的边界条件；即当该节点为null时，此时节点高度为0，返回即可\n\n对于递归的过程，则先求左右孩子节点的高度，然后得出最大值，再加一，则得出该节点的高度，返回即可。\n\n\n实现代码如下：\nclass Solution {    public int maxDepth(TreeNode root) {        return getHeight(root);    }    // 后序遍历求二叉树某节点的高度    private int getHeight(TreeNode node) {        if (node == null)            return 0;    // 为空时 节点高度为0        // 左        int leftHeight = getHeight(node.left);        // 右        int rightHeight = getHeight(node.right);        // 中        int height = Math.max(leftHeight, rightHeight) + 1;        return height;        // 返回该节点高度    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:41.3 MB,击败了18.91% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：，考虑递归的空间消耗\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC105.从前序与中序遍历序列构造二叉树","url":"/2024/02/04/LC105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"105.从前序与中序遍历序列构造二叉树给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。\n示例 1:\n\n输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]输出: [3,9,20,null,null,15,7]\n示例 2:\n输入: preorder = [-1], inorder = [-1]输出: [-1]\n提示:\n\n\ninorder.length == preorder.length\n\npreorder 和 inorder 均 无重复 元素\ninorder 均出现在 preorder\npreorder 保证 为二叉树的前序遍历序列\ninorder 保证 为二叉树的中序遍历序列\n\n解法一(递归+分治+Map)思路分析：\n\n参考从中序与后序遍历序列构造二叉树解法二，来解决该题\n首先需要确定前序遍历为：中左右，中序遍历为：左中右；所以根据前序遍历来确定根节点，然后通过根节点对中序数组进行分割\n可以建立中序数组的哈希表，来提高分割效率\n因为前序遍历的根节点索引，是从前往后获得，所以需要先建立树的左子树，再建立树的右子树\n对于递归的参数，将中序数组、前序数组、Map变量；赋值为全局变量后，参数只需包括中序数组的左右端指针\n且递归函数返回类型为TreeNode\n\n实现代码如下：\nclass Solution {    int[] preorder;    // 前序遍历数组    int[] inorder;\t// 中序遍历数组    Map&lt;Integer, Integer&gt; inMap;\t// 中序遍历数组 索引表    int preIndex;\t// 前序遍历数组 标识根节点值 索引    public TreeNode buildTree(int[] preorder, int[] inorder) {        if (preorder == null)            return null;\t// 边界条件 数组为空时 返回空树        // 对全局变量 进行赋值        this.preorder = preorder;        this.inorder = inorder;        inMap = new HashMap&lt;&gt;();        preIndex = 0;        // 构建中序遍历数组 索引表        for (int i = 0; i &lt; inorder.length; i++) {            inMap.put(inorder[i], i);        }        return doBuildTree(0, inorder.length-1);\t// 递归构建二叉树    }    private TreeNode doBuildTree(int inLeft, int inRight) {        if (inLeft &gt; inRight)            return null;\t// 若左端点 大于 右端点 则为空树        int value = preorder[preIndex];\t\t// 获取 树 根节点值        TreeNode node = new TreeNode(value);\t// 构建树        int index = inMap.get(value);\t// 根据 根节点值 获取分割中序数组索引        preIndex ++;\t// 移动根节点索引        // 先构建左子树        node.left = doBuildTree(inLeft, index - 1);        // 再构建右子树        node.right = doBuildTree(index + 1, inRight);        return node;\t// 构建完成后 将树返回    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了99.35% 的Java用户    内存消耗:43.3 MB,击败了21.31% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","数组","哈希表","分治"]},{"title":"LC106.从中序与后序遍历序列构造二叉树","url":"/2024/01/22/LC106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"106. 从中序与后序遍历序列构造二叉树给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。\n示例 1:\n\n输入： inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]输出：[3,9,20,null,null,15,7]\n示例 2:\n输入： inorder = [-1], postorder = [-1]输出：[-1]\n提示:\n\n\npostorder.length == inorder.length\n\ninorder 和 postorder 都由 不同 的值组成\npostorder 中每一个值都在 inorder 中\ninorder 保证是树的中序遍历\npostorder 保证是树的后序遍历\n\n解法一(递归+分治+Map哈希)思路分析：\n\n对于该题，首先思考；中序遍历为：左中右，后序遍历为：左右中，因此通过后序遍历可以确认二叉树的根节点，然后通过根节点可以对中序遍历进行切割成：左中序、右中序；然后根据得到的左中序长度，可以对后序遍历进行切割成：左后序、右后序\n以此类推，通过递归分治的方式，可以从根节点建立一个二叉树。\n同时思考递归的参数和返回值，因为题目要求构造一个二叉树，所以 返回值类型为TreeNode，然后对于递归的参数则包括，中序遍历数组、后序遍历数组、中序数组起始位置、中序数组末尾位置、后序数组起始位置、后序数组末尾位置。\n对于递归的边界条件，则当后序遍历数组为null时，返回null，当由后序遍历索引起始及末尾位置得；数组长度为1时，直接返回\n对于递归的过程，则是构造中间节点，以及递归构造左右节点\n同时对于如何根据后序数组，对中序数组进行分割，可以使用Map哈希表的方式，避免对中序数组进行反复查询。\n\n实现代码如下：\nclass Solution {    public TreeNode buildTree(int[] inorder, int[] postorder) {        if (postorder == null)            return null;\t// 边界条件        // 构造哈希表        Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; inorder.length; i++) {            inMap.put(inorder[i], i);        }        return doBuildTree(inorder, postorder, inMap, 0, inorder.length-1, 0, postorder.length-1);    }    private TreeNode doBuildTree(int[] inorder, int[] postorder, Map&lt;Integer, Integer&gt; inMap, int inS, int inE, int postS, int postE) {        if (inE &lt; 0 || postE &lt; 0 || inS &gt; inE || postS &gt; postE || inS &gt;= inorder.length || postS &gt;= postorder.length) // 考虑边界问题            return null;        // 根据后序遍历数组 末尾索引 获取该子树根节点值        int rootValue = postorder[postE];        TreeNode node = new TreeNode(rootValue);\t// 构造二叉树        if (postS == postE)\t\t// 若此时后序数组 起始索引和末尾索引相等 说明为叶子节点            return node;\t// 直接返回        // 根据根节点值 对中序数组进行分割 获取分割位置索引        int index = inMap.get(rootValue);        // 递归获取左右子树        node.left = doBuildTree(inorder, postorder, inMap, inS, index-1, postS, postS+index-1-inS);        node.right = doBuildTree(inorder, postorder, inMap, index+1, inE, postS+index-inS, postE-1);        return node;    }}\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了62.35% 的Java用户    内存消耗:43.5 MB,击败了13.55% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，需要遍历数组\n空间复杂度：，考虑递归对空间的消耗\n\n优化解法一思路分析：\n\n通过对解法一代码的执行流程，发现递归函数doBuildTree中的inorder参数可以省略\n且对于doBuildTree函数中的边界问题判断，由于初始inE与PostE均为len-1，inS与postS初始为0，因此对于inE &lt; 0的判断与inS &gt;= inorder.length的判断包含在inS &gt; inE中，可省略\n\n实现代码如下：\nclass Solution {    public TreeNode buildTree(int[] inorder, int[] postorder) {        if (postorder == null)            return null;\t// 边界条件        // 构造哈希表        Map&lt;Integer, Integer&gt; inMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; inorder.length; i++) {            inMap.put(inorder[i], i);        }        return doBuildTree(postorder, inMap, 0, inorder.length-1, 0, postorder.length-1);    }    private TreeNode doBuildTree(int[] postorder, Map&lt;Integer, Integer&gt; inMap, int inS, int inE, int postS, int postE) {        if (inS &gt; inE || postS &gt; postE) // 考虑边界问题            return null;        // 根据后序遍历数组 末尾索引 获取该子树根节点值        int rootValue = postorder[postE];        TreeNode node = new TreeNode(rootValue);\t// 构造二叉树        if (postS == postE)\t\t// 若此时后序数组 起始索引和末尾索引相等 说明为叶子节点            return node;\t// 直接返回        // 根据根节点值 对中序数组进行分割 获取分割位置索引        int index = inMap.get(rootValue);        // 递归获取左右子树        node.left = doBuildTree(postorder, inMap, inS, index-1, postS, postS+index-1-inS);        node.right = doBuildTree(postorder, inMap, index+1, inE, postS+index-inS, postE-1);        return node;    }}\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了62.35% 的Java用户    内存消耗:43.6 MB,击败了10.93% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历中序数组和后序数组\n空间复杂度：，考虑每层递归传递参数对空间消耗。\n\n解法二(递归+分治+Map)思路分析：\n\n跟据官方题解，将中序数组、后序数组，以及提交查询的Map变量，均改为全局遍历，即不需要作为递归函数参数，可在递归函数内访问。\n因为后序遍历中，最后一个元素为子树的根节点，所以先递归获取右子树，再递归获取左子树\n\n实现代码如下：\nclass Solution {    int[] inorder;\t\t// 中序遍历数组    int[] postorder;\t// 后序遍历数组    Map&lt;Integer, Integer&gt; inMap;\t// 中序遍历数组 索引表    int postIndex;    public TreeNode buildTree(int[] inorder, int[] postorder) {        if (postorder == null)            return null;\t// 边界条件        this.inorder = inorder;        this.postorder = postorder;        postIndex = postorder.length-1;        // 构造哈希表        inMap = new HashMap&lt;&gt;();        for (int i = 0; i &lt; inorder.length; i++) {            inMap.put(inorder[i], i);        }        return doBuildTree(0, inorder.length-1);    }    private TreeNode doBuildTree(int inLeft, int inRight) {        if (inLeft &gt; inRight)\t// 说明此时为空树            return null;        int value = postorder[postIndex];\t// 根据postIndex 来确定当前子树 中节点值        TreeNode node = new TreeNode(value);        // 根据 中间节点值 获取分割中序数组索引        int index = inMap.get(value);        postIndex--;\t// 移动所指向的根节点        // 先获取右子树        node.right = doBuildTree(index+1, inRight);        // 再获取左子树        node.left = doBuildTree(inLeft, index-1);        return node;    }}\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了99.58% 的Java用户    内存消耗:43.2 MB,击败了32.11% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n表示树的节点个数\n空间复杂度：，需要使用的空间存储哈希表，同时的空间进行递归(即二叉树的高度)，且h &lt; n\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","数组","哈希表","分治"]},{"title":"LC107.二叉树的层序遍历II","url":"/2023/12/31/LC107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II/","content":"107. 二叉树的层序遍历 II给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）\n示例 1：\n\n输入： root = [3,9,20,null,null,15,7]输出：[[15,7],[9,20],[3]]\n示例 2：\n输入： root = [1]输出：[[1]]\n示例 3：\n输入： root = []输出：[]\n提示：\n\n树中节点数目在范围 [0, 2000] 内\n\n\n解法一(BFS+队列)思路分析：\n\n使用辅助队列，一层一层遍历二叉树，每次将每层遍历的结果保存到一个列表中\n因为要求返回从底层到顶层的顺序，可以每次保存到列表时从头开始保存，也可以按从上往下顺序保存后，再反转结果列表\n\n实现代码如下：\nclass Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    // 链表从头结点插入花费时间更低        if (root == null)            return ans;        // 边界情况        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();    // 数组型花费更小            for (int i = 0; i &lt; size; ++ i) {                TreeNode node = queue.poll();                level.add(node.val);                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            }            ans.add(0, level);    // 每次插入每层结点 从头插入        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了92.83% 的Java用户    内存消耗:41.9 MB,击败了5.03% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，只考虑对二叉树结点的遍历\n\n空间复杂度：\n\n\n解法二(递归)思路分析：\n\n思路参考LC102.二叉树的层序遍历，在此基础上 需要对最后的结果进行反转\n\n实现代码如下：\nclass Solution {    // 递归    public List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) {        List&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();    // 链表从头结点插入花费时间更低        BFS(root, 0, ans);        Collections.reverse(ans);        return ans;    }    private void BFS(TreeNode node, int deeply, List&lt;List&lt;Integer&gt;&gt; ans) {        if (node == null)            return ;        if (deeply &gt;= ans.size()) {            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();            level.add(node.val);            ans.add(level);        } else {            ans.get(deeply).add(node.val);        }        BFS(node.left, deeply + 1, ans);        BFS(node.right, deeply + 1, ans);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了92.83% 的Java用户    内存消耗:41.4 MB,击败了11.17% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","广度优先搜索","二叉树"]},{"title":"LC108.将有序数组转换为二叉搜索树","url":"/2024/02/26/LC108-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"108.将有序数组转换为二叉搜索树给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。\n高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。\n示例 1：\n\n输入： nums = [-10,-3,0,5,9]输出：[0,-3,9,-10,null,5]解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：\n示例 2：\n\n输入： nums = [1,3]输出：[3,1]解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。\n提示：\n\n\n\nnums 按 严格递增 顺序排列\n\n解法一(递归+模拟)思路分析：\n\n根据二叉搜索树的特点，左子树节点小于中间节点，且右子树节点大于中间节点\n且题目给出数组为严格递增序列，且要求构造的二叉搜索树是 高度平衡的二叉搜索树\n所以很显然，构造二叉树时，应该将数组中间的数值作为根节点\n考虑使用递归的方式构造，首先思考递归的返回值和参数，因为需要获得一个二叉搜索树，所以返回值类型为TreeNode，然后传递的参数，需要有数组参数以及数组的左右节点，确定转化的序列\n然后思考递归的边界条件，即当数组的左边界大于右边界时，不需要再构造，返回null\n然后确定递归的一般过程，即根据数组左右边界确定构造二叉树的根节点，然后再构造左右子树\n\n实现代码如下：\nclass Solution {    public TreeNode sortedArrayToBST(int[] nums) {        return toBSTBySortArray(nums, 0, nums.length-1);\t// 注意转递区间为左闭右闭区间    }    private TreeNode toBSTBySortArray(int[] nums, int left, int right) {        if (left &gt; right)            return null;\t// 说明此时为空数组        int rootValIndex = ((right - left) &gt;&gt; 1) + left;\t// 获取根节点的索引        TreeNode root = new TreeNode(nums[rootValIndex]);        root.left = toBSTBySortArray(nums, left, rootValIndex-1);\t// 构造左子树        root.right = toBSTBySortArray(nums, rootValIndex+1, right);\t// 构造右子树        return root;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:42.1 MB,击败了65.39% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，N指数组的长度\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","数组","分治","二叉搜索树"]},{"title":"LC110.平衡二叉树","url":"/2024/01/12/LC110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"110. 平衡二叉树给定一个二叉树，判断它是否是高度平衡的二叉树。\n本题中，一棵高度平衡二叉树定义为：\n\n一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。\n\n示例 1：\n\n输入： root = [3,9,20,null,null,15,7]输出： true\n示例 2：\n\n输入： root = [1,2,2,3,3,null,null,4,4]输出： false\n示例 3：\n输入： root = []输出： true\n提示：\n\n树中的节点数在范围 [0, 5000] 内\n\n\n解法一(后序遍历+递归)思路分析：\n\n使用后序遍历，先遍历左右节点获取高度进行判断；\n\n若左右子树高度差值不超过1，则符合条件；\n\n如超过1，则不符合条件，返回false；\n\n通过递归的方式求取左右子树的深度\n\n\n实现代码如下：\nclass Solution {    public boolean isBalanced(TreeNode root) {        if (root == null) return true;        // 后序遍历 先遍历获取左右子树高度        int leftHeight = getHeight(root.left);        int rightHeight = getHeight(root.right);        return Math.abs(leftHeight - rightHeight) &lt;= 1                &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);    }    // 后序遍历获取 二叉树高度    private int getHeight(TreeNode node) {        if (node == null)            return 0;        return Math.max(getHeight(node.left), getHeight(node.right)) + 1;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了43.88% 的Java用户    内存消耗:43.2 MB,击败了10.39% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历二叉树结点时，需要遍历求取二叉树结点的高度\n\n空间复杂度：不考虑递归消耗，\n\n\n解法二(优化解法一)思路分析：\n\n首先对于解法一进行思考，每次判断一个结点的左右子节点是否符合要求时，需要再去求左右结点的高度，这种判断是从上向下的，对于下面的一些结点会重复访问多次，时间复杂度过高。\n\n因此可以考虑使用自下向上的判断二叉树是否为高度平衡二叉树，即获取子树高度并判断，然后向上接着判断\n\n若判断子树为平衡，则返回该子树高度，若不平衡则返回-1\n\n\n实现代码如下：\nclass Solution {    public boolean isBalanced(TreeNode root) {        if (root == null) return true;        return getHeight(root) &gt;= 0;    }    // 后序遍历获取 二叉树高度    private int getHeight(TreeNode node) {        if (node == null)            return 0;        // 左        int leftHeight = getHeight(node.left);        // 右        int rightHeight = getHeight(node.right);        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight-rightHeight) &gt; 1)            return -1;\t// 若左子树或右子树或当前子树不平衡 则返回-1        // 若当前子树平衡 则返回其高度        return Math.max(leftHeight, rightHeight) + 1;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.2 MB,击败了10.39% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，自下向上只需遍历一遍二叉树\n\n空间复杂度：，考虑递归二叉树的层数，对空间的消耗\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树"]},{"title":"LC111.二叉树的最小深度","url":"/2024/01/03/LC111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/","content":"111. 二叉树的最小深度给定一个二叉树，找出其最小深度。\n最小深度是从根节点到最近叶子节点的最短路径上的节点数量。\n说明： 叶子节点是指没有子节点的节点。\n示例 1：\n\n输入： root = [3,9,20,null,null,15,7]输出： 2\n示例 2：\n输入： root = [2,null,3,null,4,null,5,null,6]输出： 5\n提示：\n\n树中节点数的范围在 内\n\n\n解法一(BFS+队列)思路分析：\n\n依旧对二叉树进行层序遍历，在遍历的过程中，对结点进行判断，第一个出现的叶子节点即为离根节点最近的叶子节点\n\n实现代码如下：\nclass Solution {    public int minDepth(TreeNode root) {        int ans = 0;        if (root == null)            return ans;        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            ++ ans;    // 记录距离            for (int i = 0; i &lt; size; ++ i) {                TreeNode node = queue.poll();                if (node.left == null &amp;&amp; node.right == null) {                    // 找到最近的叶子节点                    return ans;                }                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            }        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了86.64% 的Java用户    内存消耗:61.6 MB,击败了6.25% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：，辅助队列\n\n\n解法二(前序求深度递归)思路分析：\n\n使用递归来寻找离根节点最近的叶子节点\n\n思考递归参数，即需要传递二叉树的节点和节点所在层数，且不需要返回值\n\n对于递归边界条件，即当节点为空时，不需要往下遍历，同时当遍历到叶子节点时，比较是否为最短距离，并结束递归\n\n递归过程则是，对叶子节点距离根节点的距离作比较，寻找最小距离\n\n\n实现代码如下：\nclass Solution {    int ans = Integer.MAX_VALUE;    public int minDepth(TreeNode root) {        getMinDepth(root, 1);        if (ans == Integer.MAX_VALUE) return 0;        return ans;    }    private void getMinDepth(TreeNode node, int depth) {        if (node == null)            return ;    // 结束遍历        if (node.left == null &amp;&amp; node.right == null) {            ans = Math.min(depth, ans);        // 记录最小深度            return ;        }        getMinDepth(node.left, depth+1);        getMinDepth(node.right, depth+1);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:7 ms,击败了63.76% 的Java用户    内存消耗:62 MB,击败了5.02% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法三(后序求高度递归)思路分析：\n\n对于该题求二叉树的最小深度，即等同于求二叉树根节点到最近叶子节点的高度，因此可以通过后序遍历来求二叉树根节点到最近叶子节点的高度\n\n首先对递归的参数和返回值进行考虑，因为需要遍历二叉树，所以递归传递参数为二叉树节点，同时需要求高度，所以递归函数返回值为int型\n\n然后思考递归的边界条件，因为从叶子节点返回得到高度，所以对于空节点则直接返回0\n\n对于递归的过程，则按照后序遍历，先遍历左右子树，然后进行判断得到当前节点的最小高度\n\n若左子树为null，则返回右子树高度+1\n\n若右子树为null，则返回左子树高度+1\n\n若左右子树均不为null，则返回左右子树最小高度+1\n\n\n\n\n实现代码如下：\nclass Solution {    public int minDepth(TreeNode root) {        return getHeight(root);    }    // 后序遍历递归求二叉树节点高度    private int getHeight(TreeNode node) {        if (node == null)            return 0;    // 边界条件 空节点返回0        // 左        int leftHeight = getHeight(node.left);        // 右        int rightHeight = getHeight(node.right);        // 获取中 高度        int height;        if (node.left != null &amp;&amp; node.right == null)            height = leftHeight+1;        else if (node.left == null &amp;&amp; node.right != null)            height = rightHeight+1;        else height = Math.min(leftHeight, rightHeight)+1;        return height;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:9 ms,击败了37.82% 的Java用户    内存消耗:61.7 MB,击败了7.75% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC112.路径总和","url":"/2024/01/20/LC112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/","content":"112. 路径总和给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。\n叶子节点 是指没有子节点的节点。\n示例 1：\n\n输入： root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22输出： true解释： 等于目标和的根节点到叶节点路径如上图所示。\n示例 2：\n\n输入： root = [1,2,3], targetSum = 5输出： false解释： 树中存在两条根节点到叶子节点的路径：(1 –&gt; 2): 和为 3(1 –&gt; 3): 和为 4不存在 sum = 5 的根节点到叶子节点的路径。\n示例 3：\n输入： root = [], targetSum = 0输出： false解释： 由于树是空的，所以不存在根节点到叶子节点的路径。\n提示：\n\n树中节点的数目在范围 [0, 5000] 内\n\n\n\n解法一(DFS)思路分析：\n\n采用递归的方式，若递归到叶子节点，则判断是否符合要求\n\n首先思考递归的参数和返回值，因题目要求返回Boolean类型变量，所以递归的返回值类型也是Boolean，因为需要对路径上的数值进行求和，所以参数为；二叉树节点和求和的参数\n\n然后思考递归的边界条件，当该节点为null时，返回false\n\n思考递归的过程，当遍历节点为叶子节点时，判断路径和是否等于targetSum，若不等于则返回false，等于则返回true，然后继续向深处遍历\n\n由于该递归所需参数类型和返回值类型与 主函数一致，且对于路径上的数值求和；可以转化为targetSum-node.val，即当遍历到叶子节点，且targetSum为0时，也满足条件，因此将主函数作为递归函数。\n\n\n实现代码如下：\nclass Solution {    public boolean hasPathSum(TreeNode root, int targetSum) {        if (root == null)            return false;\t// 边界条件        targetSum -= root.val;        if (root.left == null &amp;&amp; root.right == null) {\t// 当该节点为叶子节点时            return targetSum == 0;\t// 判断路径上节点值的和是否等于targetSum        }        return hasPathSum(root.left, targetSum) || hasPathSum(root.right, targetSum);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:42 MB,击败了79.86% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：，H是树的高度，空间复杂度主要取决于递归时栈空间的开销\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC113.路径总和 II","url":"/2024/01/21/LC113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CII/","content":"113. 路径总和 II给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。\n叶子节点 是指没有子节点的节点。\n示例 1：\n\n输入： root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22输出：[[5,4,11,2],[5,8,4,5]]\n示例 2：\n\n输入： root = [1,2,3], targetSum = 5输出：[]\n示例 3：\n输入： root = [1,2], targetSum = 0输出：[]\n提示：\n\n树中节点总数在范围 [0, 5000] 内\n\n\n\n解法一(DFS)思路分析：\n\n参考，采用递归的方式，当递归到叶子节点时，判断是否符合条件\n\n先对递归的参数和返回值进行思考，因为题目要求返回满足条件的遍历路径，所以参数主要是，二叉树节点、目标和以及存储路径的列表，对于递归函数，不需要返回其余信息\n\n然后思考递归的边界条件，即二叉树节点为null时，结束递归\n\n然后思考递归的过程，首先判断该节点是否为叶子节点，若是，则判断目标和是否满足题意，若满足则保存路径，不满足则结束递归\n\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();        dfs(root, targetSum, path);        return ans;    }    private void dfs(TreeNode node, int targetSum, List&lt;Integer&gt; path) {        if (node == null)            return ;\t// 边界条件        path.add(node.val);\t\t// 记录路径        targetSum -= node.val;\t// 更新目标值        if (node.left == null &amp;&amp; node.right == null &amp;&amp; targetSum == 0) {            ans.add(path);\t// 保存满足条件的路径        }        dfs(node.left, targetSum, new ArrayList&lt;&gt;(path));\t// 因为new新的列表 包括了回溯过程        dfs(node.right, targetSum, new ArrayList&lt;&gt;(path));    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:3 ms,击败了8.48% 的Java用户    内存消耗:46.2 MB,击败了5.02% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，每次递归，new一个新的列表也需要的时间\n\n空间复杂度：，H是二叉树的高度\n\n\n优化解法一思路分析：\n\n对上述过程进行优化，减少new一个新列表的次数，即将每次递归时的new，修改成每次保存路径时new一个新的列表\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) {        dfs(root, targetSum, new ArrayList&lt;&gt;());        return ans;    }    private void dfs(TreeNode node, int targetSum, List&lt;Integer&gt; path) {        if (node == null)            return ;\t// 边界条件        path.add(node.val);\t\t// 记录路径        targetSum -= node.val;\t// 更新目标值        if (node.left == null &amp;&amp; node.right == null &amp;&amp; targetSum == 0) {            ans.add(new ArrayList&lt;&gt;(path));\t// 保存满足条件的路径        }        dfs(node.left, targetSum, path);        dfs(node.right, targetSum, path);        path.remove(path.size()-1);\t\t// 回溯    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了99.92% 的Java用户    内存消耗:43.6 MB,击败了18.98% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，对节点进行遍历需要消耗时间为，在保存路径的过程中，需要花费来创建新列表，综合为\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","回溯"]},{"title":"LC116.填充每个节点的下一个右侧节点指针","url":"/2024/01/02/LC116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88/","content":"116. 填充每个节点的下一个右侧节点指针给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\nstruct Node {  int val;  Node *left;  Node *right;  Node *next;}\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。\n初始状态下，所有 next 指针都被设置为 NULL。\n示例 1：\n\n输入： root = [1,2,3,4,5,6,7]输出：[1,#,2,3,#,4,5,6,7,#]解释： 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，’#’ 标志着每一层的结束。\n示例 2:\n输入： root = []输出：[]\n提示：\n\n树中节点的数量在  范围内\n\n\n进阶：\n\n你只能使用常量级额外空间。\n使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n解法一(BFS+队列)思路分析：\n\n使用二叉树的层序遍历，对二叉树进行层序遍历\n\n在遍历过程中，将每层的节点进行连接\n\n\n实现代码如下：\nclass Solution {    public Node connect(Node root) {        if (root == null)            return null;        Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            for (int i = 0; i &lt; size; ++ i) {                Node node = queue.poll();                if (i == size-1) // 此时节点为一层最后的节点                    node.next = null;                else // 若不为最后一层节点 则指向队列中的下一个即可                    node.next = queue.peek();                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            }        }        return root;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:3 ms,击败了36.17% 的Java用户    内存消耗:43.1 MB,击败了9.05% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(递归)思路分析：\n\n对于连接某个节点指向下一个同层右节点，具体重复递归的特点，即左节点指向右节点，因此可以思考使用递归来实现\n\n首先思考递归的参数和返回值，因为具有递归特点即为，左节点指向右节点，因此递归的参数为左边节点和右边界点，同时是连接二叉树结点，因此不需要返回值\n\n然后思考递归的边界条件，即当传递的参数左节点为空或传递的参数右结点为空时，结束递归，此外当左结点的next已指向右节点时，也结束递归，避免重复连接\n\n思考递归的过程，即左参数节点的next指向右参数结点\n\n\n实现代码如下：\nclass Solution {    public Node connect(Node root) {        if (root != null)            FConnect(root.left, root.right);        return root;    }    private void FConnect(Node left, Node right) {        if (left == null || left.next == right || right == null)            return ;    // 边界        left.next = right;    // 递归过程 进行连接        FConnect(left.left, left.right);        FConnect(left.right, right.left);        FConnect(right.left, right.right);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.2 MB,击败了5.03% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：，不考虑递归对栈的消耗，则使用常量级空间复杂度\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树","链表"]},{"title":"LC117.填充每个节点的下一个右侧节点指针II","url":"/2024/01/03/LC117-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88II/","content":"117. 填充每个节点的下一个右侧节点指针 II给定一个二叉树：\nstruct Node {  int val;  Node *left;  Node *right;  Node *next;}\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。\n初始状态下，所有 next 指针都被设置为 NULL 。\n示例 1：\n\n输入：root = [1,2,3,4,5,null,7]输出： [1,#,2,3,#,4,5,7,#]解释： 给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化输出按层序遍历顺序（由 next 指针连接），’#’ 表示每层的末尾。\n示例 2：\n输入： root = []输出：[]\n提示：\n\n树中的节点数在范围 [0, 6000] 内\n\n\n进阶：\n\n你只能使用常量级额外空间。\n使用递归解题也符合要求，本题中递归程序的隐式栈空间不计入额外空间复杂度。\n\n解法一(BFS+队列)思路分析：\n\n该题与LC116.填充每个节点的下一个右侧节点指针类似，只是该题中的二叉树不是满二叉树，但是依然可以使用层序遍历来解决\n\n在遍历每层时，对每层结点进行连接\n\n\n实现代码如下：\nclass Solution {    public Node connect(Node root) {        if (root != null) {            Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();            queue.offer(root);            while (!queue.isEmpty()) {                int size = queue.size();                for (int i = 0; i &lt; size; ++ i) {                    Node node = queue.poll();                    if (i == size-1)    // 如果是本层最后一个结点则next指向null                        node.next = null;                    else node.next = queue.peek();    // 不是本层最后一个结点 则指向下一个右侧节点                    if (node.left != null)                        queue.offer(node.left);                    if (node.right != null)                        queue.offer(node.right);                }            }        }        return root;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了28.63% 的Java用户    内存消耗:43.1 MB,击败了5.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(使用已建立的next指针)思路分析：\n\n需要处理树上的所有结点，所以无法降低时间复杂度，但是可以尝试降低空间复杂度；\n\n可以发现的是：在某层的节点建立了next指针的联系后，该层节点形成了一个链表，因此，如果先建立某一层的next指针，再去遍历这一层，就不需要使用队列了\n\n所以如果第i层已经建立next指针，即可以通过next去访问该层所有节点，同时也可以根据第i层的left和right指针获取下一层的节点\n\n所以遍历过程中按照i+1层节点建立next指针\n\n即从根节点开始，因为第0层只有一个节点，不需要处理，可以在上一层为下一层建立next指针，即位于x层时为x+1层建立next指针，完成连接后，再移至x+1层继续建立\n\n每次只需要知道每层的最左边节点，既可以遍历该层，不需要使用队列来访问，可以节省空间。\n\n\n实现代码如下：\nclass Solution {    Node last = null;        // 记录某层已建立next连接的最后一个节点    Node nextStart = null;    // 记录某层的最左节点 即遍历某层的开始节点    public Node connect(Node root) {        if (root != null) {            Node start = root;            while (start != null) {                last = null;                nextStart = null;                for (Node p = start; p != null; p = p.next) {                    if (p.left != null) {    // 若该节点左子节点不为空 则连接                        handle(p.left);                    }                    if (p.right != null) {    // 若该节点右子节点不为空 则连接                        handle(p.right);                    }                }                start = nextStart;    // 更新遍历某层的起始节点            }        }        return root;    }    private void handle(Node p) {        if (last != null) {        // 若连接的节点不是第一个节点 则直接连接            last.next = p;        } else {        // 若连接的节点是第一个节点 则记录            nextStart = p;        }        last = p;    // 更新某层已建立next连接的最后一个节点    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43 MB,击败了5.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：，使用了常量级变量\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树","链表"]},{"title":"LC122.买卖股票的最佳时机II","url":"/2024/03/16/LC122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII/","content":"122.买卖股票的最佳时机II给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n返回 你能获得的 最大 利润 。\n示例 1：\n\n输入： prices = [7,1,5,3,6,4]输出： 7解释： 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。     总利润为 4 + 3 = 7 。\n\n示例 2：\n\n输入： prices = [1,2,3,4,5]输出： 4解释： 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。     总利润为 4 。\n\n示例 3：\n\n输入： prices = [7,6,4,3,1]输出： 0解释： 在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。\n\n提示：\n\n\n\n\n解法一(贪心)思路分析：\n\n对于求最大利润；使用贪心算法进行求解\n首先思考贪心的策略：即在股票价格处于低点时买入，处于价格最高点时卖出，以此获得此次买卖最大利润\n所以，由局部多次最优得到全局最优；即多次获得买卖最大利润，得到总的买卖最大利润\n\n实现代码如下：\nclass Solution {    public int maxProfit(int[] prices) {        int profitCount = 0;\t// 统计多次买卖所得利润        int profit = 0;\t\t// 记录单次买卖所得利润        for (int i = 0; i &lt; prices.length-1; ++ i) {            if (profit == 0 &amp;&amp; prices[i] &lt; prices[i+1]) {\t// 当未开始买卖时 尝试购买最小股票                profit -= prices[i];                if (prices[i] == 0) {\t// 若买入股票花费为0 标记为已购买                    profit -= 1;                    profitCount += 1;                }            }            if (profit &lt; 0 &amp;&amp; prices[i] &gt; prices[i+1]) {\t// 若此时已买入股票 处于股票最大值时 卖出                profitCount += profit + prices[i];                profit = 0;            }        }        if (profit &lt; 0)\t// 若股票还在手里 说明股票在最后一天处于最大值 则卖出            profitCount += profit + prices[prices.length-1];        return profitCount;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了73.83% 的Java用户    内存消耗:44.5 MB,击败了78.44% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n优化解法一思路分析：\n\n即贪心策略依然为：股票价格低时买入，股票价格高时卖出；即当前股票价格小于第二天股票价格时，进行买卖，得到利润为prices[i]-prices[i-1]\n并不需要等到股票价格最大时再卖出，因为当天可以：卖出昨天股票，然后购买当天股票，明天再卖出，且所的最大利润一样\n比如[1,2,3,4,5]五天的股票价格，第一天买入，第二天卖出再买入当天股票，当天股票明天卖出，没有明天时，不购买；一直持续到第五天，计算公式为nums[2]-nums[1] + nums[3]-nums[2] + nums[4]-nums[3] = 4，即与第一天买入，等到第五天再卖出时nums[4]-nums[1]一致\n\n实现代码如下：\nclass Solution {    public int maxProfit(int[] prices) {        int len = prices.length;        int profitCount = 0;\t// 统计多次买卖所得利润        for (int i = 1; i &lt; len; ++ i) {            if (prices[i] &gt; prices[i-1]) {                // 说明当前股票价格大于昨天股票价格 可以昨天买入 再今天卖出                profitCount += prices[i] - prices[i-1];            }        }        return profitCount;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:44.5 MB,击败了71.75% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","贪心","数组","动态规划"]},{"title":"LC131.分割回文串","url":"/2024/03/07/LC131-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"131.分割回文串给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。\n回文串 是正着读和反着读都一样的字符串。\n示例 1：\n输入： s = “aab”输出：[[“a”,”a”,”b”],[“aa”,”b”]]\n示例 2：\n输入： s = “a”输出：[[“a”]]\n提示：\n\n\ns 仅由小写英文字母组成\n\n解法一(回溯)思路分析：\n\n首先该问题为切割问题，因此考虑使用回溯算法进行求解\n即确定回溯函数三要素：\n确定函数的返回值和参数；题目不需要函数返回某值，即回溯函数返回值类型为void，其次参数中，传递startIndex参数，确定下一层递归的起始递归位置，传递原始字符串s用于切割\n确定函数的结束条件，即递归到叶子节点时，将符合题意的子串保存到答案集中\n确定递归函数内部for循环过程，即确定切割字符串的位置，并切割，对得到的字串进行判断，若子串为回文串，则可继续递归，反之，则不用继续递归；然后回溯\n\n\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;String&gt;&gt; ans = new ArrayList&lt;&gt;();\t// 存储符合条件的子串列表    List&lt;String&gt; path = new ArrayList&lt;&gt;();\t// 存储切割后的子串    public List&lt;List&lt;String&gt;&gt; partition(String s) {        backtracking(s, 0);        return ans;    }    private void backtracking(String s, int startIndex) {        if (startIndex == s.length()) {            ans.add(new ArrayList&lt;&gt;(path));            return ;        }        for (int i = startIndex+1; i &lt;= s.length(); ++ i) {            if (isPalindromic(s, startIndex, i)) {\t// 若分割得到的子串为字符串                path.add(s.substring(startIndex, i));\t// 将符合题意的子串记录                backtracking(s, i);\t\t// 继续分割字符串 得到新的子串                path.remove(path.size()-1);\t// 回溯            }        }    }    private boolean isPalindrome(String s, int startIndex, int endIndex) {\t// 判断某字符串是否为回文串        while (startIndex &lt; endIndex) {            if (s.charAt(startIndex) != s.charAt(endIndex-1))                return false;            ++ startIndex;            -- endIndex;        }        return true;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:8 ms,击败了84.51% 的Java用户    内存消耗:55.9 MB,击败了20.21% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","回溯","动态规划","字符串"]},{"title":"LC134.加油站","url":"/2024/03/20/LC134-%E5%8A%A0%E6%B2%B9%E7%AB%99/","content":"134.加油站在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。\n示例 1:\n\n输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]输出: 3解释:从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。因此，3 可为起始索引。\n\n示例 2:\n\n输入: gas = [2,3,4], cost = [3,4,3]输出: -1解释:你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。因此，无论怎样，你都不可能绕环路行驶一周。\n\n提示:\n\n\n\n\n\n\n解法一(贪心)思路分析：\n\n首先可以发现，当总油量减去总消耗量大于等于0，则说明一定可以跑完一圈。\n即各个站点的剩余量为gas[i]-cost[i]，假设从0开始累加每个站点的剩余量，记为currentSum，当添加某个站点j的剩余量后currentSum小于0时，说明从[0,j]的区间，任意一个索引都不能作为跑完一圈的起始位置，所以更新起始位置为j+1，重置currentSum = 0\n若在[0,j]区间中，存在某个索引i开始累加每个站点的剩余量到索引为j时，currentSum大于0，但是此时[0,i]的区间，累加后currentSum肯定小于0，此时跑完一圈的起始索引已经更新为i+1了，而不是从[0,j]的区间累加剩余量得到currentSum\n所以，若某区间[i,j]连续累加剩余量和小于0后，则从j+1的索引处重新开始\n即局部最优：当累加到站点j的currentSum小于-，则起始位置至少为j+1\n全局最优即为：可找到跑一圈的起始位置\n\n实现代码如下：\nclass Solution {    public int canCompleteCircuit(int[] gas, int[] cost) {        int currentSum = 0;\t// 记录当前区间的和        int totalSum = 0;\t// 记录总耗费的油和获得的油的差        int start = 0;\t// 记录 一圈起始索引        for (int i = 0; i &lt; gas.length; ++ i) {            currentSum += gas[i] - cost[i];            totalSum += gas[i] - cost[i];\t// 统计总获得的油与耗费的油的差            if (currentSum &lt; 0) {\t// 出现这段区间和小于0 则从下一个索引继续开始求和                start = i+1;\t// 更新 一圈的起始索引                currentSum = 0;\t// 重置为0 从索引i+1开始继续求和            }        }        if (totalSum &lt; 0)\t// 如果总和小于0 则不可能从哪个点开始成功走一圈            return -1;\t// 直接返回-1即可        return start;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了90.04% 的Java用户    内存消耗:56.2 MB,击败了65.21% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","贪心","数组"]},{"title":"LC135.分发糖果","url":"/2024/03/21/LC135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/","content":"135.分发糖果n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。\n你需要按照以下要求，给这些孩子分发糖果：\n\n每个孩子至少分配到 1 个糖果。\n相邻两个孩子评分更高的孩子会获得更多的糖果。\n\n请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。\n示例 1：\n\n输入： ratings = [1,0,2]输出： 5解释： 你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。\n\n示例 2：\n\n输入： ratings = [1,2,2]输出： 4解释： 你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。\n\n提示：\n\n\n\n\n\n解法一(贪心)思路分析：\n\n首先对于每个孩子，既需要考虑其左边孩子评分；又要考虑右边孩子评分；如果两边同时考虑，则容易考虑不周全，而且麻烦\n可以将比较情况分为两次，即第一次每个孩子只和左边的孩子进行比较，第二次则每个孩子只和右边的孩子比较；这样问题更容易解决\n即贪心的策略为：第一次每个孩子与左边的孩子比较，只要评分高，则该孩子多得一个糖果，由此推出全局最优为，评分高得孩子比评分低得左孩子得到更多的糖果\n同理；第二次每个孩子与右孩子比较时，执行同样的贪心策略\n需要注意的是：在第二次比较时，需要选择出满足第一次比较时分配的糖果数量，如此才能由两次贪心比较中，得到最优的全局分发糖果策略\n需要注意，每个孩子都应该至少有一个孩子，即比较前，先给每个孩子分配一个糖果\n\n实现代码如下：\nclass Solution {    public int candy(int[] ratings) {        int len = ratings.length;        int[] candy = new int[len];        Arrays.fill(candy, 1);    // 保证每个孩子至少分配到1个糖果        // 右孩子与左孩子比较 从左到右        for (int i = 1; i &lt; len; ++ i) {            if (ratings[i] &gt; ratings[i-1]) {                candy[i] = candy[i-1] + 1;            }        }        // 左孩子比较右孩子 从右到左        for (int i = len-2; i &gt;= 0; --i) {            if (ratings[i] &gt; ratings[i+1]) {                candy[i] = Math.max(candy[i], candy[i+1] + 1);            }        }        // 计算出分发的糖果后 计算总的糖果数量        int sum = 0;        for (int i : candy) {            sum += i;        }        return sum;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了97.66% 的Java用户    内存消耗:44.4 MB,击败了53.44% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","贪心","数组"]},{"title":"LC144.二叉树的前序遍历","url":"/2023/12/27/LC144.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"二叉树的前序遍历给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n示例 1：\n\n输入： root = [1,null,2,3]输出：[1,2,3]\n示例 2：\n输入： root = []输出：[]\n示例 3：\n输入： root = [1]输出：[1]\n示例 4：\n\n输入： root = [1,2]输出：[1,2]\n示例 5：\n\n输入： root = [1,null,2]输出：[1,2]\n提示：\n\n树中节点数目在范围 [0, 100] 内\n\n\n进阶： 递归算法很简单，你可以通过迭代算法完成吗？\n解法一(递归)思路分析：\n\n首先确定使用递归的方式实现前序遍历，然后需要思考如何实现递归，一般思考三点：\n\n即先确定函数的参数和返回值，因为需要获取二叉树节点值，并得到一个列表，所以参数中需要有二叉树的节点和一个用来存储节点值的列表，此外不需要其他参数，然后也不需要返回值，将节点值保存到列表中即可\n\n确定递归的终止条件，因为使用的是前序遍历，深度优先搜索，所以需要先往深处遍历二叉树，即递归终止条件为：节点为空，则说明深处遍历结束，继续换另外一条分支遍历。\n\n最后确定递归的过程，题目要求前序遍历二叉树，因此先遍历父节点，然后再遍历左节点，最后遍历右节点，所以递归中；先保存当前节点值，然后调用递归函数先传递左节点再传递右节点\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        preorderTraversal(root, ans);        return ans;    }    private void preorderTraversal(TreeNode node, List&lt;Integer&gt; ans) {        if (node == null)            return ;    // 递归终止条件        // 递归过程        ans.add(node.val);    // 先遍历父节点        preorderTraversal(node.left, ans);    // 再遍历左子节点        preorderTraversal(node.right, ans);    // 最后遍历右子节点    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.4 MB,击败了5.37% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历一遍二叉树\n\n空间复杂度：，考虑递归函数的调用\n\n\n解法二(迭代 栈)思路分析：\n\n根据栈和递归的关系，对于该题可以使用栈来完成二叉树的前序遍历，即应首先思考栈中应该保存什么，因为我们遍历的二叉树，所以栈中应该存储二叉树的节点\n\n对于迭代，先思考迭代的过程，前序遍历的顺序是 中左右，因此迭代中，首先要遍历到中节点，然后再遍历左右\n\n所以，在迭代前，应先将根节点保存到栈中，然后才能在迭代中先获取中间节点，然后再继续遍历左右节点，根据栈先进后出的规律，所以先将右节点保存到栈中，再将左节点保存到栈中，如此，在下一轮迭代前，先出来遍历的则是左节点\n\n同时对于迭代的退出条件，既然用栈来存放二叉树的节点，则当栈为空时，说明已经遍历完二叉树，所以栈为空时，退出循环\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)    // 边界条件            return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();    // 用于存储二叉树的节点        stack.push(root);        while (!stack.isEmpty()) {            // 前序遍历先遍历 中            TreeNode node = stack.pop();            ans.add(node.val);            // 根据栈后进先出 先保存右节点            if (node.right != null)                stack.push(node.right);            // 再保存左节点            if (node.left != null)                stack.push(node.left);        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.1 MB,击败了10.31% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历整个二叉树\n\n空间复杂度：，使用栈来辅助遍历二叉树\n\n\n解法三(统一迭代法)思路分析：\n\n对于将要访问的节点和将要处理的节点均放入栈中\n\n但是使用空指针来对将要处理的节点进行标记\n\n本质上，即使将栈中元素顺序以前序遍历顺序输出\n\n\n实现代码如下：\nclass Solution {    // 统一迭代法 后序    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)\t// 边界条件            return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();\t// 用于存储二叉树的节点        stack.push(root);        while (!stack.isEmpty()) {            TreeNode node = stack.pop();            if (node != null) {                // 前序遍历 先保存右节点                if (node.right != null)                    stack.push(node.right);                // 再保存左节点                if (node.left != null)                    stack.push(node.left);                // 最后 中节点入栈                stack.push(node);                stack.push(null);\t// 空指针进行标记            } else {                node = stack.pop();                ans.add(node.val);            }        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.4 MB,击败了8.57% 的Java用户\n\n复杂度分析：\n时间复杂度：\n空间复杂度：\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","栈"]},{"title":"LC145.二叉树的后序遍历","url":"/2023/12/27/LC145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"二叉树的后序遍历给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。\n示例 1：\n\n输入： root = [1,null,2,3]输出： [3,2,1]\n示例 2：\n输入： root = []输出： []\n示例 3：\n输入： root = [1]输出： [1]\n提示：\n\n树中节点的数目在范围 [0, 100] 内\n\n\n进阶： 递归算法很简单，你可以通过迭代算法完成吗？\n解法一(递归)思路分析：\n\n根据二叉树的定义，使用递归来进行求解，对于如何实现递归需要思考以下三点\n\n递归函数的参数和返回值；对于题目要求获取节点值并保存到一个列表中，所以递归函数的参数有两个，同时也可以发现不需要有返回值\n\n递归的终止条件；因为采用深度优先搜索，所以会一直往下遍历，直到二叉树节点为空，则停止，所以终止条件为；节点为空\n\n单层递归的过程；由于采用后序遍历，所以需要先继续递归遍历左子节点，再递归遍历右子节点，最后读取当前节点的值\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        postorder(root, ans);        return ans;    }    private void postorder(TreeNode node, List&lt;Integer&gt; ans) {        if (node == null)            return;        postorder(node.left, ans);        postorder(node.right, ans);        ans.add(node.val);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.5 MB,击败了5.02% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(迭代)思路分析：\n\n根据二叉树前序遍历为 中左右，那么可以将前序遍历代码遍历顺序改为 中右左，然后再将遍历结果反转 即可得到左右中后序遍历顺序\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)   // 边界条件            return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        // 按照 中右左 顺序遍历二叉树        while (!stack.isEmpty()) {            TreeNode node = stack.pop();            ans.add(node.val);            if (node.left != null) stack.push(node.left);            if (node.right != null) stack.push(node.right);        }        Collections.reverse(ans);        return ans;    }    // 另一种迭代写法    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)    // 边界条件            return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        TreeNode cur = root;        while (cur != null || !stack.isEmpty()) {            if (cur != null) {    // 如果该节点不为空 则让其一直往左                stack.push(cur);                cur = cur.left;            } else {                cur = stack.pop();    // 此时处理栈弹出的元素                ans.add(cur.val);                cur = cur.right;            }        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.7 MB,击败了5.04% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法三(统一迭代法)思路分析：\n\n对于将要访问的节点 和 将要处理的节点 均压入栈中\n\n使用空指针来标记将要处理的节点\n\n使栈中元素按照后序遍历顺序出栈\n\n\n实现代码如下：\nclass Solution {    // 统一迭代法 后序    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)            return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while (!stack.isEmpty()) {            TreeNode node = stack.pop();            if (node != null) {                // 后序遍历 先保存中间节点                stack.push(node);                stack.push(null);    // 空指针作为标记                // 再保存右节点                if (node.right != null)                    stack.push(node.right);                // 最后保存左节点                if (node.left != null)                    stack.push(node.left);            } else {                node = stack.pop();                ans.add(node.val);            }        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.6 MB,击败了5.13% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","栈"]},{"title":"LC17.电话号码的字母组合","url":"/2024/03/05/LC17-%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","content":"17.电话号码的字母组合给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。\n给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。\n\n示例 1：\n输入： digits = “23”输出：[“ad”,”ae”,”af”,”bd”,”be”,”bf”,”cd”,”ce”,”cf”]\n示例 2：\n输入： digits = “”输出：[]\n示例 3：\n输入： digits = “2”输出：[“a”,”b”,”c”]\n提示：\n\n\ndigits[i] 是范围 ['2', '9'] 的一个数字。\n\n解法一(回溯)思路分析：\n\n根据题意，该题为字母组合问题，使用回溯算法来解决\n首先是回溯三要素\n思考返回值和参数，因为题目要求获得字符组合，并不需要返回值，即返回类型为void，然后需要一个参数来表示当前递归的高度，其余参数需要时再添加\n思考递归结束条件，即当递归高度与字符串digits长度一致时，保存记录的字符组合，并结束该层递归\n思考回溯的一般过程，即根据递归高度确定所需遍历的字符串，然后进行组合，并继续选择字符，然后执行回溯操作\n\n\n\n实现代码如下：\nclass Solution {    char[][] charArr = new char[][]{            {' '},            {' '},            {'a', 'b', 'c'},            {'d', 'e', 'f'},            {'g', 'h', 'i'},            {'j', 'k', 'l'},            {'m', 'n', 'o'},            {'p', 'q', 'r', 's'},            {'t', 'u', 'v'},            {'w', 'x', 'y', 'z'}    };    List&lt;String&gt; ans = new ArrayList&lt;&gt;();    StringBuffer path = new StringBuffer();    public List&lt;String&gt; letterCombinations(String digits) {        if (digits.isEmpty())            return ans;\t// 特殊情况        backtracking(digits.length(), 0, digits);        return ans;    }    private void backtracking(int high, int currentHigh, String digits) {        if (currentHigh == high) {            // 获得一个字符组合            ans.add(path.toString());            return ;        }        // 根据当前递归高度 获取待选取的字符数组        int index = digits.charAt(currentHigh) - '0';        for (char ch : charArr[index]) {            path.append(ch);            backtracking(high, currentHigh+1, digits);            path.deleteCharAt(path.length()-1);        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:41.2 MB,击败了14.59% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n是字符串digits的长度，m是数字所代表的字母数目\n空间复杂度：，即digits的长度\n\n","categories":["leetcode"],"tags":["刷题","哈希表","回溯","字符串"]},{"title":"LC199.二叉树的右视图","url":"/2024/01/01/LC199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/","content":"199. 二叉树的右视图给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。\n示例 1:\n\n输入: [1,2,3,null,5,null,4]输出: [1,3,4]\n示例 2:\n输入: [1,null,3]输出: [1,3]\n示例 3:\n输入: []输出: []\n提示:\n\n二叉树的节点个数的范围是 [0,100]\n\n\n解法一(BFS+队列)思路分析：\n\n题目要求获取站在二叉树的左视图所看到的，二叉树的最右端结点，且按照从顶到底的顺序\n\n按照从顶到底，我们采用二叉树的层序遍历，即可获得顶层到底层 每层结点所组成的列表\n\n然后每层遍历得到的列表的末端值，即为每层的最右端结点，将其记录即可\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; rightSideView(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)            return ans;        // 考虑边界情况        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();        // 开始层序遍历        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            // 定义在for循环之外 每次遍历一层二叉树结点后 会记录该层的最后一个结点            // 即记录每层的最右端结点            TreeNode node = null;            // 只需保存该层最末端的结点            for (int i = 0; i &lt; size; ++ i) {    // 将该层结点弹出 只保留最右端结点                node = queue.poll();                if (node.left != null)                    queue.offer(node.left);                if (node.right != null)                    queue.offer(node.right);            }            ans.add(node.val);        // 将最右端结点记录        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了83.59% 的Java用户    内存消耗:40.9 MB,击败了9.35% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC216.组合总和 III","url":"/2024/03/05/LC216-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-III/","content":"216.组合总和 III找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：\n\n只使用数字1到9\n每个数字 最多使用一次\n\n返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。\n示例 1:\n输入: k = 3, n = 7\n输出: [[1,2,4]]\n解释:\n\n1 + 2 + 4 = 7没有其他符合的组合了。\n\n示例 2:\n输入: k = 3, n = 9\n输出: [[1,2,6], [1,3,5], [2,3,4]]\n解释:\n\n1 + 2 + 6 = 91 + 3 + 5 = 92 + 3 + 4 = 9没有其他符合的组合了。\n\n示例 3:\n输入: k = 4, n = 1\n输出: []\n解释: 不存在有效的组合。在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 &gt; 1，没有有效的组合。\n提示:\n\n\n\n\n解法一(回溯)思路分析：\n\n题目为组合问题，所以采用回溯算法解决问题\n即回溯三要素：\n考虑回溯算法的返回值和参数，即不需要回溯函数返回具体内容，则返回类型为void，然后对于回溯算法的参数则有k、n、以及记录当前起始遍历索引，和选择元素个数。\n然后考虑回溯算法的结束条件，即当所选元素和为n以及元素个数为k时，结束本层递归\n考虑回溯算法的一般过程，即在for循环遍历中，寻找本层可能选择的元素值，并进行下一层递归，然后执行回溯\n\n\n且可以考虑对回溯进行剪枝操作，即当遍历选取元素时，若选取的元素使count &gt; n，则该元素及之后的元素都算无效，不用再选取。\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {        backtracking(k, n, 1, 0);        return ans;    }    private void backtracking(int k, int n, int startIndex, int count) {        if (count == n &amp;&amp; path.size() == k) {            ans.add(new ArrayList&lt;&gt;(path));\t\t// 保存符合题意的组合            return ;\t// 结束本层递归        }        for (int i = startIndex; i &lt;= Math.min(n-count, 9); ++ i) {            path.add(i);\t// 尝试选择元素            backtracking(k, n, i+1, count+i);\t// 继续下一层递归            path.remove(path.size()-1);        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.1 MB,击败了40.19% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，其中  为集合的大小，本题中  固定为 9。一共有  个组合，每次判断需要的时间代价是。\n空间复杂度：。path数组的空间代价是 ，递归栈空间的代价是 ，故空间复杂度为 \n\n","categories":["leetcode"],"tags":["刷题","数组","回溯"]},{"title":"LC222.完全二叉树的节点个数","url":"/2024/01/09/LC222-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0/","content":"222. 完全二叉树的节点个数给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含  个节点。\n示例 1：\n\n输入： root = [1,2,3,4,5,6]输出： 6\n示例 2：\n输入： root = []输出： 0\n示例 3：\n输入： root = [1]输出： 1\n提示：\n\n树中节点的数目范围是\n\n题目数据保证输入的树是 完全二叉树\n\n进阶： 遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？\n解法一(统一迭代遍历)思路分析：\n\n采用统一迭代二叉树的遍历方法，来对二叉树进行遍历，在遍历的过程中统计节点数目\n\n此处采用 前序遍历\n\n\n实现代码如下：\nclass Solution {    public int countNodes(TreeNode root) {        int ans = 0;        if (root == null)            return ans;\t\t// 边界条件        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while (!stack.isEmpty()) {            TreeNode node = stack.pop();            if (node != null) {                // 对节点进行处理 添加待遍历节点                if (node.right != null)                    stack.push(node.right);                if (node.left != null)                    stack.push(node.left);                // 添加待处理节点                stack.push(node);                stack.push(null);\t// 使用null标记待处理节点            } else {                stack.pop();\t// 弹出待处理节点                ++ ans;\t\t// 对节点进行计数            }        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:9 ms,击败了5.25% 的Java用户    内存消耗:44.5 MB,击败了83.97% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(BFS+队列)思路分析：\n\n采用层序遍历法，对二叉树进行遍历，并在遍历过程中 统计节点数\n\n实现代码如下：\nclass Solution {    // BFS    public int countNodes(TreeNode root) {        int ans = 0;        if (root == null)            return ans;\t\t// 边界条件        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            for (int i = 0; i &lt; size; ++i) {                ++ ans;                TreeNode node = queue.poll();                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            }        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:5 ms,击败了9.04% 的Java用户    内存消耗:46.5 MB,击败了5.07% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法三(二分查找+位运算)思路分析：\n\n首先题目给出该二叉树为 完全二叉树，因此可以利用完全二叉树的特性计算节点个数。\n\n首先规定根节点位于第0层，完全二叉树的最大层数为h，且根据完全二叉树的特性有；最左边的节点一定位于最底层，且从根节点到最左边的节点的路径长度即为最大层数h\n\n当时，第i层包含个节点，最底层包含节点数最少为1，最多为\n\n当底层包含1个节点时，完全二叉树的节点个数是：\n\n当底层包含个节点时，完全二叉树的节点个数时：\n\n\n\n因此对于最大层数为h的完全二叉树，节点个数在的范围内，即在该范围内通过二分查找的方式得到完全二叉树的节点个数\n\n即根据节点个数范围的上下界得到判断的节点个数k，如果第k个节点存在，则节点个数一定大于或等于k，如果第k个节点不存在，则节点个数一定小于 k，因此每次查找的范围缩小一半，直到找到节点个数。\n\n如何判断第k个节点是否存在？如果第k个节点位于第h层，则k的二进制表示包含h+1位，且最高位为1，其余各位从高到底表示从根节点到第k个节点的路径，0表示移动到左子节点，1表示移动到右子节点\n\n通过位运算得到第k个节点对应的路径，然后判断该路径对应的节点是否存在，则可判断第k个节点是否存在\n\n\n实现代码如下：\nclass Solution {    // 二分查找 + 位运算    public int countNodes(TreeNode root) {        if (root == null) return 0;\t// 边界        // 获取二叉树的层数        int h = 0;        TreeNode node = root;        while (node.left != null) {            ++ h;\t// 计算二叉树的层数            node = node.left;        }        // 根据二叉树的层数 获取节点数范围        int min = 1 &lt;&lt; h;\t// 位运算计算\t最低限度        int max = (1 &lt;&lt; (h + 1)) - 1;\t// 位运算计算 最高限度        int ans = 0;\t// 即二分查找寻找符合条件的 用ans来保存        // 二分查找区间为 左闭右闭        while (min &lt;= max) {            int mid = ((max - min) &gt;&gt; 1) + min;            if (exitTreeNode(mid, root, h)) {                // 如果存在 则继续查找                ans = mid;                min = mid + 1;            } else {                max = mid - 1;            }        }        return ans;\t\t// 在结束二分查找时 min指向的节点是最后一个存在的节点    }    private boolean exitTreeNode(int k, TreeNode root, int level) {        // 获取当前从根节点出发的方向        int bits = 1 &lt;&lt; (level-1);        TreeNode node = root;        while (node != null &amp;&amp; bits &gt; 0) {            if ((bits &amp; k) == 0) {                node = node.left;            } else {                node = node.right;            }            bits &gt;&gt;= 1;        }        return node != null;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:46.4 MB,击败了8.84% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n为完全二叉树的节点数\n\n空间复杂度：，只使用有限的额外空间\n\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","位运算","二分查找"]},{"title":"LC226.翻转二叉树","url":"/2024/01/04/LC226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"226. 翻转二叉树给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。\n示例 1：\n\n输入： root = [4,2,7,1,3,6,9]输出：[4,7,2,9,6,3,1]\n示例 2：\n\n输入： root = [2,1,3]输出：[2,3,1]\n示例 3：\n输入： root = []输出：[]\n提示：\n\n树中节点数目范围在 [0, 100] 内\n\n\n解法一(BFS+队列)思路分析：\n\n对二叉树进行层序遍历，每遍历一个节点，则将其左右节点进行反转\n\n实现代码如下：\nclass Solution {    public TreeNode invertTree(TreeNode root) {        if (root != null) {            Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();            queue.offer(root);            while (!queue.isEmpty()) {                int size = queue.size();                for (int i = 0; i &lt; size; ++ i) {                    TreeNode node = queue.poll();                    // 进行左右节点交换                    TreeNode temp = node.left;                    node.left = node.right;                    node.right = temp;                    if (node.left != null) queue.offer(node.left);                    if (node.right != null) queue.offer(node.right);                }            }        }        return root;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40 MB,击败了8.36% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(递归)思路分析：\n\n对于翻转二叉树，即交换二叉树每个节点的左右子节点，即可实现翻转，交换过程具有重复性，因此考虑使用迭代和递归来实现，因为感觉递归更简单，则使用递归\n\n首先思考递归的参数，因为实现翻转二叉树，因此参数中传递二叉树节点即可，对于返回值，因为要对二叉树进行改变，所以应该返回交换好的二叉树节点\n\n对于递归的边界条件，即当二叉树节点为null时，返回null即可\n\n对于交换过程，则先保存好该节点的左子节点，然后左子节点重新赋值为已经交换好的该节点的右子二叉树，同理，右子树重新赋值为已经交换好的该节点的左子二叉树\n\n\n实现代码如下：\nclass Solution {    public TreeNode invertTree(TreeNode root) {        if (root != null) {            root = doInvertTree(root);        }        return root;    }    private TreeNode doInvertTree(TreeNode node) {        if (node == null)            return null;        TreeNode temp = node.left;        node.left = doInvertTree(node.right);        node.right = doInvertTree(temp);        return node;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.9 MB,击败了11.22% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC235. 二叉搜索树的最近公共祖先","url":"/2024/02/24/LC235-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","content":"235. 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]\n\n示例 1:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8输出: 6解释: 节点 2 和节点 8 的最近公共祖先是 6。\n示例 2:\n输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4输出: 2解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。\n说明:\n\n所有节点的值都是唯一的。\np、q 为不同节点且均存在于给定的二叉搜索树中。\n\n解法一(普通二叉树)思路分析：\n\n参考236.二叉树的最近公共祖先优化解法一做法\n采用DFS递归遍历二叉树的方式求解，且对于二叉树节点的遍历顺序为后序遍历\n思考递归的参数和返回值，因为寻找二叉搜索树两个节点的公共祖先，所以参数包括二叉树根节点，以及两个求公共祖先节点，然后根据题目要求，返回值类型为TreeNode，当寻找到公共祖先时，直接返回\n思考递归的边界条件，若二叉树节点为null时，则返回null，若所遍历的节点为p或q时，将其返回\n确定递归的一般过程，即先遍历左子树，再遍历右子树寻找公共祖先，然后对搜索遍历的结果left与right进行判断\n\n实现代码如下：\nclass Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if (root == null || root == p || root == q)            return root;\t// 边界条件 及返回条件        TreeNode left = lowestCommonAncestor(root.left, p, q);        // 遍历左        TreeNode right = lowestCommonAncestor(root.right, p, q);    // 遍历右        // 对左右子树遍历结果进行判断        if (left != null &amp;&amp; right != null)            return root;    // 两者遍历均不为空 说明当前节点即为最近公共祖先        if (left != null)            return left;    // left不为null 而right为null 说明最近公共祖先在左子树        return right;        // 最近公共祖先不在左子树 也不是当前节点 即只能在右子树    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:6 ms,击败了74.71% 的Java用户    内存消耗:43.9 MB,击败了35.29% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n解法二(二叉搜索树)思路分析：\n\n对于二叉搜索树，存在左子树节点均小于中间节点，右子树节点均大于中间节点，因此可以利用二叉搜索树的性质\n对于节点p和q的值，若均小于根节点，即两节点最近公共祖先只可能存在左子树，反之均大于根节点，即最近公共祖先只可能存在右子树\n若两节点的节点值，不均小于或等于中间节点值，则说明此时节点为最近公共祖先\n\n实现代码如下：\nclass Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        TreeNode ans = root;        while (true) {            if (p.val &lt; ans.val &amp;&amp; q.val &lt; ans.val) {                ans = ans.left;        // 节点值均小于中间节点 最近公共祖先在左子树            } else if (p.val &gt; ans.val &amp;&amp; q.val &gt; ans.val) {                ans = ans.right;    // 节点值均小于中间节点 最近公共祖先在右子树            } else break;    // 此时当前节点即为最近公共祖先        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:6 ms,击败了74.71% 的Java用户    内存消耗:44 MB,击败了13.49% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","二叉搜索树"]},{"title":"LC236.二叉树的最近公共祖先","url":"/2024/02/06/LC236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","content":"236.二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n示例 1：\n\n输入： root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出： 3解释： 节点 5 和节点 1 的最近公共祖先是节点 3 。\n示例 2：\n\n输入： root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出： 5解释： 节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。\n示例 3：\n输入： root = [1,2], p = 1, q = 2输出： 1\n提示：\n\n树中节点数目在范围  内。\n\n所有 Node.val 互不相同 。\np != q\np 和 q 均存在于给定的二叉树中。\n\n解法一(DFS)思路分析：\n\n首先根据题目要求，最近公共祖先为，深度尽可能大的且包括所给节点的节点\n且二叉树的深度为，从根节点到该节点的最简单路径长度\n因此使用递归后序遍历，从深度最大的节点开始判断该节点是否为最近公共祖先\n即每遍历一个节点，则从该节点进行查找，判断是否能查找到题目所给节点\n\n实现代码如下：\nclass Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        return dfs(root, p.val, q.val);    }    private TreeNode dfs(TreeNode node, int p, int q) {        if (node == null)            return null;    // 空节点停止判断        TreeNode leftDfs = dfs(node.left, p, q);    // 先从左子树判断        if (leftDfs != null)    // 若左子树已找到公共祖先 则直接返回            return leftDfs;        TreeNode rightDfs = dfs(node.right, p, q);    // 再判断右子树        if (rightDfs != null)    // 若右子树已找到公共祖先 则直接返回            return rightDfs;        boolean findP = findTreeNode(node, p);    // 判断节点p是否在该子树上        boolean findQ = findTreeNode(node, q);    // 判断节点q是否在该子树上        if (findQ &amp;&amp; findP)            return node;    // 若两节点均在该树上 则返回公共祖先        return null;    }    private Boolean findTreeNode(TreeNode node, int x) {        if (node == null)            return false;        return findTreeNode(node.right, x) || findTreeNode(node.left, x) || node.val == x;    }}\n提交结果如下：\n\n解答成功:    执行耗时:7 ms,击败了65.99% 的Java用户    内存消耗:43.6 MB,击败了45.60% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，每遍历一个节点，需要重新遍历二叉树寻找目标节点\n空间复杂度：，递归遍历二叉树的同时，还需递归寻找目标节点\n\n优化解法一思路分析：\n\n对于解法一每遍历一个节点，判断其是否为公共祖先，尝试优化\n在遍历二叉树的过程中，寻找到最近公共祖先\n然后考虑对二叉树进行后序遍历，当遍历节点为null时返回null\n当遍历到p或q时，找到目标节点将其返回\n然后处理再遍历左右子树，并保留左右子树返回节点\n当左右子树都不为null时，说明p和q节点分别位于二叉树两侧\n考虑完两个节点位于异侧情况时，只需考虑两节点位于二叉树的一侧\n即当左子树遍历得到节点不为null时，左子树遍历得到的节点即为最近公共祖先\n对于右子树遍历得到节点同理。\n\n\n\n实现代码如下：\nclass Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        return dfs(root, p, q);    }    private TreeNode dfs(TreeNode node, TreeNode p, TreeNode q) {        if (node == null || node == p || node == q)            return node;        TreeNode left = dfs(node.left, p, q);        TreeNode right = dfs(node.right, p, q);        if (left != null &amp;&amp; right != null)            return node;        if (left != null)            return left;        return right;    }}\n提交结果如下：\n\n解答成功:    执行耗时:7 ms,击败了65.99% 的Java用户    内存消耗:43.8 MB,击败了22.74% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，对于二叉树只需遍历一遍\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树"]},{"title":"LC257.二叉树的所有路径","url":"/2024/01/14/LC257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/","content":"257. 二叉树的所有路径给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。\n叶子节点 是指没有子节点的节点。\n示例 1：\n\n输入： root = [1,2,3,null,5]输出：[“1-&gt;2-&gt;5”,”1-&gt;3”]\n示例 2：\n输入： root = [1]输出：[“1”]\n提示：\n\n树中节点的数目在范围 [1, 100] 内\n\n\n解法一(前序遍历递归+dfs)思路分析：\n\n因为要求从根节点到叶子节点的路径，所以遍历二叉树从根节点开始，即采用前序遍历中左右\n\n使用递归来实现前序遍历更为方便\n\n考虑递归的参数和返回值，题目需要把遍历路径保存为字符串，因此参数为存储路径的字符串和二叉树节点，且该遍历不需要返回值\n\n然后考虑递归的边界条件，当遍历的节点为空时，结束继续往下遍历，当遍历到叶子节点时，则保存该条遍历路径，并结束遍历\n\n考虑递归的过程，即在遍历到叶子节点时，保存遍历路径，若不是叶子节点，则继续往深处遍历\n\n\n实现代码如下：\nclass Solution {    List&lt;String&gt; ans = new ArrayList&lt;&gt;();    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        dfs(\"\", root);        return ans;    }    private void dfs(String result, TreeNode node) {        if (node == null)            return ;        result += node.val;    // 路径增加        if (node.left == null &amp;&amp; node.right == null) {            // 遍历到叶子节点 保存路径            ans.add(result);            return ;        }        dfs(result+\"-&gt;\", node.left);    // 向左往深处遍历        dfs(result+\"-&gt;\", node.right);    // 向右往深处遍历    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:8 ms,击败了32.93% 的Java用户    内存消耗:41.8 MB,击败了5.10% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历二叉树节点，以及遍历过程中对String字符串的拷贝操作\n\n空间复杂度：，需要存储二叉树遍历路径\n\n\n优化解法一(StringBuffer)思路分析：\n\n使用StringBuffer来代替字符串，可变字符串追加或删除元素为，能够有更好的性能\n\n注意使用StringBuffer可变字符串时，因为每次操作都会改变引用，所以操作后需要进行回溯操作\n\n保存到叶子节点的路径后，应该回溯删除该叶子节点值，往深处遍历左右子树结束时，也应该删除该节点，回归初始，便于往别的分支继续递归\n\n\n实现代码如下：\nclass Solution {    List&lt;String&gt; ans = new ArrayList&lt;&gt;();    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        dfs(new StringBuffer(), root);        return ans;    }    private void dfs(StringBuffer result, TreeNode node) {        if (node == null)            return ;        int size = result.length();    // 记录进入函数时的长度 便于递归回溯        result.append(node.val);    // 路径增加        if (node.left == null &amp;&amp; node.right == null) {            // 遍历到叶子节点 保存路径            ans.add(result.toString());            result.delete(size, result.length());    // 回溯            return ;        }        result.append(\"-&gt;\");        dfs(result, node.left);    // 向左往深处遍历        dfs(result, node.right);    // 向右往深处遍历        result.delete(size, result.length());    // 回溯    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了99.97% 的Java用户    内存消耗:41.1 MB,击败了26.21% 的Java用户\n\n复杂度分析：\n\n时间复杂度：只有当保存根节点到叶子节点的路径时，需要将结果转化为String，需要花费\n\n空间复杂度：，递归对空间的消耗，以及递归过程中需要对字符串路径的存储\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","回溯","字符串"]},{"title":"LC332.重新安排行程","url":"/2024/03/09/LC332-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B/","content":"332.重新安排行程给你一份航线列表 tickets ，其中 tickets[i] = [fromi, toi] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。\n所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。\n\n例如，行程 [\"JFK\", \"LGA\"] 与 [\"JFK\", \"LGB\"] 相比就更小，排序更靠前。\n\n假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。\n示例 1：\n\n\n输入： tickets = [[“MUC”,”LHR”],[“JFK”,”MUC”],[“SFO”,”SJC”],[“LHR”,”SFO”]]输出：[“JFK”,”MUC”,”LHR”,”SFO”,”SJC”]\n\n示例 2：\n\n\n输入： tickets = [[“JFK”,”SFO”],[“JFK”,”ATL”],[“SFO”,”ATL”],[“ATL”,”JFK”],[“ATL”,”SFO”]]输出：[“JFK”,”ATL”,”JFK”,”SFO”,”ATL”,”SFO”]解释： 另一种有效的行程是 [“JFK”,”SFO”,”ATL”,”JFK”,”ATL”,”SFO”] ，但是它字典排序更大更靠后。\n\n提示：\n\n\n\n\n\nfromi 和 toi 由大写英文字母组成\nfromi != toi\n\n解法一(回溯)思路分析：\n\n对于该问题进行分析，即我们需要从起点去寻找路径，找到一个节点后，若该节点符合则可以继续查找，若该节点不符合，则需要回溯删除该节点，换节点继续搜索。\n即解决该题，要考虑回溯，则使用回溯的思路来解决。\n考虑回溯函数的三要素：\n即回溯函数的返回值和参数；对于该题，我们需要确定选择某个节点后，可以找到符合题意(使用所有机票，并字典排序返回最小)的行程，所以当可以找到时，返回true，如此便可确定选择该节点，可以找到行程；当无法找到时，再进行回溯；对于函数的参数，可以当需要时进行添加。\n思考回溯的结束条件，假设符合题意的路径存储在List&lt;String&gt; ans中，则当ans.size() == tickets.size()+1时，说明找到路径，返回true\n考虑回溯的遍历过程，即根据上一层递归确定的某机票的终点，即该层递归所依据的终点，来查找对应的机票，并选择对应的节点加入路径中，然后继续递归并判断是否为符合题意得节点，若符合，则结束递归，若不符合，则回溯并更换节点。\n\n\n对于根据机票起点，查找对应字典序最小得终点；使用for循环遍历整个tickets机票列表，容易超时。\n所以可以再寻找行程前，对整个机票做一个映射关系，即创建一个Map&lt;String, Map&lt;String, Integer&gt;&gt; reflects；则可以通过起点字符串，快速得到其对应得所有终点reflects.get(from)；即Map&lt;String, Integer&gt;中，Integer用于记录对应终点得数目，每到达一次对应终点，则其数目减一，如此可以避免重复使用机票。\n同时因为题目要求所得行程为字典排序最小的行程，所以Map&lt;String, Integer&gt; reflect = TreeMap()，即TreeMap()使对应得终点机票按照key，即字符串字典序进行排序。\n如此，回溯函数，选取终点节点时，是从字典排序最小得终点开始选择，这样便可以保证，函数获取到的第一条行程，便是最符合题意得行程。\n\n实现代码如下：\nclass Solution {    LinkedList&lt;String&gt; ans = new LinkedList&lt;&gt;();    Map&lt;String, Map&lt;String, Integer&gt;&gt; reflects = new HashMap&lt;&gt;();    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) {        // 建立机票之间起点到多个终点的映射        for (List&lt;String&gt; ticket : tickets) {            Map&lt;String, Integer&gt; reflect;\t// 终点Map            if (reflects.containsKey(ticket.get(0))) {                reflect = reflects.get(ticket.get(0));\t// 获取已存在的起点-终点映射                reflect.put(ticket.get(1), reflect.getOrDefault(ticket.get(1), 0) + 1);            } else {                reflect = new TreeMap&lt;&gt;();\t// 升序Map                reflect.put(ticket.get(1), 1);\t// 保存对应的终点及数目            }            reflects.put(ticket.get(0), reflect);\t// 更新 起点-终点的映射        }        ans.add(\"JFK\");\t// 添加行程起点        backtracking(tickets.size());        return ans;    }    private boolean backtracking(int ticketNumber) {        if (ans.size() == ticketNumber + 1)            return true;\t// 找到符合题意的行程        String from = ans.getLast();        if (reflects.containsKey(from)) {            for (Map.Entry&lt;String, Integer&gt; ticket : reflects.get(from).entrySet()) {                int count = ticket.getValue();\t// 获取该起点对应的终点的数目                if (count &gt; 0) {\t// 说明存在机票                    ans.add(ticket.getKey());\t// 将对应终点添加到行程                    ticket.setValue(count-1);\t// 修改机票数目                    if (backtracking(ticketNumber))                        return true;\t// 找到符合题意的行程后 返回                    ans.removeLast();\t// 回溯                    ticket.setValue(count);                }            }        }        return false;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:9 ms,击败了55.67% 的Java用户    内存消耗:44.4 MB,击败了13.22% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","深度优先搜索","欧拉回路"]},{"title":"LC37.解数独","url":"/2024/03/10/LC37-%E8%A7%A3%E6%95%B0%E7%8B%AC/","content":"37.解数独编写一个程序，通过填充空格来解决数独问题。\n数独的解法需 遵循如下规则：\n\n数字 1-9 在每一行只能出现一次。\n数字 1-9 在每一列只能出现一次。\n数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）\n\n数独部分空格内已填入了数字，空白格用 '.' 表示。\n示例 1：\n\n\n输入： board = [[“5”,”3”,”.”,”.”,”7”,”.”,”.”,”.”,”.”],[“6”,”.”,”.”,”1”,”9”,”5”,”.”,”.”,”.”],[“.”,”9”,”8”,”.”,”.”,”.”,”.”,”6”,”.”],[“8”,”.”,”.”,”.”,”6”,”.”,”.”,”.”,”3”],[“4”,”.”,”.”,”8”,”.”,”3”,”.”,”.”,”1”],[“7”,”.”,”.”,”.”,”2”,”.”,”.”,”.”,”6”],[“.”,”6”,”.”,”.”,”.”,”.”,”2”,”8”,”.”],[“.”,”.”,”.”,”4”,”1”,”9”,”.”,”.”,”5”],[“.”,”.”,”.”,”.”,”8”,”.”,”.”,”7”,”9”]]输出：[[“5”,”3”,”4”,”6”,”7”,”8”,”9”,”1”,”2”],[“6”,”7”,”2”,”1”,”9”,”5”,”3”,”4”,”8”],[“1”,”9”,”8”,”3”,”4”,”2”,”5”,”6”,”7”],[“8”,”5”,”9”,”7”,”6”,”1”,”4”,”2”,”3”],[“4”,”2”,”6”,”8”,”5”,”3”,”7”,”9”,”1”],[“7”,”1”,”3”,”9”,”2”,”4”,”8”,”5”,”6”],[“9”,”6”,”1”,”5”,”3”,”7”,”2”,”8”,”4”],[“2”,”8”,”7”,”4”,”1”,”9”,”6”,”3”,”5”],[“3”,”4”,”5”,”2”,”8”,”6”,”1”,”7”,”9”]]解释： 输入的数独如上图所示，唯一有效的解决方案如下所示：\n\n\n提示：\n\n\n\nboard[i][j] 是一位数字或者 '.'\n题目数据 保证 输入数独仅有一个解\n\n解法一(回溯)思路分析：\n\n解数独问题和N皇后问题有点类似，考虑使用回溯算法进行求解\n思考回溯函数三要素：\n思考回溯函数的返回值和参数类型；因为解数独只存在一种解法，所以只需找到一种便可以结束整个函数，所以返回值类型为boolean型，当找到一种解法时，返回true结束函数，参数有：board数组，其余参数再需要时进行添加。\n思考回溯函数的结束条件，并不需要特意结束函数，当数独的空填完后，便不会再继续填空，函数自然结束\n思考回溯函数的遍历，即使用双重for循环，遍历整个字符数组，当遍历到一个可以填空的位置时,遍历数字1-9，并判断某数字是否可以填在该空，不可以则跳过，若可以，则标记该树，并继续填空，判断是否能解开数独，若能，则结束函数，若不能，则回溯，填写新的数字。\n\n\n\n实现代码如下：\nclass Solution {    boolean[][] rows;\t// 记录第i行 已放的数字    boolean[][] cols;\t// 记录第j列 已存放的数字    boolean[][] blocks;\t// 记录第几个方块 已存放的数字; 方块序号为 从左到右 从上到下  public void solveSudoku(char[][] board) {    // 初始化 rows、cols、blocks    rows = new boolean[board.length][board[0].length + 1];    cols = new boolean[board.length][board[0].length + 1];    blocks = new boolean[board.length][board[0].length + 1];    init(board);\t// 对三个记录数组进行初始化    backtracking(board);  }    private void init(char[][] board) {        // 初始化        for (int i = 0; i &lt; board.length; ++ i) {            for (int j = 0; j &lt; board[0].length; ++ j) {                if (board[i][j] != '.') {                    rows[i][board[i][j] - '0'] = true;\t// 记录第i行                    blocks[getBlock(i, j)][board[i][j] - '0'] = true;\t// 记录第几个3*3宫内                }                if (board[j][i] != '.') {                    cols[i][board[j][i] - '0'] = true;\t// 记录第i列                }            }        }    }    private boolean backtracking(char[][] board) {        for (int i = 0; i &lt; board.length; ++ i) {            for (int j = 0; j &lt; board[0].length; ++ j) {                if (board[i][j] == '.') {                    for (int k = 1; k &lt;= 9; ++ k) {                        if (isValid(i, j, k)) {                            board[i][j] = (char) (k+'0');                            rows[i][k] = true;                            cols[j][k] = true;                            blocks[getBlock(i, j)][k] = true;                            if (backtracking(board))                                return true;                            board[i][j] = '.';                            rows[i][k] = false;                            cols[j][k] = false;                            blocks[getBlock(i, j)][k] = false;                        }                    }                    return false;                }            }        }        return true;    }    private boolean isValid(int i, int j, int k) {        return !(rows[i][k] || cols[j][k] || blocks[getBlock(i, j)][k]);    }    private int getBlock(int i, int j) {\t// 根据方块坐标 获取其位于第几个3*3宫内        return 3 * (i/3) + j/3;    }}\n提交结果如下：\n\n解答成功:    执行耗时:3 ms,击败了70.53% 的Java用户    内存消耗:40.1 MB,击败了32.62% 的Java用户\n\n","categories":["leetcode"],"tags":["刷题","数组","哈希表","回溯","矩阵"]},{"title":"LC376.摆动序列","url":"/2024/03/13/LC376-%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/","content":"376.摆动序列如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。\n\n例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。\n\n相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。\n\n\n子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。\n给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。\n示例 1：\n\n输入： nums = [1,7,4,9,2,5]输出： 6解释： 整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。\n\n示例 2：\n\n输入： nums = [1,17,5,10,13,15,10,5,16,8]输出： 7解释： 这个序列包含几个长度为 7 摆动序列。其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。\n\n示例 3：\n\n输入： nums = [1,2,3,4,5,6,7,8,9]输出： 2\n\n提示：\n\n\n\n\n进阶： 你能否用 O(n) 时间复杂度完成此题?\n解法一(贪心)思路分析：\n\n求最优问题，尝试使用贪心算法\n由示例2给出数组元素值，得到一个折线图，即每个点的高度为对应元素值，由此可以得出，对于求最长摆动子序列，即统计折线图中的每个峰值即可得出；\n局部最优为：删除单调坡上的节点，保留单调坡上的两个端点，即可得到两个峰值；整体最优则是：整个序列中有最多的峰值\n所以对于求最长摆动子序列，只需统计数组的峰值数量即可。\n同时使用preDiff来记录nums[i] - nums[i-1]，使用curDiff来记录nums[i+1] - nums[i]；显然preDiff&gt;0 &amp;&amp; curDiff&lt;0或preDiff&lt;0 &amp;&amp; curDiff&gt;0时，元素nums[i]为一个峰值\n解决该题需要考虑以下三种情况：\n即上下坡里有平坡，即对数组[1,2,2,2,1]，则最长摇摆序列为3，需要删除左边多余的2或者删除右边多余的2，可以统一规定删除左边的两个2，即此时preDiff=0 &amp;&amp; curDiff&lt;0时，也需要记录一个峰值\n同时考虑数组首尾两端的情况，对于数组最右端的元素，默认其在摇摆序列中，对于最左端元素，假设其前端还有一个元素，与数组第一个元素值相等，即初始化preDiff = 0，此时则可统一处理数组的第一个元素与中间元素\n还需要考虑在单调坡上，存在平坡，即数组序列为[1,2,2,2,3,4,4]，此时需要注意该数组序列中，最长摇摆子序列长度为2\n\n\n\n实现代码如下：\nclass Solution {    public int wiggleMaxLength(int[] nums) {        if (nums.length == 1) return 1;        int preDiff = 0;\t// 记录nums[i] - nums[i-1] 初始化为0 默认第一个数组元素前有平坡        int curDiff = 0;\t// 记录nums[i+1] - nums[i]        int result = 1;\t\t// 记录最长子序列的长度\t默认最后一个元素在摆动序列中        for (int i = 0; i &lt; nums.length - 1; ++ i) {            curDiff = nums[i+1] - nums[i];            if ((preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0) || (preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0)) {                ++ result;                preDiff = curDiff;\t// 不实时更新preDiff 保证在单调性完全改变时 再更新 避免单调坡中的平坡            }        }        return result;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.1 MB,击败了59.32% 的Java用户\n\n解法二(动态规划)","categories":["leetcode"],"tags":["贪心","数组","动态规划"]},{"title":"LC39.组合总和","url":"/2024/03/05/LC39-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","content":"39.组合总和给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。\ncandidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。\n对于给定的输入，保证和为 target 的不同组合数少于 150 个。\n示例 1：\n输入： candidates = [2,3,6,7], target = 7输出：[[2,2,3],[7]]解释：2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。7 也是一个候选， 7 = 7 。仅有这两种组合。\n示例 2：\n输入: candidates = [2,3,5], target = 8输出: [[2,2,2,2],[2,3,3],[3,5]]\n示例 3：\n输入: candidates = [2], target = 1输出: []\n提示：\n\n\n\ncandidates 的所有元素 互不相同\n\n\n解法一思路分析：\n\n首先得该题为组合问题，所以使用回溯算法进行求解\n然后根据回溯算法三要素\n先考虑回溯函数的返回值和参数，因为不需要回溯函数返回数据，所以返回类型为void，然后对于递归函数的参数，传递目标和参数，下一层循环七点参数即可\n考虑回溯函数的结束条件，即当目标和参数为0时，说明找到符合题意的组合，将其记录，并结束本层递归即可\n考虑递归函数的一般过程，即使用for循环遍历数据集合，选取元素，然后继续递归，然后执行回溯即可\n\n\n对于遍历集合元素，可以进行判断，若添加当元素时，已超过目标和，则不用再递归选取新的元素，跳过该元素即可\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {        backtracking(target, candidates, 0);        return ans;    }    private void backtracking(int target, int[] candidates, int startIndex) {        if (target == 0) {            ans.add(new ArrayList&lt;&gt;(path));            return ;        }        for (int i = startIndex; i &lt; candidates.length; ++ i) {            if (candidates[i] &gt; target) continue;\t// 若不符合题意 则跳过该数            path.add(candidates[i]);\t// 选取符合题意元素            backtracking(target-candidates[i], candidates, i);            path.remove(path.size() - 1);        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了99.94% 的Java用户    内存消耗:43.7 MB,击败了31.03% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，即l表示某个解的元素个数，n表示解的个数\n空间复杂度：，l表示需要记录的解的个数\n\n","categories":["leetcode"],"tags":["刷题","数组","回溯"]},{"title":"LC40.组合总和 II","url":"/2024/03/06/LC40-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-II/","content":"40.组合总和 II给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。\ncandidates 中的每个数字在每个组合中只能使用 一次 。\n注意： 解集不能包含重复的组合。\n示例 1:\n输入: candidates = [10,1,2,7,6,1,5], target = 8,输出:[[1,1,6],[1,2,5],[1,7],[2,6]]\n示例 2:\n输入: candidates = [2,5,2,1,2], target = 5,输出:[[1,2,2],[5]]\n提示:\n\n\n\n\n\n解法一(回溯)思路分析：\n\n首先确定问题为组合问题，所以使用回溯算法进行求解\n其次确定回溯算法三要素：\n考虑回溯函数的返回值和参数，即不需要回溯函数返回某值，即回溯函数返回值类型为void；然后对于回溯函数的参数，即需要一个目标数参数来确定每次递归还需要寻找的元素值，同时传递集合参数。\n然后确定回溯函数的结束条件，即目标和参数为0时，说明已经寻找到符合题意的组合，将其记录答案集中即可，并结束该层递归\n确定回溯函数遍历集合过程，即遍历候选人集合，选定元素，并尝试继续递归选取元素，递归结束后，进行回溯\n\n\n需要注意题目要求集合元素只使用一次，且需要避免出现重复组合，所以给回溯函数添加startIndex参数，避免重复遍历某集合元素\n且因为，集合中会出现重复元素，所以即使使用startIndex来避免重复遍历某元素，然后依旧会选取到相等的元素；导致出现重复组合\n首先考虑出现重复的具体原因，即在第一次进行遍历到元素值为x的元素时，得到一些符合题意的组合，若接下来在同一层循环中，再一次遍历到元素值为x，此时继续往深处遍历得到的组合，与第一次得到的组合会出现重复，因为在获取下一层的符合题意的值时，上一层已经是重复的了。\n即要解决在同一树层的重复，即在该层中已经出现过的值，当再次出现时选择跳过即可，为了方便处理同层重复，可以对候选集合按顺序排序，如此重复元素均排列在一起，即可通过前后对比candidates[i] == candidates[i-1]来实现避免树层重复。\n同时，因为求目标和，所以可对回溯递归过程进行剪枝，即当前所选元素值 已经大于目标值 即已不满足题意，无需向下递归即可结束\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\t// 保留符合题意的元素组合    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();\t\t// 记录选取的元素组合    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {        Arrays.sort(candidates); // 对集合进行排序 便于去重        backtracking(candidates, target, 0);        return ans;    }    private void backtracking(int[] candidates, int target, int startIndex) {        if (target == 0) {    // 说明已经找到符合题意的组合            ans.add(new ArrayList&lt;&gt;(path));            return ;\t// 结束循环        }        for (int i = startIndex; i &lt; candidates.length; ++i) {            if (candidates[i] &gt; target) continue;\t// 剪枝            if (i &gt; startIndex &amp;&amp; candidates[i] == candidates[i-1])\t// i &gt; startIndex 保证是在树层去重                continue;\t// 避免出现重复的组合 在树层去重            path.add(candidates[i]);\t// 选取元素            backtracking(candidates, target-candidates[i], i+1);\t// 继续递归选取            path.remove(path.size()-1);\t// 回溯        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:3 ms,击败了67.06% 的Java用户    内存消耗:42.3 MB,击败了52.13% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，s表示符合题意的组合长度，n则表示每次递归过程中，for循环的长度\n空间复杂度：，s则表示满足题意组合的长度\n\n","categories":["leetcode"],"tags":["刷题","数组","回溯"]},{"title":"LC404.左叶子之和","url":"/2024/01/20/LC404-%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C/","content":"404. 左叶子之和给定二叉树的根节点 root ，返回所有左叶子之和。\n示例 1：\n\n输入: root = [3,9,20,null,null,15,7]输出: 24解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24\n示例 2:\n输入: root = [1]输出: 0\n提示:\n\n节点数在 [1, 1000] 范围内\n\n\n解法一(前序遍历)思路分析：\n\n采用前序遍历，对二叉树进行遍历，然后在遍历过程中，计算左叶子之和\n\n对于前序遍历采用递归的方式\n\n首先思考递归的参数和返回值类型，因为是遍历二叉树，所以递归函数返回为void，同时递归函数的参数为二叉树的节点\n\n然后考虑递归的边界条件，即节点为null时，不需要往下遍历\n\n然后思考递归的过程，即对于左子节点进行一次判断，若左子节点不为空，且为叶子节点，则进行一次求和\n\n\n\n\n实现代码如下：\nclass Solution {    private int ans = 0;    public int sumOfLeftLeaves(TreeNode root) {        pre(root);        return ans;    }    private void pre(TreeNode node) {        if (node == null)            return ;    // 考虑边界条件        if (node.left != null &amp;&amp; node.left.left == null &amp;&amp; node.left.right == null) {            // 若左子节点不为空 且左子节点为叶子节点            ans += node.left.val;    // 对左叶子求和        }        pre(node.left);        // 遍历 左        pre(node.right);    // 遍历 右    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.4 MB,击败了9.75% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，对二叉树进行遍历\n\n空间复杂度：，递归的空间消耗与递归的层数有关。\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC406.根据身高重建队列","url":"/2024/03/24/LC406-%E6%A0%B9%E6%8D%AE%E8%BA%AB%E9%AB%98%E9%87%8D%E5%BB%BA%E9%98%9F%E5%88%97/","content":"406.根据身高重建队列假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。\n请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。\n示例 1：\n\n输入： people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]解释：编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。\n\n示例 2：\n\n输入： people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]\n\n提示：\n\n\n\n\n题目数据确保队列可以被重建\n\n解法一(排序)思路分析：\n\n即先将队列按身高，从高到低进行排序，在身高相等时，k[i]则按升序排序，即先安排前面要求人数少的人\n排序结束后，再遍历整个队列，根据k[i]进行插入，如此不需要考虑第i人前的身高，因为此时前面的身高一定大于后面人的身高，只需根据k[i]将其移动到符合题意得位置即可\n\n实现代码如下：\nclass Solution {    public int[][] reconstructQueue(int[][] people) {        Arrays.sort(people, (a, b) -&gt; {            if (a[0] == b[0]) {                return a[1] - b[1];\t\t// 若身高相等 则按前面要几个更高的数目升序排            } else return b[0] - a[0];\t// 按身高降序排列        });        // System.out.println(Arrays.deepToString(people));\t// 检验排序结果        List&lt;int[]&gt; result = new ArrayList&lt;&gt;();\t// 重新按照ki进行排列        for (int[] person : people) {            result.add(person[1], person);    // 若要求前面有几个更高的人 则插入第几个位置        }        return result.toArray(new int[0][]);\t// 将符合题意的列表转化为数组    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:5 ms,击败了99.75% 的Java用户    内存消耗:44.5 MB,击败了28.06% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：，n代表队列中的人数\n\n","categories":["leetcode"],"tags":["刷题","数组","排序","树状数组","线段树"]},{"title":"LC429.N叉树的层序遍历","url":"/2024/01/01/LC429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"429. N 叉树的层序遍历给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。\n树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。\n示例 1：\n\n输入： root = [1,null,3,2,4,null,5,6]输出：[[1],[3,2,4],[5,6]]\n示例 2：\n\n输入： root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]\n提示：\n\n树的高度不会超过 1000\n树的节点总数在 之间\n\n解法一(BFS+队列)思路分析：\n\n虽然该树不是二叉树，但是依然可以使用广度优先搜索进行层序遍历\n\n实现代码如下：\nclass Solution {    public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        if (root == null)            return ans;        // 考虑边界条件        Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();        // 层序遍历        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            List&lt;Integer&gt; level = new ArrayList&lt;&gt;();    // 记录该层结点值            for (int i = 0; i &lt; size; ++ i) {                Node node = queue.poll();                level.add(node.val);    // 保存记录该层结点                List&lt;Node&gt; children = node.children;    // 记录该层孩子结点//                if (children != null) {//                    children.forEach(queue::offer);    // 将该孩子的结点进队 用于下一层遍历//                }                for (Node child : children) {    // 增强for 比 lambda表达式开销更低                    queue.offer(child);                }            }            ans.add(level);        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:3 ms,击败了88.49% 的Java用户    内存消耗:43.6 MB,击败了9.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","广度优先搜索"]},{"title":"LC435.无重叠区间","url":"/2024/03/26/LC435-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4/","content":"435.无重叠区间给定一个区间的集合 intervals ，其中  。返回 需要移除区间的最小数量，使剩余区间互不重叠 。\n示例 1:\n\n输入: intervals = [[1,2],[2,3],[3,4],[1,3]]输出: 1解释: 移除 [1,3] 后，剩下的区间没有重叠。\n\n示例 2:\n\n输入: intervals = [ [1,2], [1,2], [1,2] ]输出: 2解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。\n\n示例 3:\n\n输入: intervals = [ [1,2], [2,3] ]输出: 0解释: 你不需要移除任何区间，因为它们已经是无重叠的了。\n\n提示:\n\n\nintervals[i].length == 2\n\n\n解法一(排序+贪心)思路分析：\n\n对于重复的区间判断问题，可以先对所有区间的右端点按从小到大进行排序\n然后遍历排序后的区间集合，若第i个区间的左端点在前一个区间的右端点以内，则说明这两个区间重复\n即贪心策略为：删除出现的重复区间，从而得到全局最优；移除区间的数量最小\n\n实现代码如下：\nclass Solution {    public int eraseOverlapIntervals(int[][] intervals) {        Arrays.sort(intervals, new Comparator&lt;int[]&gt;() {            public int compare(int[] interval1, int[] interval2) {                return interval1[1] - interval2[1];            }        });\t// 对区间集合按右端点进行排序        int count = 0;\t// 记录需要移除的区间的最小数量        int end = intervals[0][1];        int len = intervals.length;        for (int i = 1; i &lt; len; ++ i) {            if (intervals[i][0] &gt;= end) {\t// 若第i个区间为不重复区间                end = intervals[i][1];\t// 更新此时不重复区间的终点位置            } else ++ count;\t// 需要移除的区间数量增加        }        return count;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:48 ms,击败了93.15% 的Java用户    内存消耗:72 MB,击败了37.67% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：，即排序对栈的空间消耗。\n\n","categories":["leetcode"],"tags":["贪心","数组","排序","动态规划"]},{"title":"LC45.跳跃游戏II","url":"/2024/03/18/LC45-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8FII/","content":"45.跳跃游戏 II给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。\n每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处:\n\n0 &lt;= j &lt;= nums[i]\ni + j &lt; n\n\n返回到达 nums[n - 1] 的最小跳跃次数。生成的测试用例可以到达 nums[n - 1]。\n示例 1:\n\n输入: nums = [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。\n\n示例 2:\n\n输入: nums = [2,3,0,1,4]输出: 2\n\n提示:\n\n\n\n题目保证可以到达 nums[n-1]\n\n解法一(贪心)思路分析：\n\n对于求最小跳跃次数问题，使用贪心算法求解\n确定贪心策略为，记录每次跳跃时，最大可移动位置；即当移动到最大可移动位置时，仍未到达终点，则此时不得不再进行跳跃。\n所以局部最优为：确定每次跳跃时，在[跳跃起点, 跳跃终点]的序列中，记录下一次跳跃的最大距离，若移动到跳跃终点时，依旧无法走到最终点，则进行一次跳跃\n所以由局部最优，推出全局最优为；使用最小跳跃次数，尽可能的往前走，直到终点\n且对于最远距离maxLen应该初始化为0，因为第一次跳跃时只能从索引为0的位置开始。\n同时需要使用变量preLen记录上次跳跃，索引最多可移动到的位置，当索引i==preLen时，不得不再进行一次跳跃，并记录此时跳跃的最远距离，以及已跳跃次数\n且preLen初始化为0，因为初始时，只能从索引为0的位置开始跳跃\n当preLen == nums.length - 1的时，说明该次跳跃已经可以到达终点，则结束循环，无需再继续跳跃\n\n实现代码如下：\nclass Solution {    public int jump(int[] nums) {        int len = nums.length;        int count = 0;\t// 统计最小跳跃次数        int preLen = 0;\t// 记录每次跳跃的极限最远范围        int maxLen = 0;\t// 记录可跳跃的最大距离        for (int i = 0; i &lt; len-1; ++ i) {            maxLen = Math.max(maxLen, nums[i] + i);            if (i == preLen) {\t// 当移动到上次跳跃最远距离 依旧未达到终点时                preLen = maxLen;\t// 更新这次跳跃最远距离                ++count;\t// 跳跃次数增加            }            if (preLen &gt;= len-1) break;        }        return count;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了99.17% 的Java用户    内存消耗:43.8 MB,击败了87.78% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","贪心","数组","动态规划"]},{"title":"LC450.删除二叉搜索树中的节点","url":"/2024/02/25/LC450-%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","content":"450.删除二叉搜索树中的节点给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。\n一般来说，删除节点可分为两个步骤：\n\n首先找到需要删除的节点；\n如果找到了，删除它。\n\n示例 1:\n\n输入： root = [5,3,6,2,4,null,7], key = 3输出：[5,4,6,2,null,null,7]解释： 给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。另一个正确答案是 [5,2,6,null,4,null,7]。\n\n示例 2:\n输入: root = [5,3,6,2,4,null,7], key = 0输出: [5,3,6,2,4,null,7]解释: 二叉树不包含值为 0 的节点\n示例 3:\n输入: root = [], key = 0输出: []\n提示:\n\n节点数的范围 .\n\n节点值唯一\nroot 是合法的二叉搜索树\n\n\n进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。\n解法一(模拟+递归)思路分析：\n\n首先考虑二叉搜索树的特征，即左子树节点小于中间节点值，右子树节点大于中间节点值\n因此对于找到需要删除的节点，即key与node.val进行比较\n如果key &lt; node.val 则待删除节点在左子树\n如果key &gt; node.val 则待删除节点在右子树\n如果key = node.val 则找到待删除节点，并执行删除逻辑\n\n\n找到待删除节点后，需要根据二叉搜索树的定义执行删除，主要分为以下三种情况\n删除节点的左子树为空且右子树不为空或左子树不为空且右子树为空；则将不为空的子树连接到二叉搜索树中\n若删除节点的左右子树均为空，则直接删除该节点即可\n若删除节点的左右子树均不为空，则根据二叉搜索树的定义有左子树 &lt; 右子树，即将左子树链接到右子树最左节点后，将右子树返回即可\n\n\n\n实现代码如下：\nclass Solution {    public TreeNode deleteNode(TreeNode root, int key) {        return dfs(root, key);    }    private TreeNode dfs(TreeNode node, int key) {        if (node == null)            return null;\t// 边界条件        if (node.val &gt; key) {            node.left = dfs(node.left, key);\t\t// 说明待删除节点在左子树 继续递归        } else if (node.val &lt; key) {            node.right = dfs(node.right, key);\t// 说明待删除节点在右子树 继续递归        } else {\t// 找到待删除节点            if (node.left == null &amp;&amp; node.right == null) {                return null;            } else if (node.left == null || node.right == null) {                return node.left == null ? node.right : node.left;\t// 返回不为null的子树            } else {                TreeNode pos = node.right;                while (pos.left != null)                    pos = pos.left;                pos.left = node.left;\t// 将左子树链接到右子树最左端末尾                return node.right;            }        }        return node;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:44.8 MB,击败了42.11% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，h指二叉搜索树的高度\n空间复杂度：\n\n优化解法一(维持树的高度)思路分析：\n\n结合题解，对于以上解法一删除节点后，对左右子树的链接作优化，从而维持二叉搜索树在一定的高度\n对于如何链接，即将右子树的最左端节点，即最小节点找出，然后将其作为新的左右子树的根节点，如此则可以避免直接将左子树链接到右子树最左端，导致二叉搜索树高度增加过大\n同时因为将右子树最左端节点作新的根节点，也需要将右子树的最左端节点给删除，防止节点重复出现\n\n实现代码如下：\nclass Solution {    public TreeNode deleteNode(TreeNode root, int key) {        return dfs(root, key);    }    private TreeNode dfs(TreeNode node, int key) {        if (node == null)            return null;\t// 边界条件        if (node.val &gt; key) {            node.left = dfs(node.left, key);\t\t// 说明待删除节点在左子树 继续递归        } else if (node.val &lt; key) {            node.right = dfs(node.right, key);\t// 说明待删除节点在右子树 继续递归        } else {\t// 找到待删除节点            if (node.left == null &amp;&amp; node.right == null) {                return null;            } else if (node.left == null || node.right == null) {                return node.left == null ? node.right : node.left;\t// 返回不为null的子树            } else {                TreeNode pos = node.right;                while (pos.left != null)\t// 寻找右子树的最左端节点                    pos = pos.left;                // 右子树的最左端节点作为新的根节点                node.val = pos.val;\t\t// 将pos节点值赋值给当前根节点 即pos作为新的根节点                node.right = dfs(node.right, pos.val);\t// 删除重复出现的pos节点值            }        }        return node;    }}\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:44.9 MB,击败了25.75% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","二叉搜索树"]},{"title":"LC452.用最少数量的箭引爆气球","url":"/2024/03/25/LC452-%E7%94%A8%E6%9C%80%E5%B0%91%E6%95%B0%E9%87%8F%E7%9A%84%E7%AE%AD%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83/","content":"452.用最少数量的箭引爆气球有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中 表示水平直径在  和  之间的气球。你不知道气球的确切 y 坐标。\n一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 ，， 且满足 ，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。\n给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。\n示例 1：\n\n输入： points = [[10,16],[2,8],[1,6],[7,12]]输出： 2解释： 气球可以用2支箭来爆破:-在x = 6处射出箭，击破气球[2,8]和[1,6]。-在x = 11处发射箭，击破气球[10,16]和[7,12]。\n\n示例 2：\n\n输入： points = [[1,2],[3,4],[5,6],[7,8]]输出： 4解释： 每个气球需要射出一支箭，总共需要4支箭。\n\n示例 3：\n\n输入： points = [[1,2],[2,3],[3,4],[4,5]]输出： 2解释：气球可以用2支箭来爆破:\n\n\n在x = 2处发射箭，击破气球[1,2]和[2,3]。\n在x = 4处射出箭，击破气球[3,4]和[4,5]。\n\n提示:\n\n\n\n\n\n解法一(贪心+排序)思路分析：\n\n由题意不难得知，气球直径范围有交集的气球，均可被同一支箭爆破\n因为可以对箭的范围按照结束区间进行排序；当某个气球的起始范围在上个气球的终止范围内，则两个气球必有交集。\n即；局部贪心则为：若该气球与上述气球没交集，则需要新的箭来爆破。\n从而得到全局最优：所用箭数量最少\n\n实现代码如下：\nclass Solution {    public int findMinArrowShots(int[][] points) {        // 对气球坐标进行排序 便于确定哪些气球可以用同样的箭 爆破        Arrays.sort(points, (a, b) -&gt; {            if (a[1] &gt; b[1]) {                return 1;            } else if (a[1] &lt; b[1]) {                return -1;            } else return 0;        });        // System.out.println(Arrays.deepToString(points));\t// 测试排序结果        int count = 1;\t// 记录需要使用的箭的数量        int end = points[0][1];\t// 记录箭生效范围的右区间        for (int[] point : points) {            if (point[0] &gt; end) {\t// 当新气球超过 箭的终止生效范围时                ++ count;\t// 需要使用新的箭来爆破气球                end = point[1];\t\t// 新箭 生效的终止位置                }        }        return count;    }}\n提交结果如下：\n\n解答成功:    执行耗时:53 ms,击败了98.27% 的Java用户    内存消耗:67.3 MB,击败了41.31% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：，主要为排序所使用的栈空间\n\n","categories":["leetcode"],"tags":["贪心","数组","排序"]},{"title":"LC455.分发饼干","url":"/2024/03/12/LC455-%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/","content":"455.分发饼干假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。\n对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] &gt;= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。\n示例 1:\n\n输入: g = [1,2,3], s = [1,1]输出: 1解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。\n\n示例 2:\n\n输入: g = [1,2], s = [1,2,3]输出: 2解释:你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。你拥有的饼干数量和尺寸都足以让所有孩子满足。所以你应该输出2.\n\n提示：\n\n\n\n\n\n解法一(贪心)思路分析：\n\n首先对于求最优解的问题，考虑使用贪心算法，即由局部最优到全局最优\n因为要尽可能满足数量越多的孩子，而每块饼干只能满足一个孩子，所以可以对孩子胃口以及饼干尺寸从大到小\n从大到小枚举饼干，尝试从大到小满足孩子，若某饼干能满足孩子，则满足孩子数增加，若不能满足，则枚举下一个孩子，再尝试是否能满足\n\n实现代码如下：\nclass Solution {    public int findContentChildren(int[] g, int[] s) {        int childCount = 0;\t// 记录可满足孩子的数目        Arrays.sort(g);\t// 对孩子胃口 按从大到小 排序        Arrays.sort(s);\t// 对饼干胃口 按从大到小 排序        int i = g.length-1;\t// 从最大的胃口的孩子开始枚举        int j = s.length-1;\t// 从最大尺寸的饼干开始枚举        while (j &gt;= 0 &amp;&amp; i &gt;= 0) {            if (s[j] &gt;= g[i]) {                // 说明此时                ++ childCount;\t// 满足孩子数目增加                -- j;\t// 换新的饼干            }            -- i;    // 换下一个孩子        }        return childCount;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:7 ms,击败了99.87% 的Java用户    内存消耗:44.1 MB,击败了44.88% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，m指孩子数量，n指饼干数量，即遍历数组时间复杂度为，对两个数组排序的时间复杂度为\n空间复杂度：\n\n","categories":["leetcode"],"tags":["贪心","数组","排序","双指针"]},{"title":"LC46.全排列","url":"/2024/03/09/LC46-%E5%85%A8%E6%8E%92%E5%88%97/","content":"46.全排列给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。\n示例 1：\n\n输入： nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n示例 2：\n\n输入： nums = [0,1]输出：[[0,1],[1,0]]\n\n示例 3：\n\n输入： nums = [1]输出：[[1]]\n\n提示：\n\n\n\nnums 中的所有整数 互不相同\n\n解法一(回溯)思路分析：\n\n全排列问题，考虑使用回溯算法来解决\n首先确定回溯函数三要素：\n即函数返回值和参数，因为不需要特意返回某值，即函数返回值类型为：void；同时，对于参数则需要传递；给定数组，其余参数可需要时添加\n对于函数递归的结束条件，因为题目要求对数组元素进行全排列，即当得到排列路径长度等于nums.length时，即排列结束，保存符合要求的排列，并结束递归\n对于函数内，循环遍历数组元素，排除已包括在路径中的元素，选择新元素加入排列，然后继续递归，递归结束后进行回溯即可\n\n\n\n实现代码如下：\nclass Solution {    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();\t// 存储排列情况    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\t// 题目返回结果    boolean[] flag = new boolean[7];\t// 标记某元素是否已在排列中    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        backtracking(nums);        return ans;    }    private void backtracking(int[] nums) {        if (path.size() == nums.length) {            ans.add(new ArrayList&lt;&gt;(path));            return ;        }        for (int i = 0; i &lt; nums.length; ++ i) {            if (flag[i]) continue;\t// 排除路径中出现重复的元素            path.add(nums[i]);            flag[i] = true;\t// 标记某元素已在排列中            backtracking(nums);\t// 继续递归            flag[i] = false;\t// 回溯            path.remove(path.size() - 1);        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了91.51% 的Java用户    内存消耗:43.4 MB,击败了53.66% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","数组","回溯"]},{"title":"LC47.全排列 II","url":"/2024/03/09/LC47-%E5%85%A8%E6%8E%92%E5%88%97-II/","content":"47.全排列 II给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。\n示例 1：\n\n输入： nums = [1,1,2]输出：[[1,1,2], [1,2,1], [2,1,1]]\n\n示例 2：\n\n输入： nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n提示：\n\n\n\n\n解法一(回溯)思路分析：\n\n对于排列问题，使用回溯算法解决\n确定回溯函数三要素：\n即确定函数返回值和参数，该题无需函数返回某值，即返回值类型为：void，其次参数考虑有：给定数组；其余参数需要时再添加\n对于递归函数的结束条件，即当path中，排列元素个数等于nums.length时，说明已得到一个全排列，将其保存到答案集中，并结束本层递归\n考虑函数的一般过程，因为nums中包含有重复元素，即需要使用树层去重的方式，避免出现重复的全排列，即使用数组哈希来记录本层已使用过的元素，出现重复元素则将其跳过即可。然后for循环遍历选取元素，对于该树层已使用过的元素，则跳过，同时对于已在排列中的元素，也跳过；然后将新的元素加入到排列中，并标记该元素本层使用过，避免下一层重复使用，同时也避免本层再次使用相同元素值的元素\n\n\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\t// 答案集    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();\t// 记录排列    boolean[] flag = new boolean[9];\t// 标记某元素是否已在排列中    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {        backtracking(nums);        return ans;    }    private void backtracking(int[] nums) {        if (path.size() == nums.length) {            ans.add(new ArrayList&lt;&gt;(path));            return ;        }        boolean[] used = new boolean[21];        for (int i = 0; i &lt; nums.length; ++ i) {            if (flag[i] || used[nums[i]+10])                continue;\t// 避免树层重复 以及重复添加某元素到排列中            used[nums[i]+10] = true;            path.add(nums[i]);            flag[i] = true;            backtracking(nums);            flag[i]\t= false;\t// 回溯            path.remove(path.size() - 1);        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了99.81% 的Java用户    内存消耗:43.6 MB,击败了78.07% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","数组","回溯"]},{"title":"LC491.非递减子序列","url":"/2024/03/08/LC491-%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97/","content":"491.非递减子序列给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。\n数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。\n示例 1：\n\n输入： nums = [4,6,7,7]输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]\n\n示例 2：\n\n输入： nums = [4,4,3,2,1]输出：[[4,4]]\n\n提示：\n\n\n\n\n解法一(回溯+哈希)思路分析：\n\n该题求数组中符合题意得子序列，考虑使用回溯算法进行求解\n思考回溯算法三要素：\n即回溯函数返回值和参数，不需要返回特定值，即返回类型为void，参数，则需要下一层递归起始索引，已经整数数组，其余参数需要时再添加\n考虑函数得结束条件，因为递增子序列至少两个元素，所以需要判断，同时需要使用哈希来去重，避免出现重复子序列；当path.size() &gt;= 2时，将符合题意得集合添加到结果集\n然后考虑函数的集合遍历过程，即需要进行树层去重，然后需要判断获得的元素是否递增，然后再选取符合题意的元素，然后继续递归，递归结束后进行回溯\n\n\n因为该题，无法对数组进行排序，来完全去重，所以需要在回溯函数的if部分，再进行一次哈希去重\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt;\tans = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    Set&lt;List&lt;Integer&gt;&gt; hash = new HashSet&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {        backtracking(0, nums);\t// 回溯函数        return ans;    }    private void backtracking(int startIndex, int[] nums) {        if (path.size() &gt;= 2) {            if (!hash.contains(path)) {                ArrayList&lt;Integer&gt; newPath = new ArrayList&lt;&gt;(path);                ans.add(newPath);                hash.add(newPath);            }        }        for (int i = startIndex; i &lt; nums.length; ++ i) {            if (path.isEmpty()) {\t// 初始时 子序列为空                path.add(nums[i]);\t// 直接添加元素            } else {                if (i != startIndex &amp;&amp; nums[i] == nums[i-1])                    continue;\t// 树层去重                int pre = path.get(path.size()-1);                if (nums[i] &lt; pre) continue;\t// 去除非递增元素                path.add(nums[i]);\t// 添加符合条件的数组元素            }            backtracking(i+1, nums);\t\t// 继续递归遍历            path.remove(path.size() - 1);\t// 回溯        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:11 ms,击败了8.94% 的Java用户    内存消耗:49.8 MB,击败了38.52% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n优化解法一思路分析：\n\n对于解法一使用全局Set来对搜索得到的子序列进行去重，进行优化\n即将全局Set的去重操作，放入回溯函数的每层递归中，即利用结合树层去重，虽然无法重新排序数组，使得邻近元素实现，树层去重\n但是可以在每层递归中，添加一个哈希表，如此，在同层递归中，可以使用哈希表来进行去重\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt;\tans = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {        backtracking(0, -101, nums);\t// 回溯函数        return ans;    }    private void backtracking(int startIndex, int last, int[] nums) {        if (path.size() &gt;= 2) {            ans.add(new ArrayList&lt;&gt;(path));        }        boolean[] hash = new boolean[201];  // 数组哈希        for (int i = startIndex; i &lt; nums.length; ++ i) {            if (hash[nums[i]+100]) continue;\t// 树层去重            if (!path.isEmpty() &amp;&amp; nums[i] &lt; last) continue; // 排除不符合题意的元素            hash[nums[i]+100] = true;            path.add(nums[i]);            backtracking(i+1, nums[i], nums);\t\t// 继续递归遍历            path.remove(path.size() - 1);\t// 回溯        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:5 ms,击败了88.67% 的Java用户    内存消耗:49.2 MB,击败了70.79% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","数组","哈希表","回溯","位运算"]},{"title":"LC501.二叉搜索树中的众数","url":"/2024/02/06/LC501-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0/","content":"501.二叉搜索树中的众数给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。\n如果树中有不止一个众数，可以按 任意顺序 返回。\n假定 BST 满足如下定义：\n\n结点左子树中所含节点的值 小于等于 当前节点的值\n结点右子树中所含节点的值 大于等于 当前节点的值\n左子树和右子树都是二叉搜索树\n\n示例 1：\n\n输入： root = [1,null,2,2]输出：[2]\n示例 2：\n输入： root = [0]输出：[0]\n提示：\n\n树中节点的数目在范围  内\n\n\n进阶： 你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）\n解法一(递归 + 中序遍历)思路分析：\n\n首先题目给出二叉搜索树的定义，因此可以使用中序遍历来遍历二叉树，从而得到一个有序的序列，然后根据该有序的序列寻找众数。\n使用递归的方式来实现二叉搜索树的中序遍历\n同时对于递归的返回值，为null，递归的参数则有二叉树的节点\n对于递归的边界条件，若二叉树的节点为null，结束递归\n对于递归的一般过程；则对该节点的值进行统计与判断\n首先需要一个全局变量val来记录上一个节点的值，初始为root.val，然后使用一个全局变量num来统计对应val值出现的次数，初始为0\n当遍历到某节点时，若该节点的值node.val == val，则++ num\n若该节点的值不等于val，则将已经统计记录的val和num进行判断，另一个全局变量maxNum用于记录出现某值的最大次数\n若num &gt; maxNum，则出现新的众数，重新记录保存val\n若num == maxNum，则将该众数继续保存到已有的记录中\n若num &lt; maxNum，则无需操作\n\n\n当判断记录结束后，更新val和num\n\n\n\n实现代码如下：\nclass Solution {    int val;\t// 用于记录中序遍历上一个节点的值    int num;\t// 用于记录值等于val的节点个数    int maxNum;\t// 用于记录num出现的最大值    List&lt;Integer&gt; ans;\t// 用于保存记录出现的众数    public int[] findMode(TreeNode root) {        val = root.val;\t// 初始化为根节点        ans = new LinkedList&lt;&gt;();        doFindMode(root);        updateAns();\t// 再进行更新ans 防止漏掉序列最后连续的数值        int[] arr = new int[ans.size()];        for (int i = 0; i &lt; ans.size(); ++ i) {            arr[i] = ans.get(i);        }        return arr;    }    private void doFindMode(TreeNode node) {        if (node == null)            return ;        doFindMode(node.left);\t\t// 遍历左子树        if (node.val == val) {            ++ num;        } else {            updateAns();\t// 对列表进行更新            val = node.val;            num = 1;        }        doFindMode(node.right);\t\t// 遍历右子树    }    private void updateAns() {        if (num &gt; maxNum) {            ans.clear();\t// 清除记录            ans.add(val);\t// 记录新的众数            maxNum = num;\t// 更新最大num        } else if (num == maxNum) {            ans.add(val);\t// 增加新的众数        }    }}\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.9 MB,击败了28.46% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","二叉搜索树"]},{"title":"LC51.N皇后","url":"/2024/03/10/LC51-N%E7%9A%87%E5%90%8E/","content":"51.N 皇后按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。\nn 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。\n给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。\n每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。\n示例 1：\n\n\n输入： n = 4输出：[[“.Q..”,”…Q”,”Q…”,”..Q.”],[“..Q.”,”Q…”,”…Q”,”.Q..”]]解释：如上图所示，4 皇后问题存在两个不同的解法。\n\n示例 2：\n\n输入： n = 1输出：[[“Q”]]\n\n提示：\n\n\n\n解法一(回溯)思路分析：\n\n该题需要对放置皇后位置进行寻找，当找到的位置错误时，需要回退到确定错误位置前，即解决该题需要使用到回溯算法\n即先确定回溯函数三要素：\n确定函数的返回值和参数，因为该题需要记录所有可行的放置方案，所以不需要依靠返回值寻找最优，即返回值类型为void，同时对于参数，则需要count记录当前放置到第几行，n则记录最多放置多少行皇后\n确定函数的结束条件，即当能够放完所有皇后count == n时，说明找到符合题意得放置方案，将其记录保存\n确定函数得遍历过程，即从每一行得起始遍历到末尾，并判断当前位置是否能放置皇后，若不能放置则跳过，若能放置，则根据放置位置对周围位置做标记，并记录放置位置，然后继续寻找下一行皇后放置位置，寻找结束后，进行回溯，便于寻找第二可行方案。\n\n\n其中，标记某位置不能放置的数组的类型，一定要是数值型，因为可能会同时有两个及多个皇后标记某位置不能放置，若不是数值型，当回溯时，会因为一个皇后放置位置回溯，导致其余皇后标记的位置失效，从而得到不正确的方案\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;String&gt;&gt; ret = new LinkedList&lt;&gt;();    List&lt;String&gt; path = new LinkedList&lt;&gt;();    int[][] flag;\t// 用于标记几个皇后导致某位置不能放置 当0个皇后时 即flag[i][j]=0    boolean[][] ans;\t// 记录放置皇后的位置    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {        flag = new int[n][n];        ans = new boolean[n][n];        backtracking(0, n);        return ret;    }    private void backtracking(int count, int n) {        if (count == n) {            // 找到符合题意的方案            path.clear();\t// 清除之前保存的方案            for (int i = 0; i &lt; n; ++i) {                StringBuilder str = new StringBuilder();                for (int j = 0; j &lt; n; ++j) {                    if (ans[i][j])                        str.append('Q');                    else str.append('.');                }                path.add(str.toString());            }            ret.add(new ArrayList&lt;&gt;(path));            return ;        }        for (int i = 0; i &lt; n; ++ i) {            if (flag[count][i] != 0)                continue;\t// 跳过不能放置皇后的位置            doFlag(count, i, 1, n);\t// 根据当前位置 对不能放置皇后的位置作标记            ans[count][i] = true;\t// 记录放置皇后的位置            backtracking(count+1, n);            ans[count][i] = false;\t// 回溯            doFlag(count, i, -1, n);        }    }    // 根据皇后位置 做标记函数    private void doFlag(int i, int j, int value, int n) {        int k, l;        // 标记行        for (k = 0; k &lt; n; ++ k)            flag[i][k] += value;        // 标记列        for (k = 0; k &lt; n; ++ k) {            if (k == i) continue;\t// 避免重复标记            flag[k][j] += value;        }        // 当前位置到右下角        k = i;\tl = j;        while (++k &lt; n &amp;&amp; ++l &lt; n)            flag[k][l] += value;        // 当前位置到右上角        k = i;\tl = j;        while (--k &gt;= 0 &amp;&amp; --l &gt;= 0)            flag[k][l] += value;        // 当前位置到左下角        k = i;\tl = j;        while (++k &lt; n &amp;&amp; --l &gt;= 0)            flag[k][l] += value;        // 当前位置到左上角        k = i;\tl = j;        while (--k &gt;= 0 &amp;&amp; ++l &lt; n)            flag[k][l] += value;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了89.69% 的Java用户    内存消耗:44.1 MB,击败了9.38% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n表示皇后个数\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","数组","回溯"]},{"title":"LC513.找树左下角的值","url":"/2024/01/20/LC513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/","content":"513. 找树左下角的值给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。\n假设二叉树中至少有一个节点。\n示例 1:\n\n输入: root = [2,1,3]输出: 1\n示例 2:\n\n输入: [1,2,3,4,null,5,6,null,null,7]输出: 7\n提示:\n\n二叉树的节点个数的范围是 \n\n\n解法一(层序遍历)思路分析：\n\n采用层序遍历的方式，一层一层遍历二叉树，在遍历的过程中，每遍历一层，则将该层最左边的节点记录\n\n当遍历结束后，记录的最后一个元素，即为 树左下角的值\n\n\n实现代码如下：\nclass Solution {    public int findBottomLeftValue(TreeNode root) {        // List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        int ans = 0;        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            for (int i = 0; i &lt; size; ++ i) {                TreeNode node = queue.poll();                if (i == 0) ans = node.val;    // 记录每层的最左边的节点                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            }        }        return ans;    // 返回列表的最后一个节点    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了62.58% 的Java用户    内存消耗:42.2 MB,击败了89.09% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(深度优先搜索)思路分析：\n\n使用curVal记录高度在curHeight的最左节点的值，height则记录当前节点的高度\n\n深度优先搜索遍历时，先搜索左子节点，再搜索右子节点，然后判断当前高度height是否大于curHeight，大于则更新curVal和curHeight\n\n因为先遍历左子树再遍历右子树，因此每次更改curVal时记录的是在curHeight高度的最左节点值，因为遍历到同高度其余节点时，不会改变curVal\n\n\n实现代码如下：\nclass Solution {    int curHeight = 0;    int curVal = 0;\t\t// 记录高度curHeight时 最左节点的值    public int findBottomLeftValue(TreeNode root) {        dfs(root, 0);        return curVal;    }    private void dfs(TreeNode node, int height) {        if (node == null)            return ;        ++ height;\t// 此时节点高度+1        dfs(node.left, height);\t\t// 先遍历左子树        dfs(node.right, height);\t// 再遍历右子树        if (height &gt; curHeight) {\t// 若当前高度大于记录的高度            curVal = node.val;\t// 更新            curHeight = height;        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:42.1 MB,击败了92.83% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC515.在每个树行中找最大值","url":"/2024/01/02/LC515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC/","content":"515. 在每个树行中找最大值给定一棵二叉树的根节点 root ，请找出该二叉树中每一层的最大值。\n示例1：\n\n输入: root = [1,3,2,5,3,null,9]输出: [1,3,9]\n示例2：\n输入: root = [1,2,3]输出: [1,3]\n提示：\n\n二叉树的节点个数的范围是 \n\n\n解法一(BFS+队列)思路分析：\n\n使用二叉树的层序遍历，对每层进行遍历\n\n在对每层进行遍历时，寻找每层的最大值，并保存\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; largestValues(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)            return ans;\t\t// 排除边界条件        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            int max = Integer.MIN_VALUE;\t// 标记该层最大值            for (int i = 0; i &lt; size; ++ i) {                TreeNode node = queue.poll();                max = Math.max(max, node.val);                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            }            ans.add(max);\t// 记录保存每层最大值        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了87.47% 的Java用户    内存消耗:44.1 MB,击败了9.26% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历二叉树\n\n空间复杂度：，辅助队列\n\n\n解法二(递归+dfs)思路分析：\n\n可以使用递归深度优先搜索去寻找每层的最大值。\n\n首先思考递归的参数和返回值，因为需要寻找每层的最大值，所以需要一个变量来标记节点所在层数，同时需要传递二叉树的节点，以及需要保存结果的列表参数；同时不需要返回值\n\n思考递归的边界条件，对于递归寻找某层二叉树结点的最大值，当结点为空时，即不需要判断是否为最大值，直接返回即可，且此时也意味着遍历到二叉树末端\n\n思考递归的过程，对于某个二叉树结点，首先需要判断其所在层 在此之前是否有递归到过，如果有，则将其结点值与此时列表中的结点值进行比较，若没有递归过，则直接将其保存到结果列表中\n\n\n实现代码如下：\nclass Solution {    // 递归+dfs    public List&lt;Integer&gt; largestValues(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        dfs(root, 0, ans);        return ans;    }    private void dfs(TreeNode node, int deeply, List&lt;Integer&gt; ans) {        if (node == null)            return ;\t// 递归边界        if (deeply &gt;= ans.size()) {\t// 该层未曾出现过            ans.add(node.val);        } else {\t// 若该层出现过 比较得出更大值            Integer num = ans.get(deeply);            if (num &lt; node.val) {                ans.set(deeply, node.val);            }        }        dfs(node.left, deeply+1, ans);        dfs(node.right, deeply+1, ans);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了96.80% 的Java用户    内存消耗:44.4 MB,击败了5.04% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC53.最大子数组和","url":"/2024/03/15/LC53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","content":"53.最大子数组和给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1：\n\n输入： nums = [-2,1,-3,4,-1,2,1,-5,4]输出： 6解释： 连续子数组 [4,-1,2,1] 的和最大，为 6 。\n\n示例 2：\n\n输入： nums = [1]输出： 1\n\n示例 3：\n\n输入： nums = [5,4,-1,7,8]输出： 23\n\n提示：\n\n\n\n\n进阶： 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。\n解法一(贪心)思路分析：\n\n首先对于求最大和问题，考虑使用贪心算法来求解\n思考局部的贪心策略；即对于连续子数组，应该从正数开始作为起始点，因为从负数开始的话，一定会使子数组元素和变小；即使用count来统计最大和，当最大和小于0时，则重新更新子数组的起始点，因为count &lt; 0 再添加新的数组元素，总和肯定比新的数组元素更小\n所以局部贪心为：对子数组求连续和，当连续后为负数时，重新计算连续和，此时变相更新子数组的起始点；而对于子数组的终止位置，则不需要特意寻找，因为可以使用一个变量result时刻记录出现的最大和的值，在连续和变化到负数时，result已经记录了最大连续和\n因此由局部最优，并时刻记录出现的更大的连续和，可以得到全局最优\n\n实现代码如下：\nclass Solution {    public int maxSubArray(int[] nums) {        int result = Integer.MIN_VALUE;        int count = 0;        for (int num : nums) {            count += num;            if (count &gt; result) // 时刻更新最大和                result = count;            if (count &lt; 0)                count = 0;\t// 当连续子数组和小于0时 重置连续和为0        }        return result;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了100.00% 的Java用户    内存消耗:55.6 MB,击败了84.42% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["贪心","数组","分治","动态规划"]},{"title":"LC530.二叉搜索树的最小绝对差","url":"/2024/02/06/LC530-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","content":"530.二叉搜索树的最小绝对差给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。\n差值是一个正数，其数值等于两值之差的绝对值。\n示例 1：\n\n输入： root = [4,2,6,1,3]输出： 1\n示例 2：\n\n输入： root = [1,0,48,null,null,12,49]输出： 1\n提示：\n\n树中节点的数目范围是 \n\n\n注意： 本题与  783 相同\n解法一(递归+前序)思路分析：\n\n根据二叉搜索树的性质，有左子树节点值小于根节点，右子树节点值大于根节点，\n对于如何求不同节点值之间的最小差值，考虑从上往下进行比较，采用前序遍历\n并使用一个变量ans来记录 树中任意两不同节点值之间的最小差值\n即每次传递将该节点值，与该节点所应该处于的值大小区间进行比较，对左边界和右边界分别求差值，并进行差值比较，从而得到最小差值，再将最小差值与ans进行比较，若小于ans则更新ans\n使用递归实现前序遍历，即先思考递归的参数和返回值，因为已用变量来记录最小插值，所以无需返回值，为void，对于递归的参数，则包括二叉树节点、以及区间的两个端点\n对于递归的边界条件，即二叉树节点为null时，结束递归\n对于递归的单层过程，即计算更新最小差值，然后继续遍历左右子树寻找最小差值\n需要注意的是：表示区间端点的参数类型应该为long，因为当求左区间与节点值的差值时，会超过int范围导致溢出\n\n实现代码如下：\nclass Solution {    private int ans = Integer.MAX_VALUE;    public int getMinimumDifference(TreeNode root) {        getMinimumDifference(root, Integer.MIN_VALUE, Integer.MAX_VALUE);        return ans;    }    private void getMinimumDifference(TreeNode node, long minVal, long maxVal) {        if (node == null)            return ;\t// 边界条件        // 计算并更新最小差值        ans = Math.min(ans, (int)Math.min(node.val-minVal, maxVal-node.val)); // 中间节点计算过程        getMinimumDifference(node.left, minVal, node.val);\t// 遍历左子树        getMinimumDifference(node.right, node.val, maxVal);\t// 遍历右子树    }}\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.3 MB,击败了29.20% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","深度优先搜索","广度优先搜索","二叉树","二叉搜索树"]},{"title":"LC538.把二叉搜索树转换为累加树","url":"/2024/02/26/LC538-%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/","content":"538.把二叉搜索树转换为累加树给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n提醒一下，二叉搜索树满足下列约束条件：\n\n节点的左子树仅包含键 小于 节点键的节点。\n节点的右子树仅包含键 大于 节点键的节点。\n左右子树也必须是二叉搜索树。\n\n注意： 本题和 1038: . - 力扣（LeetCode） 相同\n示例 1：\n\n输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n示例 2：\n输入：root = [0,null,1]输出：[1,null,1]\n示例 3：\n输入：root = [1,0,2]输出：[3,3,2]\n示例 4：\n输入：root = [3,2,4,1]输出：[7,9,4,10]\n提示：\n\n树中的节点数介于  和  之间。\n每个节点的值介于  和  之间。\n树中的所有值 互不相同 。\n给定的树为二叉搜索树。\n\n解法一(递归)思路分析：\n\n题目要求对二叉搜索树每个节点的值进行更新，更新为 原树中大于等于该节点的值之和，且给出的二叉搜索树中各个节点的值各不相同\n由二叉搜索树的特点得；越往右则节点值越大，即对于更新每个节点的值，只需将该节点的值加上该节点右部分所有节点值的和即可\n因此可以从二叉搜索树的右端开始遍历，在遍历的过程中，改变二叉搜索树节点的值，并累计右端节点值的和，即对于二叉搜索树进行 右 中 左 的遍历\n选择递归的方式来实现 右中左 的遍历方式\n首先思考递归的参数和返回值，即进行遍历只需传递二叉树节点参数接口，因为在原基础上改变二叉搜索树节点值 所以返回值为null\n然后考虑递归的边界条件，即空节点不需要进行更新转换\n然后确定递归的一般过程，即先遍历右子树，然后改变当前节点的值，然后再遍历左子树\n\n实现代码如下：\nclass Solution {    int preSum = 0;    public TreeNode convertBST(TreeNode root) {        dfs(root);        return root;    }    private void dfs(TreeNode node) {        if (node == null)            return ;\t// 边界条件        dfs(node.right);\t// 先往右遍历        node.val += preSum;\t// 更新节点的值        preSum = node.val;\t// 更新记录的右端节点和        dfs(node.left);\t\t// 最后更改左子树    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:44.2 MB,击败了36.28% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","二叉搜索树"]},{"title":"LC55.跳跃游戏","url":"/2024/03/17/LC55-%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/","content":"55.跳跃游戏给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。\n判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。\n示例 1：\n\n输入： nums = [2,3,1,1,4]输出： true解释： 可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\n\n示例 2：\n\n输入： nums = [3,2,1,0,4]输出： false解释： 无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\n\n提示：\n\n\n\n\n解法一(贪心)思路分析：\n\n根据每个元素代表在该位置可以跳跃到的最长位置\n即贪心策略为：每次得到在该位置可以跳到的最远位置，若下某个位置不在最远位置范围内，则说明无法移动到数组最后一个下标，即不满足\n即全局最优由局部最优，每次得到可跳跃的最远位置，推出全局最优\n\n实现代码如下：\nclass Solution {    public boolean canJump(int[] nums) {        int len = nums.length;        if (len == 1) return true;\t// 边界条件        int maxLen = 0;\t// 跳过的数组位置 可以到达的最大位置        for (int i = 0; i &lt; len; ++ i) {            if (maxLen &lt; i) {                // 说明此时可到达的最远距离 无法移动到当前位置 即无法继续往下走                return false;            }            maxLen = Math.max(maxLen, nums[i] + i);\t// 更新可到达的最远位置        }        return true;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了93.05% 的Java用户    内存消耗:44.5 MB,击败了56.64% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","贪心","数组","动态规划"]},{"title":"LC559.N叉树得最大深度","url":"/2024/01/07/LC559-N%E5%8F%89%E6%A0%91%E5%BE%97%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","content":"559. N 叉树的最大深度给定一个 N 叉树，找到其最大深度。\n最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。\nN 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。\n示例 1：\n\n输入： root = [1,null,3,2,4,null,5,6]输出： 3\n示例 2：\n\n输入： root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]输出： 5\n提示：\n\n树的深度不会超过 1000 。\n树的节点数目位于  之间。\n\n解法一(BFS+队列)思路分析：\n\n使用层序遍历来求解，从根节点遍历到最后一层，即可得到N叉树得最大深度\n\n实现代码如下：\nclass Solution {    public int maxDepth(Node root) {        int ans = 0;        if (root == null)            return ans;\t\t// 边界条件        Queue&lt;Node&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            ++ ans;\t// 遍历一层 深度+1            for (int i = 0; i &lt; size; ++ i) {                Node node = queue.poll();                for (Node child: node.children) {                    queue.offer(child);\t// 将下一层节点入队                }            }        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了27.65% 的Java用户    内存消耗:43 MB,击败了5.03% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(前序求深度+递归)思路分析：\n\n参考LC104.二叉树的最大深度思路\n\n实现代码如下：\nclass Solution {    int ans = 0;\t// 前序遍历求深度    public int maxDepth(Node root) {        getMaxDepth(root, 1);        return ans;    }    private void getMaxDepth(Node node, int depth) {        if (node == null)            return ;\t// 边界条件        // 中        ans = Math.max(ans, depth);        // 遍历N个孩子 以左开始        for (Node child: node.children) {            getMaxDepth(child, depth+1);        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43 MB,击败了5.77% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：，此处考虑，递归对空间的消耗\n\n\n解法三(后序求高度+递归)思路分析：\n\n因为根节点得高度就是二叉树得最大深度，因此可以使用后序遍历来求根节点得高度，采用递归得方式。\n\n具体思路参考LC104.二叉树的最大深度\n\n\n实现代码如下：\nclass Solution {    public int maxDepth(Node root) {        return getHeight(root);    }    // 后序遍历求某节点的高度    private int getHeight(Node node) {        if (node == null)            return 0;\t// 空节点 高度为0        int height = 0;        for (Node child: node.children) {            height = Math.max(getHeight(child), height);        }        return height+1;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.2 MB,击败了5.03% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：，考虑递归对空间的消耗\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索"]},{"title":"LC572.另一棵树的子树","url":"/2024/01/05/LC572-%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91/","content":"572. 另一棵树的子树给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。\n二叉树 tree 的一棵子树包括 tree 的某个节点和这个节点的所有后代节点。tree 也可以看做它自身的一棵子树。\n示例 1：\n\n输入： root = [3,4,5,1,2], subRoot = [4,1,2]输出： true\n示例 2：\n\n输入： root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]输出： false\n提示：\n\nroot 树上的节点数量范围是 [1, 2000]\nsubRoot 树上的节点数量范围是 [1, 1000]\n\n\n\n解法一(迭代+暴力匹配)思路分析：\n\n对二叉树root采用前序遍历进行遍历，寻找与二叉树subRoot的根节点相等的节点，找到某节点后，判断以该节点为根节点的子树 是否与 subRoot相等。\n\n实现代码如下：\nclass Solution {    public boolean isSubtree(TreeNode root, TreeNode subRoot) {        // 使用统一迭代进行二叉树遍历        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while (!stack.isEmpty()) {            TreeNode node = stack.pop();            if (node.val == subRoot.val) {    // 若出现与subRoot的根节点值相等 则进一步判断是否为子树                if (isSameTree(node, subRoot))                    return true;    // 为子树 则直接返回true            }            if (node.right != null) stack.push(node.right);            if (node.left != null) stack.push(node.left);        }        return false;    }    // 判断两棵树是否相等    private boolean isSameTree(TreeNode p, TreeNode q) {        if (p == null &amp;&amp; q == null) return true;        if (p == null || q == null) return false;        return p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:5 ms,击败了14.15% 的Java用户    内存消耗:43.1 MB,击败了8.66% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，subRoot是子树，且刚好遍历整个root\n\n空间复杂度：，递归调用和前序遍历root\n\n\n解法二解法三","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","字符串匹配","哈希函数"]},{"title":"LC617.合并二叉树","url":"/2024/02/05/LC617-%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"617.合并二叉树给你两棵二叉树： root1 和 root2 。\n想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。\n返回合并后的二叉树。\n注意: 合并过程必须从两个树的根节点开始。\n示例 1：\n\n输入： root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]输出：[3,4,5,5,4,null,7]\n示例 2：\n输入： root1 = [1], root2 = [1,2]输出：[2,2]\n提示：\n\n两棵树中的节点数目在范围 [0, 2000] 内\n\n\n解法一(递归)思路分析：\n\n根据题目要求，采用递归的方式构建合并后的二叉树，且对给定的二叉树采用前序遍历的方式进行构建\n首先考虑递归的参数和返回值，即参数为指向两颗二叉树的指针，同时返回值类型为TreeNode\n然后思考递归的边界条件，即当，指向两颗树的指针均为null时，返回null\n然后思考递归的一般过程，即对于当前指向两颗树的指针；所指向的节点的值之和，构建二叉树的根节点，并递归构建左子树和左子树\n\n实现代码如下：\nclass Solution {    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {        return dfs(root1, root2);    }    private TreeNode dfs(TreeNode node1, TreeNode node2) {        if (node1 == null &amp;&amp; node2 == null)            return null;\t// 两节点为空时 直接返回null        if (node1 == null)            return node2;\t// 此时第一棵树为空时 直接将第二棵树节点作为新二叉树节点        if (node2 == null)            return node1;\t// 此时第二颗树为空时 直接将第一棵树节点作为新二叉树节点        TreeNode node = new TreeNode();\t\t// 两棵树均不为null时 构建新节点        node.val = node1.val + node2.val;        node.left = dfs(node1.left, node2.left);\t// 构建左子树        node.right = dfs(node1.right, node2.right);\t// 构建右子树        return node;    }}\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.9 MB,击败了18.40% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n指新二叉树节点\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","广度优先搜索","二叉树"]},{"title":"LC637.二叉树的层平均值","url":"/2024/01/01/LC637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC/","content":"637. 二叉树的层平均值给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差  以内的答案可以被接受。\n示例 1：\n\n输入： root = [3,9,20,null,null,15,7]输出：[3.00000,14.50000,11.00000]解释： 第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。因此返回 [3, 14.5, 11] 。\n示例 2:\n\n输入： root = [3,9,20,15,7]输出：[3.00000,14.50000,11.00000]\n提示：\n\n树中节点数量在 范围内\n\n\n解法一(BFS+队列)思路分析：\n\n根据层序遍历，对二叉树进行一层一层遍历\n\n在遍历每一层时，并计算每层的平均值\n\n\n实现代码如下：\nclass Solution {    public List&lt;Double&gt; averageOfLevels(TreeNode root) {        List&lt;Double&gt; ans = new ArrayList&lt;&gt;();        if (root == null)            return ans;        // 照常判断边界条件        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            double sum = 0;        // 计算该层 结点值的和            for (int i = 0; i &lt; size; ++ i) {                TreeNode node = queue.poll();                sum += node.val;                if (node.left != null) queue.offer(node.left);                if (node.right != null) queue.offer(node.right);            }            ans.add(sum / size);        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了92.44% 的Java用户    内存消耗:44.4 MB,击败了7.71% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","深度优先遍历","广度优先遍历"]},{"title":"LC654.最大二叉树","url":"/2024/02/04/LC654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"654. 最大二叉树给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:\n\n创建一个根节点，其值为 nums 中的最大值。\n递归地在最大值 左边 的 子数组前缀上 构建左子树。\n递归地在最大值 右边 的 子数组后缀上 构建右子树。\n\n返回 nums 构建的 最大二叉树 。\n示例 1：\n\n输入： nums = [3,2,1,6,0,5]输出： [6,3,5,null,2,0,null,null,1]解释： 递归调用如下所示：\n\n[3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。\n[3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。\n空数组，无子节点。\n[2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。\n空数组，无子节点。\n只有一个元素，所以子节点是一个值为 1 的节点。\n\n\n\n\n[0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。\n只有一个元素，所以子节点是一个值为 0 的节点。\n空数组，无子节点。\n\n\n\n\n\n示例 2：\n\n输入： nums = [3,2,1]输出： [3,null,2,null,1]\n提示：\n\n\n\nnums 中的所有整数 互不相同\n\n解法一(递归+分治)思路分析：\n\n根据题目要求，即从给定数组中，选出最大值，作为当前树的根节点，然后再对数组进行分割成两部分，用于构建左子树和右子树\n所以考虑使用递归的方式来求解，首先将题目所给数组，赋值为全局变量，减少递归参数\n即，对于递归的参数，则是数组的左右端点，然后返回值类型为TreeNode\n对于递归的边界条件，即当左端点大于右端点时，说明为空树，返回null\n对于递归的过程\n则先在指定数组范围内，寻找最大值，然后构建二叉树\n根据最大值所在索引，将数组分为左右两部分\n左部分递归构建左子树，右部分递归构建右子树\n\n\n\n实现代码如下：\nclass Solution {    int[] nums;    public TreeNode constructMaximumBinaryTree(int[] nums) {        if (nums == null)            return null;\t// 边界情况        this.nums = nums;        return doBuildTree(0, nums.length-1);    }    private TreeNode doBuildTree(int left, int right) {        if (left &gt; right)            return null;\t// 说明为空树        int max = Integer.MIN_VALUE;        int index = 0;\t// 用于标记最大值索引        for (int i = left; i &lt;= right; ++i) {\t// 寻找最大值 以及所对应的索引            if (nums[i] &gt; max) {                max = nums[i];                index = i;            }        }        TreeNode node = new TreeNode(max);\t// 构建二叉树        node.left = doBuildTree(left, index-1);\t// 构建左子树        node.right = doBuildTree(index+1, right);\t// 构建右子树        return node;    }}\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了90.07% 的Java用户    内存消耗:43.9 MB,击败了10.98% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，因为每次递归都需要遍历一半的数组寻找最大值\n空间复杂度：，h表示二叉树的高度，即每次递归对空间的消耗\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","数组","分治","栈","单调栈"]},{"title":"LC669.修剪二叉搜索树","url":"/2024/02/25/LC669-%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"669.修剪二叉搜索树给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。\n所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。\n示例 1：\n\n输入： root = [1,0,2], low = 1, high = 2输出：[1,null,2]\n示例 2：\n\n输入： root = [3,0,4,null,2,null,null,1], low = 1, high = 3输出：[3,2,null,1]\n提示：\n\n树中节点数在范围  内\n\n树中每个节点的值都是 唯一 的\n题目数据保证输入是一棵有效的二叉搜索树\n\n\n解法一(递归)思路分析：\n\n首先需要确定二叉搜索树的性质，即左子树小于中间节点值，右子树大于中间节点值\n其次，对于二叉树首先考虑使用递归的方式来解决问题\n首先思考递归的参数和返回值，即参数有二叉树节点、low、high，返回值则为TreeNode\n然后思考递归的边界条件，即当节点为null时，返回null\n然后思考递归的一般过程，因为根节点也有可能不符合条件，所以需要先进行节点判断\n若node.val &lt; low，则由于左子树节点均小于node.val，所以该节点及左子树均需删除，因此只需判断右子树是否符合要求\n同理，若node.val &gt; high，则该节点及右子树均需删除，因此只需判断左子树是否符合要求\n若此时节点符合要求，则只需判断左右子树符合要求即可\n判断结束后，将修剪过的二叉树返回即可\n\n\n\n实现代码如下：\nclass Solution {    public TreeNode trimBST(TreeNode root, int low, int high) {        if (root == null)            return null;\t// 边界条件        // 先对中间节点进行判断        if (root.val &lt; low)\t// 说明该节点及左子树均需移除            return trimBST(root.right, low, high);\t// 只需继续修剪右子树        if (root.val &gt; high)\t// 说明该节点及右子树均需移除            return trimBST(root.left, low, high);\t// 只需继续修剪左子树        // 当中间节点符合要求后 只需修剪其左右子树        root.left = trimBST(root.left, low, high);        root.right = trimBST(root.right, low, high);        return root;\t// 将修剪后的二叉搜索树返回    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.1 MB,击败了54.43% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","二叉搜索树"]},{"title":"LC69.x的平方根","url":"/2023/11/26/LC69.x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/","content":"x的平方根给你一个非负整数 x ，计算并返回 x 的 算术平方根 。\n由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。\n注意： 不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。\n示例 1：\n输入：x = 4输出：2\n\n示例 2：\n输入：x = 8输出：2解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。\n\n提示：\n\n0 &lt;= x &lt;= 2^31 - 1\n\n解题解法一思路分析：\n\n根据题目提示，x的范围在0 &lt;= x &lt;= 2^31-1，如果是暴力循环遍历求解寻找平方根，会超时，所以我们考虑使用二分来搜索平方根。\n使用二分时，我们需要考虑if判断条件，同时我们可以根据算术平方根的性质有x = a*a, a &gt;= 2, a*a/2 &gt; a即二分搜索的终点可以缩减为x/2\n\n实现代码如下：\nclass Solution {    public int mySqrt(int x) {       if (x == 0 || x == 1)     // 若x为1或2则算术平方根为x本身直接返回即可            return x;        // 当 x &gt;= 2时 由算数平方根的性质可以得出 x的算术平方根a 一定 &lt; x/2        int end = x / 2;        // 使用二分来搜索        int start = 1;        while (start &lt; end) {            int mid = ((end - start) &gt;&gt; 1) + start;            if ((long)mid * mid &gt; x) {                end = mid;            } else {                start = mid + 1;            }        }        // 返回结果刚好是x的算术平方根的两边整数端点        // 根据题意返回左端点       if (start*start &gt; x) start -= 1;       return start;    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了94.10% 的Java用户    内存消耗:39.1 MB,击败了5.01% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(log x)\n空间复杂度：O(1)\n\n总结：\n在if判断中，mid*mid会导致溢出，因此需要将类型改为long，同时返回值有可能是在x算术平方根的两边端点，需要返回更小的端点\n解法二","categories":["leetcode"],"tags":["刷题","二分查找","数学"]},{"title":"LC700.二叉搜索树中的搜索","url":"/2024/02/05/LC700-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2/","content":"700.二叉搜索树中的搜索给定二叉搜索树（BST）的根节点 root 和一个整数值 val。\n你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。\n示例 1:\n\n输入： root = [4,2,7,1,3], val = 2输出：[2,1,3]\n示例 2:\n\n输入： root = [4,2,7,1,3], val = 5输出：[]\n提示：\n\n树中节点数在 [1, 5000] 范围内\n\nroot 是二叉搜索树\n\n\n解法一(DFS+模拟)思路分析：\n\n根据题目要求，使用深度优先搜索，当寻找到符合条件的节点时，将节点返回\n\n实现代码如下：\nclass Solution {    TreeNode ans;\t// 保存搜索中 所找到的子树    public TreeNode searchBST(TreeNode root, int val) {        ans = null;\t// 初始搜索结果为 null        dfs(root, val);        return ans;    }    private void dfs(TreeNode node, int val) {        if (node == null)            return ;        if (node.val == val) {            ans = node;            return ;\t// 若找到子树 则终止搜索        }        dfs(node.left, val);\t// 向左寻找        dfs(node.right, val);\t// 向右寻找    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:44.3 MB,击败了5.83% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历二叉树节点\n空间复杂度：\n\n解法二(利用二叉搜索树性质)思路分析：\n\n首先对于二叉搜索树，有以下性质：\n左子树所有节点的元素值均小于根节点元素值\n右子树所有节点的元素值均小于根节点元素值\n\n\n因此对于解法一的代码，可以进行优化，提高查询效率\n\n实现代码如下：\nclass Solution {    public TreeNode searchBST(TreeNode root, int val) {        if (root == null)            return null;\t// 如果根节点为空 或者查询到不存在        if (root.val == val)            return root;        return searchBST(root.val &lt; val? root.right : root.left, val);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:44.3 MB,击败了5.35% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","二叉搜索树"]},{"title":"LC701.二叉搜索树中的插入操作","url":"/2024/02/24/LC701-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/","content":"701.二叉搜索树中的插入操作给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。\n注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。\n示例 1：\n\n输入： root = [4,2,7,1,3], val = 5输出：[4,2,7,1,3,5]解释： 另一个满足题目要求可以通过的树是：\n示例 2：\n输入： root = [40,20,60,10,30,50,70], val = 25输出：[40,20,60,10,30,50,70,null,null,25]\n示例 3：\n输入： root = [4,2,7,1,3,null,null,null,null,null,null], val = 5输出：[4,2,7,1,3,5]\n提示：\n\n树中的节点数将在 的范围内。\n\n所有值 Node.val 是 独一无二 的。\n\n保证 val 在原始BST中不存在。\n\n解法一(模拟+递归)思路分析：\n\n利用二叉搜索树的特性，采用递归的方式，模拟二叉搜索树新增节点过程\n首先思考递归的参数，即二叉树节点与待插入值，返回结果为二叉搜索树\n再思考递归的边界条件，即当节点为空时，构造新的二叉树节点返回\n思考递归的一般过程，即当该节点值小于中间节点值时，该节点应插入左子树\n当该节点值大于中间节点时，该节点应插入右子树\n插入结束后，返回新的二叉树\n\n实现代码如下：\nclass Solution {    public TreeNode insertIntoBST(TreeNode root, int val) {        if (root == null)            return new TreeNode(val);        if (val &lt; root.val) {            root.left = insertIntoBST(root.left, val);        } else {            root.right = insertIntoBST(root.right, val);        }        return root;    }}\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:44.1 MB,击败了35.34% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n解法二(迭代+模拟)思路分析：\n\n因为二叉搜索树为空树，所以首先要判断root是否为null\n然后循环寻找待插入位置\n若当前节点值小于val，则继续判断左子树\n若当前节点值大于val，则继续判断右子树\n\n实现代码如下：\nclass Solution {    public TreeNode insertIntoBST(TreeNode root, int val) {        if (root == null)            return new TreeNode(val);\t// 直接创建新的二叉搜索树        TreeNode node = root;\t// 遍历二叉搜索树节点        while (node != null) {            if (val &lt; node.val) {                if (node.left == null) {                    node.left = new TreeNode(val);\t// 找到插入位置并插入                    break;                } else {                    node = node.left;                }            } else {                if (node.right == null) {                    node.right = new TreeNode(val);                    break;                } else {                    node = node.right;                }            }        }        return root;    }}\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:44.2 MB,击败了24.16% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","二叉树","二叉搜索树"]},{"title":"LC763.划分字母区间","url":"/2024/03/27/LC763-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4/","content":"763.划分字母区间给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。\n注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。\n返回一个表示每个字符串片段的长度的列表。\n示例 1：\n\n输入： s = “ababcbacadefegdehijhklij”输出：[9,7,8]解释：划分结果为 “ababcbaca”、”defegde”、”hijhklij” 。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 这样的划分是错误的，因为划分的片段数较少。 \n\n示例 2：\n\n输入： s = “eccbbbbdec”输出：[10]\n\n提示：\n\n\ns 仅由小写英文字母组成\n\n解法一(贪心+哈希表)思路分析：\n\n根据题意，即保证一个片段的字母都只在这个片段出现过。\n可以使用哈希表记录每个字符最后出现位置；然后从头遍历字符，并更新某字符出现的最远的位置，若此时遍历到的字符在最远位置，即说明找到一个符合题意得片段，找到分割点\n即贪心算法，每找到一个刚好满足题意得片段。便马上分割；从而得到全局最优：将字符串划分为尽可能多的片段。\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; partitionLabels(String s) {        int[] hash = new int[27];\t// 记录每个字母出现的最大索引        int length = s.length();\t// 获取字符串长度        char[] str = s.toCharArray();\t// 将字符串转化为字符数组        for (int i = 0; i &lt; length; ++ i) {            hash[str[i] - 'a'] = i;        }        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\t// 记录每个片段长度        int left = 0;\t// 记录片段的左边界        int right = 0;\t// 记录片段的右边界        for (int i = 0; i &lt; length; ++ i) {            right = Math.max(right, hash[str[i]-'a']);\t// 更新某片段的右边界            if (i == right) {\t// 找到某片段的最远右边界                result.add(right - left + 1);\t// 记录某片段的长度                left = right + 1;\t// 更新为下一个片段左边界            }        }        return result;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了98.77% 的Java用户    内存消耗:41.2 MB,击败了28.72% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","贪心","哈希表","字符串","双指针"]},{"title":"LC77.组合","url":"/2024/03/04/LC77-%E7%BB%84%E5%90%88/","content":"77.组合给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。\n你可以按 任何顺序 返回答案。\n示例 1：\n输入： n = 4, k = 2输出：[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]\n示例 2：\n输入： n = 1, k = 1输出：[[1]]\n提示：\n\n\n\n\n解法一(回溯)思路分析：\n\n题目为组合问题，使用回溯算法来进行求解\n即回溯三部曲：\n考虑回溯的返回值和参数，即参数为选择的树的个数，返回值设为null\n考虑回溯的终止条件；当选择的树的个数为k时，结束本层递归\n考虑回溯的遍历过程，即因为是组合问题，所以不能出现重复的集合，对于各元素，通过循环来实现遍历\n\n\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans;\t// 存储组合的答案    int num;\t// 将n值 设为全局    int ret;\t// 将k值 设为全局    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {        ans = new ArrayList&lt;&gt;();        num = n;        ret = k;        backtracking(1, new ArrayList&lt;&gt;());        return ans;    }    private void backtracking(int s, List&lt;Integer&gt; arr) {        if (arr.size() == ret) {            ans.add(new ArrayList&lt;&gt;(arr));            return ;        }        for (int i = s; i &lt;= num; ++ i) {            arr.add(i);            backtracking(i+1, arr);            arr.remove(arr.size()-1);        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:20 ms,击败了59.61% 的Java用户    内存消耗:92.5 MB,击败了16.14% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：，使用常量级变量\n\n解法二(解法一剪枝优化)思路分析：\n\n对于递归中，每层可以剪枝的地方即for循环\n考虑每层循环时，所需要的元素个数为k - arr.size()，即可计算出当前循环索引最多可以移动到的位置为n - (k - arr.size()) + 1\n即完成剪枝\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans;\t// 存储组合的答案    int num;\t// 将n值 设为全局    int ret;\t// 将k值 设为全局    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {        ans = new ArrayList&lt;&gt;();        num = n;        ret = k;        backtracking(1, new ArrayList&lt;&gt;());        return ans;    }    private void backtracking(int s, List&lt;Integer&gt; arr) {        if (arr.size() == ret) {            ans.add(new ArrayList&lt;&gt;(arr));            return ;        }        for (int i = s; i &lt;= num-ret+arr.size()+1; ++ i) {            arr.add(i);            backtracking(i+1, arr);            arr.remove(arr.size()-1);        }    }}\n提交结果如下：\n\n解答成功:    执行耗时:17 ms,击败了81.58% 的Java用户    内存消耗:92.4 MB,击败了30.17% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：，使用常量级变量\n\n","categories":["leetcode"],"tags":["刷题","回溯"]},{"title":"LC78.子集","url":"/2024/03/08/LC78-%E5%AD%90%E9%9B%86/","content":"78.子集\n给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n示例 1：\n\n输入： nums = [1,2,3]输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n示例 2：\n\n输入： nums = [0]输出：[[],[0]]\n\n提示：\n\n\n\nnums 中的所有元素 互不相同\n\n解法一(回溯)思路分析：\n\n首先确定该问题为子集问题，使用回溯算法进行求解\n考虑回溯三要素：\n考虑回溯的返回值和参数，题目不需要函数返回某值，即返回值为void，参数则包括集合，以及下一层递归选取元素的起始索引\n考虑回溯的结束条件，因为需要获取全部的子集，即当选取元素个数符合path.size() &gt; 0 &amp;&amp; path.size() &lt;= nums.length时，将子集保存到ans中\n考虑回溯的遍历过程，即遍历集合，选取元素，然后继续递归选取，结束递归后进行回溯\n\n\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        ans.add(new ArrayList&lt;&gt;(path));\t// 获取空集        backtracking(0, nums);        return ans;    }    private void backtracking(int startIndex, int[] nums) {        if (!path.isEmpty() &amp;&amp; path.size() &lt;= nums.length) {            ans.add(new ArrayList&lt;&gt;(path));        }        for (int i = startIndex; i &lt; nums.length; ++ i) {            path.add(nums[i]);            backtracking(i+1, nums);            path.remove(path.size()-1);        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:41.8 MB,击败了16.97% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n表示集合长度，每个集合元素有两种状态，则共有个状态，而每种状态需要时间构造子集\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","数组","回溯","位运算"]},{"title":"LC844.比较含退格的字符串","url":"/2023/11/28/LC844.%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"比较含退格的字符串给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 true 。# 代表退格字符。\n注意：如果对空文本输入退格字符，文本继续为空。\n示例 1：\n输入：s = \"ab#c\", t = \"ad#c\"输出：true解释：s 和 t 都会变成 \"ac\"。\n\n示例 2：\n输入：s = \"ab##\", t = \"c#d#\"输出：true解释：s 和 t 都会变成 \"\"。\n\n示例 3：\n输入：s = \"a#c\", t = \"b\"输出：false解释：s 会变成 \"c\"，但 t 仍然是 \"b\"。\n\n提示：\n\n1 &lt;= s.length, t.length &lt;= 200\ns 和 t 只含有小写字母以及字符 '#'\n\n进阶：\n\n你可以用 O(n) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？\n\n解题解法一(模拟)思路分析：\n\n考虑模拟字符串输入到文本编辑器的操作，对字符串进行修改，模拟退格，将退格后的字符串s和t进行比较\n由于对于字符串s和t的处理，都是相同处理，可以构造一个函数来处理s和t。\n\n实现代码如下：\nclass Solution {    public boolean backspaceCompare(String s, String t) {       return buildString(s).equals(buildString(t));    }    // 模拟字符串输入到空白的文本编辑器    private String buildString(String s) {       StringBuilder ans = new StringBuilder();       int n = s.length();       for (int i = 0; i &lt; n; ++ i) {          char ch = s.charAt(i);          if (ch != '#') {   // 如果该字符是字母则输入             ans.append(ch);          } else {   // 若字符是'#'  则回退             if (!ans.isEmpty())       // 不为空时需要回退                ans.deleteCharAt(ans.length()-1);          }       }       return ans.toString();    }}\n\n提交结果如下：\n&gt; 2023/11/28 23:36:06    解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.8 MB,击败了11.31% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n+m)，n是字符串s的长度，m是字符串t的长度。\n空间复杂度：O(n+m)，n是字符串s的长度，m是字符串t的长度，主要是函数buildString()返回字符串的消耗，相当于构建新的字符串。\n\n解法二(双指针)思路分析：\n\n一个字符是否需要被回退，取决于该字符后面是否有退格符(‘#’)，与该字符前面是否有退格符无关，因此可以考虑逆序遍历字符串，便可以在遍历的过程中确定一个字符串是否需要被删除\n\n我们可以使用一个变量skip来表示需要删除的字符数量，当我们遍历到一个字符时：\n\n如果该字符是‘#’，则需要再多删除一个字符，使skip加1\n若该字符不是退格符，则\nskip == 0 则当前字符不需要删除\nskip != 0，则当前字符需要被删除 ，并让skip减1。\n\n\n\n\n所以可以定义两个指针，分别指向两个字符串末尾，并对两个字符串逆序遍历，然后每遍历一个不需要被删除的字符串则进行比较，直到找到不相等的字符或遍历结束。\n\n\n实现代码如下：\nclass Solution {    public boolean backspaceCompare(String s, String t) {       int lenS = s.length() - 1;    // 字符串s的长度       int lenT = t.length() - 1;    // 字符串t的长度       int skipS = 0;    // 表示逆序遍历过程中 s有多少字符需要被删除       int skipT = 0;    // 表示逆序遍历过程中 t有多少字符需要被删除       while (lenS &gt;= 0 || lenT &gt;= 0) {          // 逆序遍历 找出字符串s需要比较的字符          while (lenS &gt;= 0) {             if (s.charAt(lenS) == '#') {                // 若字符为回退符                // 删除数目加一                lenS --;                skipS ++;             } else {   // 若字符为普通字符                if (skipS &gt; 0) {   // 需要删除                   lenS --;                   skipS --;                } else {   // 不需要删除则退出循环 进行比较                   break;                }             }          }          // 逆序遍历 找出字符串t需要比较的字符          while (lenT &gt;= 0) {             if (t.charAt(lenT) == '#') {                lenT --;                skipT ++;             } else {                if (skipT &gt; 0) {                   skipT --;                   lenT --;                } else {                   break;                }             }          }          // 进行字符比较          if (lenT &gt;= 0 &amp;&amp; lenS &gt;= 0) {             // 说明字符串均未遍历完 则判断此时指针指向字符是否相等             if (s.charAt(lenS) != t.charAt(lenT)) {                return false;             }          } else {             // 当lenT&lt;0 和 lenS&lt;0 同时成立时 说明两个字符串是空串即相等             if (lenT &gt;= 0 || lenS &gt;= 0) {                // 若此时 字符串s或字符串t 中有未遍历完的字符串且另外一条字符串已为空 则说明两个字符串不等                return false;             }          }          lenS --;          lenT --;       }       return true;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.7 MB,击败了17.42% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(m+n)，需要对字符串s和t进行遍历\n空间复杂度：O(1)\n\n总结：\n在对某些字符串的题目，正序遍历模拟不好做的时候，可以尝试更换思路使用逆序遍历，同时对于双指针算法在某个时间点所代表的含义，以及指向的值要有一个清楚的认识，思路要清晰，要熟悉变量每个时刻的变化。\n","categories":["leetcode"],"tags":["刷题","字符串","栈","双指针","模拟"]},{"title":"LC860.柠檬水找零","url":"/2024/03/23/LC860-%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/","content":"860.柠檬水找零在柠檬水摊上，每一杯柠檬水的售价为 5 美元。顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。\n每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。\n注意，一开始你手头没有任何零钱。\n给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。如果你能给每位顾客正确找零，返回 true ，否则返回 false 。\n示例 1：\n\n输入： bills = [5,5,5,10,20]输出： true解释：前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。由于所有客户都得到了正确的找零，所以我们输出 true。\n\n示例 2：\n\n输入： bills = [5,5,10,10,20]输出： false解释：前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。由于不是每位顾客都得到了正确的找零，所以答案是 false。\n\n提示：\n\n\nbills[i] 不是 5 就是 10 或是 20\n\n解法一(贪心)思路分析：\n\n对于该题，首先的贪心策略就是；尽可能保留多的5美元钞票，因为5美元的钞票更加通用，即对于找零15美元；优先使用一张10美元加一张5美元的找零方案\n因为10美元只在找零15美元时，有用\n如果找零15美元，使用3张5美元的，则可能再接下来找零5美元时，无法正确找零\n即局部贪心为：尽可能节省5美元的使用，从而得到全局最优，正确为每个顾客找零\n\n实现代码如下：\nclass Solution {    public boolean lemonadeChange(int[] bills) {        int a = 0;\t// 记录5美元的钞票数目        int b = 0;\t// 记录10美元的钞票数目        int c = 0;\t// 记录20美元的钞票数目        for (int bill : bills) {            if (bill == 5) {                a += 1;    // 5美元钞票不需要找零            } else if (bill == 10) {                if (a == 0) // 无法正确找零                    return false;                a -= 1;                b += 1;            } else {                if (b &gt; 0 &amp;&amp; a &gt; 0) {    // 存在10美元时 先使用10美元                    a -= 1;                    b -= 1;                } else if (a &gt;= 3) {    // 不存在10美元时 只能使用3张5美元进行找零                    a -= 3;                } else    // 其余情况 无法正确找零                    return false;                c += 1;            }        }        return true;    }}\n\n提交结果如下：解答成功:    执行耗时:1 ms,击败了100.00% 的Java用户    内存消耗:54.5 MB,击败了86.24% 的Java用户\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","贪心","数组"]},{"title":"LC90.子集 II","url":"/2024/03/08/LC90-%E5%AD%90%E9%9B%86-II/","content":"90.子集 II给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。\n解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。\n示例 1：\n\n输入： nums = [1,2,2]输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]\n\n示例 2：\n\n输入： nums = [0]输出：[[],[0]]\n\n提示：\n\n\n\n\n解法一(回溯)思路分析：\n\n子集问题，一般使用回溯算法来求解\n考虑回溯函数三要素：\n首先考虑回溯函数返回值和参数，因为不需要特意返回某值，即返回值类型为void，然后对于参数，即集合参数，以及下一层递归选取元素的起始索引\n然后确定回溯的结束条件，因为子集问题求得是所有节点的结果，即不需要特意使用return;来结束递归\n然后考虑回溯的遍历集合过程，因为集合中会出现重复元素，所以考虑对集合进行排序，然后对树层进行去重，然后再选取符合题意的元素，进行递归，递归后回溯\n\n\n通过对给定集合进行排序，从而便于在 回溯的树形结构中，树层的层面上进行去重\n\n实现代码如下：\nclass Solution {    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {        Arrays.sort(nums);\t// 对集合进行排序 便于树层去重        backtracking(0, nums);        return ans;    }    private void backtracking(int startIndex, int[] nums) {        ans.add(new ArrayList&lt;&gt;(path));\t// 保存每个节点的结果        for (int i = startIndex; i &lt; nums.length; ++ i) {            if (i != startIndex &amp;&amp; nums[i] == nums[i-1])                continue;\t// 树层去重            path.add(nums[i]);\t// 添加元素            backtracking(i+1, nums);\t// 继续递归            path.remove(path.size() - 1);\t// 回溯        }    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:1 ms,击败了97.90% 的Java用户    内存消耗:42.5 MB,击败了50.88% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，即有个状态，而每得到一个状态需要花费\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","数组","回溯","位运算"]},{"title":"LC93.复原IP地址","url":"/2024/03/07/LC93-%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/","content":"93.复原IP地址有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。\n\n例如：\"0.1.2.201\" 和 \"192.168.1.1\" 是 有效 IP 地址，但是 \"0.011.255.245\"、\"192.168.1.312\" 和 \"192.168@1.1\" 是 无效 IP 地址。\n\n给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。\n示例 1：\n输入： s = “25525511135”输出：[“255.255.11.135”,”255.255.111.35”]\n示例 2：\n输入： s = “0000”输出：[“0.0.0.0”]\n示例 3：\n输入： s = “101023”输出：[“1.0.10.23”,”1.0.102.3”,”10.1.0.23”,”10.10.2.3”,”101.0.2.3”]\n提示：\n\n\ns 仅由数字组成\n\n解法一(回溯)思路分析：\n\n首先确定该题为字符串分割问题，考虑使用回溯算法进行求解\n然后根据题目确定回溯函数三要素：\n先确定函数返回值和参数，因为不需要函数返回特定值，即返回值类型为void，其次；参数需要有被切割字符串，以及每层递归切割字符串的起始索引\n确定递归函数的结束条件，当对字符串已经进行三次分隔后，或者；切割索引已经移动到给定字符末尾；说明已经找到符合条件的字符串，即记录符合题意的 有效IP地址\n函数的单层递归过程，即使用for循环来移动切割位置，从而实现不同的切割方式，每切割得到一个字符串，即进行判断是否符合条件，符合；则继续切割，并添加符合题意的字符串，并执行回溯操作\n\n\nStringBuilder效率比StringBuffer更高；但是不是线程安全的\n\n实现代码如下：\nclass Solution {    List&lt;String&gt; ans = new ArrayList&lt;&gt;();    StringBuffer path = new StringBuffer();    int numberOfSeparations = 0;\t// 确定得到的path中包含四个整数    int length;\t\t// 记录字符串s长度    public List&lt;String&gt; restoreIpAddresses(String s) {        length = s.length();        backtracking(s, 0);        return ans;    }    private void backtracking(String s, int startIndex) {        if (numberOfSeparations &gt; 4) return ;\t// 剪枝 排除无效IP        if (startIndex == length &amp;&amp; numberOfSeparations == 4) {            // 说明已经找到有效IP地址            ans.add(path.toString());            return ;        }        for (int i = startIndex; i &lt; length; ++ i) {            if (i - startIndex &lt; 3 &amp;&amp; isEffectiveInt(s, startIndex, i+1)) {                // 找到有效数字                int size = path.length();\t// 添加有效数字前字符串长度                path.append(s, startIndex, i+1);                if (i+1 != length)\t// 分割符放置在字符串中                    path.append(\".\");                ++ numberOfSeparations;\t\t// 统计已分隔得到的整数个数                backtracking(s, i+1);\t\t// 继续递归 分隔                path.delete(size, path.length());\t// 回溯                -- numberOfSeparations;            }        }    }    // 判断切割得到的整数 是否有效    private boolean isEffectiveInt(String s, int start, int end) {        int x = 0;        if (end-start == 1)            return true;\t// 若切割得到的整数只有1位 则必定有效        for (int i = start; i &lt; end; ++ i) {            if (i == start &amp;&amp; s.charAt(i) == '0') // 切割的数字含有前导0 无效                return false;            x = x*10 + (s.charAt(i)-'0');        }        return x &gt;= 0 &amp;&amp; x &lt;= 255;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:2 ms,击败了72.72% 的Java用户    内存消耗:41 MB,击败了81.19% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，指字符串s的长度，n则指分割得到的子串个数\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","回溯","字符串"]},{"title":"LC94.二叉树的中序遍历","url":"/2023/12/27/LC94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","content":"二叉树的中序遍历给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。\n示例 1：\n\n输入： root = [1,null,2,3]输出：[1,3,2]\n示例 2：\n输入： root = []输出：[]\n示例 3：\n输入： root = [1]输出：[1]\n提示：\n\n树中节点数目在范围 [0, 100] 内\n\n\n进阶: 递归算法很简单，你可以通过迭代算法完成吗？\n解法一(递归)思路分析：\n\n根据二叉树的定义，使用递归来进行求解，对于如何实现递归需要思考以下三点\n\n递归函数的参数和返回值；对于题目要求获取节点值并保存到一个列表中，所以递归函数的参数有两个，同时也可以发现不需要有返回值\n\n递归的终止条件；因为采用深度优先搜索，所以会一直往下遍历，直到二叉树节点为空，则停止，所以终止条件为；节点为空\n\n单层递归的过程；由于采用中序遍历，所以需要先继续递归遍历左子节点，再读取当前节点的值，最后遍历右子节点\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        inorder(root, ans);        return ans;    }    private void inorder(TreeNode node, List&lt;Integer&gt; ans) {        if (node == null)            return ;        inorder(node.left, ans);        ans.add(node.val);        inorder(node.right, ans);    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.4 MB,击败了5.01% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历一遍二叉树\n\n空间复杂度：，递归调用\n\n\n解法二(迭代)思路分析：\n\n根据前序遍历迭代法，对于中序遍历顺序，左中右，首先将根节点所有左节点全部压入栈，遍历完左节点后，即开始遍历\n\n此时遍历左节点，遍历结束后，需要将左节点的父节点的左孩子设为null，避免重复遍历\n\n然后再对此时节点的右节点进行判断，若不为空，则压入栈\n\n若有当前节点的右节点压入栈中，则再下一轮迭代时，又会一直深入遍历右节点的左分支，直到左压入栈结束为止\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)    // 边界条件            return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);        while (!stack.isEmpty()) {            while (stack.peek().left != null)    // 一直往左 直到第一个应该遍历的左节点                stack.push(stack.peek().left);            TreeNode node = stack.pop();    // 弹出应该遍历的节点            if(!stack.isEmpty())    // 切点该节点 与栈中可能是父节点的联系                stack.peek().left = null;            ans.add(node.val);    // 遍历            if (node.right != null) // 若存在右节点 则开始遍历                stack.push(node.right);        }        return ans;    }}\n\n提交代码如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.1 MB,击败了11.80% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法三(统一迭代法)思路分析：\n\n将待访问节点和待处理节点放入栈中\n\n同时使用空指针来标记待处理节点\n\n即将栈中元素按照中序遍历顺序输出\n\n\n实现代码如下：\nclass Solution {    // 统一前中后序遍历的迭代法 中序    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)            return ans;        // 处理边界条件        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        stack.push(root);    // 先保存根节点        while (!stack.isEmpty()) {            TreeNode node = stack.pop();            if (node != null) {                // node = stack.pop();    // 将节点移除 避免重复操作                // 先将右节点保存  因为右节点最后遍历                if (node.right != null)                    stack.push(node.right);                // 再保存中节点                stack.push(node);                stack.push(null);    // 通过空值标记待处理节点                // 最后保存左节点                if (node.left != null)                    stack.push(node.left);            } else {                // stack.pop();    // 将空结点移除 下一个节点才是需要访问的节点                node = stack.pop();                ans.add(node.val);            }        }        return ans;    }}\n\n提交代码如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.6 MB,击败了5.09% 的Java用户\n\n复杂度分析：\n\n时间复杂度分析：\n\n空间复杂度分析：\n\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","栈"]},{"title":"LC98.验证二叉搜索树","url":"/2024/02/05/LC98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","content":"98.验证二叉搜索树给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。\n有效 二叉搜索树定义如下：\n\n节点的左子树只包含 小于 当前节点的数。\n节点的右子树只包含 大于 当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n示例 1：\n\n输入： root = [2,1,3]输出： true\n示例 2：\n\n输入： root = [5,1,4,null,null,3,6]输出： false解释： 根节点的值是 5 ，但是右子节点的值是 4 。\n提示：\n\n树中节点数目范围在 内\n\n\n解法一(模拟+dfs)思路分析：\n\n利用二叉搜索树的性质，对树的节点进行检验\n采用深度优先搜索进行遍历实现代码如下：class Solution {    public boolean isValidBST(TreeNode root) {        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);    }    private boolean isValidBST(TreeNode node, long minVal, long maxVal) {        if (node == null)            return true;        if (node.val &lt;= minVal || node.val &gt;= maxVal)            return false;\t// 该节点值 不满足二叉搜索树的范围 返回false        return isValidBST(node.left, minVal, node.val) &amp;&amp; isValidBST(node.right, node.val, maxVal);    }}\n提交结果如下：\n解答成功: 执行耗时:0 ms,击败了100.00% 的Java用户 内存消耗:42.1 MB,击败了88.95% 的Java用户\n\n\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n解法二(中序遍历+二叉搜索树性质)思路分析：\n\n根据二叉搜索树，节点左子树只包含小于当前节点的值， 节点右子树只包含大于当前节点的值，可以采用中序遍历；左中右的顺序，可以得到一个递增的有序数组\n即判断中序遍历后的数组是否有序递增，即可检验该二叉树是否为二叉搜索树\n同时，利用双指针，可以标记遍历前一个节点，然后进行比较，判断当前遍历节点值是否大于前一个节点值\n大于，则符合二叉搜索树特点，继续遍历判断\n小于，则不符合特点，返回false\n\n\n\n实现代码如下：\nclass Solution {    // 中序遍历    TreeNode pre = null;\t// 标记中序遍历顺序当前节点的前一个节点    public boolean isValidBST(TreeNode root) {        if (root == null)            return true;        boolean left = isValidBST(root.left);\t// 中序遍历先 遍历判断左子树        if (pre != null &amp;&amp; pre.val &gt;= root.val)\t\t// 再判断中            return false;\t// 不符合条件        pre = root;\t// 更新指针        boolean right = isValidBST(root.right);\t// 中序遍历 遍历判断右子树        return left &amp;&amp; right;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:42.3 MB,击败了70.75% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n空间复杂度：\n\n","categories":["leetcode"],"tags":["刷题","树","深度优先搜索","二叉树","二叉搜索树"]},{"title":"LCR146.螺旋遍历二维数组","url":"/2023/12/04/LCR146.%E8%9E%BA%E6%97%8B%E9%81%8D%E5%8E%86%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","content":"螺旋遍历二维数组给定一个二维数组 array，请返回「螺旋遍历」该数组的结果。\n螺旋遍历：从左上角开始，按照 向右、向下、向左、向上 的顺序 依次 提取元素，然后再进入内部一层重复相同的步骤，直到提取完所有元素。\n示例 1：\n输入： array = [[1,2,3],[8,9,4],[7,6,5]]输出：[1,2,3,4,5,6,7,8,9]\n示例 2：\n输入： array  = [[1,2,3,4],[12,13,14,5],[11,16,15,6],[10,9,8,7]]输出：[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]\n限制：\n\n0 &lt;= array.length &lt;= 100\n0 &lt;= array[i].length &lt;= 100\n\n注意：与螺旋矩阵_54一致\n解题解法一(模拟)思路分析：\n\n根据限制，可以使用暴力解法来解决，模拟遍历数组array，并将遍历的元素保存到返回结果中。\n\n注意遍历过程中，需要遵循循环不变量原则，即保证每次遍历的区间不发生改变。若采用左闭右闭的区间，则遍历过程中需遵循区间为左闭右闭。选择左闭右闭来解决。\n\n且根据返回结果为int[]，可以使用一个变量来标记遍历的个数\n\n需要特别注意 array.length == 0 时，数组为空，array[0]会出现报错，需要格外注意\n\n\nclass Solution {    public int[] spiralArray(int[][] array) {        if(array.length == 0)         // 处理异常情况 array=[] 时 直接返回            return new int[0];        int t = 0;        // 上边        int b = array.length - 1;        // 下边        int l = 0;        // 左边        int r = array[0].length    - 1;    // 右边        int s = (b+1)*(r+1);    // 总的数组元素个数        int k = 0;        // 记录遍历到的数组元素个数        int[] ans = new int[s];        // 区间为 左闭右闭        while (k &lt; s) {            // 上边 从左向右            // k &lt; s 保证循环过程中不会重复遍历数组            for (int j = l; j &lt;= r &amp;&amp; k &lt; s; ++j, ++k) {                ans[k] = array[t][j];            }            ++ t;        // 改边遍历完后 下次遍历下一行            // 右边 从上向下            for (int i = t; i &lt;= b &amp;&amp; k &lt; s; ++i, ++k) {                ans[k] = array[i][r];            }            -- r;            // 下边 从右往左            for (int j = r; j &gt;= l &amp;&amp; k &lt; s; --j, ++k) {                ans[k] = array[b][j];            }            -- b;            // 左边 从下往上            for (int i = b; i &gt;= t &amp;&amp; k &lt; s; --i, ++k) {                ans[k] = array[i][l];            }            ++ l;        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了97.64% 的Java用户    内存消耗:43.6 MB,击败了12.19% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(m*n)，即数组array的数组元素个数\n\n空间复杂度：O(1)，除了返回值以外，使用常数级变量\n\n\n总结： 需要格外注意空值，留意数组长度，即留意数组是否为空。\n","categories":["leetcode","剑指Offer"],"tags":["刷题","数组","矩阵","模拟"]},{"title":"Markdown语法及使用","url":"/2023/11/21/Markdown%E8%AF%AD%E6%B3%95%E5%8F%8A%E4%BD%BF%E7%94%A8/","content":"简介：Markdown 是一种轻量级标记语言，允许人们使用易读易写的纯文本格式编写文档。\n主要语法：Markdown 标题使用 # 来标记标题语法格式：\n# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题\n\n请注意以上 “一级标题” 与 “#” 之间的空格。\n效果示例如下：\n\nMarkdown 段落Markdown段落没有特殊格式，段落的换行号是：使用两个以上的空格加回车。\nMarkdown 字体及样式斜体、粗体、粗斜体以下使用*来标识斜体、粗体或粗斜体，且*可以被_下划线代替：\n*斜体文字***粗体文字*****粗斜体文字***\n\n效果展示如下：\n\n文字添加下划线下划线主要通过HTML的标签来实现：\n&lt;u&gt;带下划线的文本&lt;/u&gt;\n\n效果展示如下：\n\n文字显示删除线通过在文字的两端添加两个波浪线 ~ 来显示，语法格式如下：\n~~添加删除线的文字~~\n\n效果展示如下：\n\n文字添加脚注脚注是对文本的补充说明，语法格式如下：\n被脚注说明的文字[^脚注描述性文字][^脚注描述性文字]: 对需要被说明的文字进行说明\n\n注意：“脚注描述性文字” 的两处文本应该保持一致\n效果展示如下：\n\nMarkdown 分割线在一行中，可以使用三个以上的*或-或_来建立分割线，且行内不能有其他东西。语法格式如下：\n**** * *************- - -_ _ _ _ _\n\n效果展示如下：\n\nMarkdown 列表无序列表Markdown 使用* 或+或 -作为无序列表的标记，语法格式如下：\n* 第一项* 第二项* 第三项\n\n效果展示如下：\n\n有序列表有序列表直接使用数字加.来实现，即1.来表示序号1，注意1.与后续文字之间应该有一个空格字符，语法格式如下：\n1. 第一项2. 第二项3. 第三项\n\n效果展示如下：\n\n列表嵌套列表嵌套，需要在子列表的选项前添加4个空格，语法格式如下：\n1. 第一项    - 第一项的第一个子列表    - 第一项的第二个子列表2. 第二项    - 第二项的第一个子列表    - 第二项的第二个子列表\n\n效果展示如下：\n\nMarkdown 区块引用Markdown 区块引用时在段落开头使用 &gt;符号加一个空格，        同时区块也可以进行嵌套，一个&gt;符号表示第一层，两个&gt;&gt;表时第二层，依次类推……        语法格式如下：\n&gt; 区块引用&gt; 第一层区块引用&gt;&gt; 第二层区块引用&gt;&gt;&gt; 第三层区块引用\n\n效果展示如下：\n\nMarkdown 代码框行内代码行内代码使用两个单引号包起来即可，语法格式如下：\n`行内代码`\n\n效果展示如下：\n\n代码区块使用三个单引号开始，和三个单引号结束，代码包含在中间，同时还可以指定代码块语言。语法示例如下：\n```代码块\n效果展示如下：![1700570340343](https://github.com/YTAZWC/picx-images-hosting/raw/master/1700570340343.webp)## Markdown 链接### 简单使用链接链接使用示例如下所示：```markdown[链接名称](链接地址)或&lt;链接地址&gt;\n\n两种使用方式效果展示如下：\n\n变量代替链接链接可以用变量来代替，并在文档末尾附带变量地址，示例语法如下：\n这个链接1作为网址变量[baidu][1][1]: https://baidu.com\n\n效果展示如下：\n\nMarkdown 图片Markdown 图片格式如下所示：\n![alt 属性文本](图片网址 \"可选标题\")\n\n效果展示如下：\n\nMarkdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用-来分隔表头和其他行。语法格式如下：\n|表头1|表头2||----|----||单元格11|单元格12||单元格12|单元格22|\n\n效果展示如下：\n\n对齐方式设置表头对齐方式有如下几种：\n\n-:设置右对齐\n\n:-设置左对齐\n\n:-:设置居中对齐\n语法示例如下所示：\n|左对齐|居中对齐|右对齐||:----|:----:|----:||单元格11|单元格12|单元格13||单元格21|单元格22|单元格23|\n\n效果展示如下：\n\n\n\nMarkdown 转义对于Markdown中的一些特殊符号，可以使用反斜杠来进行转义\n插入数学公式当需要在编辑器中插入数学公式时，可以使用两个美元$$符号包裹TeX或LaTeX格式的数学公式来实现，代码示例如下：\n$$\\int_0^1 {x^2} \\,{\\rm d}x$$\n\n效果展示如下：\n\n参考文章Markdown常用语法汇总 - 知乎 (zhihu.com)\n","categories":["Markdown"],"tags":["Markdown","语法"]},{"title":"Spring整合Redis","url":"/2024/03/17/Spring%E6%95%B4%E5%90%88Redis/","content":"引入依赖在pom.xml文件导入如下依赖：\n&lt;!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-redis --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;version&gt;2.6.13&lt;/version&gt;   &lt;!--可以省略版本 由SpringBoot自动确定适配版本--&gt;&lt;/dependency&gt;\n\n配置Redis配置Redis数据库参数在application.properties配置文件中，填写以下配置:\n# RedisProperties# 确定使用Redis的第11号数据库spring.redis.database=11# 配置Redis连接地址spring.redis.host=localhost# 配置Redis连接端口spring.redis.port=6379# 配置连接Redis的密码  Redis数据库无密码则不需要此配置spring.redis.password=连接密码\n\n配置结果如下图所示：\n\n编写配置类，构造RedisTemplateRedisConfig.class配置类如下，用于获取RedisTemplate类\n/** * @author 花木凋零成兰 * @date 2024/3/17 14:58 */@Configurationpublic class RedisConfig {    /**     * 获取访问Redis模板类     * @param factory Redis连接工厂类 自动装配     * @return     */    @Bean    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) {        RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;&gt;();        template.setConnectionFactory(factory); // 配置连接工厂        // 需要配置序列化方式  将Java类型数据存到Redis数据库中        // 设置 key 的序列化方式        template.setKeySerializer(RedisSerializer.string());    // RedisSerializer.string()序列字符串的序列化器        // 设置 value 的序列化方式        template.setValueSerializer(RedisSerializer.json());    // 序列化为json        // 设置 hash 的key的序列化方式        template.setHashKeySerializer(RedisSerializer.string());        // 设置 hash 的value的序列化方式        template.setHashValueSerializer(RedisSerializer.json());                // 使配置文件中的配置生效        template.afterPropertiesSet();                return template;    }}\n\nRedis操作模板类常用方法操作如下：操作字符串：\n\nredisTemplate.opsForValue()\n\n操作哈希：\n\nredisTemplate.opsForHash()\n\n操作列表：\n\nredisTemplate.opsForList()\n\n操作集合(无序):\n\nredisTemplate.opsForSet()\n\n操作集合(有序)\n\nredisTemplate.opsForZSet()\n\n进行测试测试代码如下：\n/** * @author 花木凋零成兰 * @date 2024/3/17 15:43 */@SpringBootTest@ContextConfiguration(classes = Application.class)        // 使用Application类的配置public class RedisTest {    @Autowired    private RedisTemplate redisTemplate;    // 注入redisTemplate    @Test    public void testStrings() {        System.out.println(\"测试对字符串的操作...\");        String redisKey = \"test:count\";        redisTemplate.opsForValue().set(redisKey, 1);   // 存字符串数据        System.out.println(redisTemplate.opsForValue().get(redisKey));    // 获取key对应的value        System.out.println(redisTemplate.opsForValue().increment(redisKey));    // 自动增加key对应的value        System.out.println(redisTemplate.opsForValue().decrement(redisKey));    // 自动减少key对应的value    }    @Test    public void testHashes() {        System.out.println(\"测试对哈希的操作...\");        String redisKey = \"test:user\";        // 存哈希数据        redisTemplate.opsForHash().put(redisKey, \"id\", 1);        redisTemplate.opsForHash().put(redisKey, \"username\", \"zhangsan\");        // 获取哈希数据        System.out.println(redisTemplate.opsForHash().get(redisKey, \"id\"));        System.out.println(redisTemplate.opsForHash().get(redisKey, \"username\"));    }    @Test    public void testLists() {        System.out.println(\"测试对列表的操作...\");        String redisKey = \"test:ids\";        // 将值 从左边 插入列表        redisTemplate.opsForList().leftPush(redisKey, 101);        redisTemplate.opsForList().leftPush(redisKey, 102);        redisTemplate.opsForList().leftPush(redisKey, 103);        // 获取当前列表 数据个数        System.out.println(redisTemplate.opsForList().size(redisKey));        // 获取列表 索引所对应数据        System.out.println(redisTemplate.opsForList().index(redisKey, 0));        // 获取列表 索引 在[]范围内的数据        System.out.println(redisTemplate.opsForList().range(redisKey, 0, 2));        // 将值 从左边 弹出列表        System.out.println(redisTemplate.opsForList().leftPop(redisKey));        System.out.println(redisTemplate.opsForList().leftPop(redisKey));        System.out.println(redisTemplate.opsForList().leftPop(redisKey));    }    @Test    public void testSets() {        System.out.println(\"测试对(无序)集合的操作...\");        String redisKey = \"test:teachers\";        // 存set数据 可一次性存多个        redisTemplate.opsForSet().add(redisKey, \"刘备\", \"关羽\", \"张飞\", \"赵云\", \"诸葛\");        // 获取set中数据个数        System.out.println(redisTemplate.opsForSet().size(redisKey));        // 随机弹出set中的某个数据        System.out.println(redisTemplate.opsForSet().pop(redisKey));        // 展示set中的数据        System.out.println(redisTemplate.opsForSet().members(redisKey));    }    @Test    public void testSortedSets() {        System.out.println(\"测试对(有序)集合的操作...\");        String redisKey = \"test:students\";        // 插入元素        redisTemplate.opsForZSet().add(redisKey, \"唐僧\", 80);        redisTemplate.opsForZSet().add(redisKey, \"孙悟空\", 90);        redisTemplate.opsForZSet().add(redisKey, \"猪八戒\", 70);        redisTemplate.opsForZSet().add(redisKey, \"沙悟净\", 75);        redisTemplate.opsForZSet().add(redisKey, \"白龙马\", 65);        // 统计数据个数        System.out.println(redisTemplate.opsForZSet().size(redisKey));        // 获取某个元素 的分数        System.out.println(redisTemplate.opsForZSet().score(redisKey, \"猪八戒\"));        // 获取某个元素 按大到小在集合的排名 的位置索引(从0开始)        System.out.println(redisTemplate.opsForZSet().reverseRank(redisKey, \"猪八戒\"));        // 获取元素 按大到小排名的 0-2个元素        System.out.println(redisTemplate.opsForZSet().reverseRange(redisKey, 0, 2));    }    @Test    public void testKeys() {        System.out.println(\"测试一些公共方法操作...\");        redisTemplate.delete(\"test:user\");  // 删除key所对的数据        // 判断key是否存在        System.out.println(redisTemplate.hasKey(\"test:user\"));        // 设置某个key的过期时间        redisTemplate.expire(\"test:students\", 10, TimeUnit.SECONDS);    }}\n\n测试结果如下所示：\n\n优化redis多次访问同一个key即将key绑定到一个对象上，不需要在每次对key所对应的value进行操作时，再传入key\n实现代码如下：\n@SpringBootTest@ContextConfiguration(classes = Application.class)        // 使用Application类的配置public class RedisTest {    @Autowired    private RedisTemplate redisTemplate;    // 注入redisTemplate    @Test    public void testBoundOperations() {        System.out.println(\"多此访问同一个key; 将其绑定到一个对象, 即绑定对象...\");        String redisKey = \"test:count\";        BoundValueOperations operations = redisTemplate.boundValueOps(redisKey);    // 绑定key        // 接下来对同一个key进行操作 不需要再传入key        System.out.println(operations.get());   // 获取绑定的key 对应的值        // 对key所对应的value进行自增 5 次        operations.increment();        operations.increment();        operations.increment();        operations.increment();        operations.increment();        System.out.println(operations.get());   // 获取绑定的key 对应的值    }}\n\n测试结果如下：\n\nRedis事务管理redis事务机制：\n启用事务后；执行某条redis命令时，不会立刻执行；而是将命令暂存到队列中，直到操作结束，提交事务时，再将队列中的所有命令发送给Redis，再执行队列中的命令.\n编程式事务演示在某个方法内的某部分代码，启用事务。\n测试代码如下：\n@SpringBootTest@ContextConfiguration(classes = Application.class)        // 使用Application类的配置public class RedisTest {    // 编程式事务    @Test    public void testTransactional() {        Object obj =  redisTemplate.execute(new SessionCallback() {            @Override            public Object execute(RedisOperations operations) throws DataAccessException {                // redisTemplate.execute()方法调用时；底层自动调用该execute方法                // operations 用于执行操作命令                String redisKey = \"test:text\";                operations.multi(); // 启用事务                // 添加数据到set                operations.opsForSet().add(redisKey, \"zhangsan\", \"lisi\", \"wangwu\");                // 因为事务还未提交 即上述添加数据命令 还未执行                // 此时查看对应 set 集合中的数据 应该不存在上述添加数据                System.out.println(operations.opsForSet().members(redisKey));                return operations.exec();   // 提交事务 并结束方法调用            }        });        System.out.println(\"obj: \" + obj);    // 查看事务类型信息等    }}\n\n测试结果如下：\n\n即由上述测试结果，证明了，redis事务是等到操作结束后，再执行队列中的命令；且事务得到的对象结果为[操作成功次数(一次添加数据成功数据个数)，操作的数据]\n","categories":["开发学习"],"tags":["Spring","Spring Boot","Redis"]},{"title":"三数之和_15","url":"/2023/12/14/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C-15/","content":"三数之和15. 三数之和 - 力扣（LeetCode）\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n你返回所有和为 0 且不重复的三元组。\n注意： 答案中不可以包含重复的三元组。\n示例 1：\n输入： nums = [-1,0,1,2,-1,-4]输出：[[-1,-1,2],[-1,0,1]]解释：nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。注意，输出的顺序和三元组的顺序并不重要。\n示例 2：\n输入： nums = [0,1,1]输出： []解释： 唯一可能的三元组和不为 0 。\n示例 3：\n输入： nums = [0,0,0]输出： [[0,0,0]]解释： 唯一可能的三元组和为 0 。\n提示：\n\n\n\n\n解法一(排序+双指针)思路分析：\n\n首先思考暴力求解，其时间复杂度为，同时还需要使用哈希表对所得元组进行去重，对此需要换一种思路来解决。\n\n我们需要思考不重复的本质，对于一个三元组[1, 2, 3]，有六种排列情况，为了避免出现六种情况，可以对三个元素进行保证，即\n\n第二个元素不低于第一个元素\n\n第三个元素不低于第一个元素\n\n\n\n即保证三元组[a, b, c]，满足，如此在枚举三个元素时，可以保证不会出现重复的元组，即因为，不会出现枚举出[2, 3, 1]的情况，即只会出现[1, 2, 3]的情况\n\n因此我们可以对题目给出数组 nums进行排序，然后再去寻找满足条件的三元组，如此可避免重复情况，也方便排除重复的三元组\n\n因为需要寻找满足的三元组，因此对于暴力求解中的第二重循环和第三重循环，可以发现每当b从前往后枚举增加时，c应该减少才能继续满足a+b+c = 0的关系式\n\n因此我们可以使用双指针，即当需要枚举数组的两个元素时，发现伴随第一个元素的递增，第二个元素是递减的，那么可以使用双指针(相向双指针)，将枚举的时间复杂度由减少至\n\n所以我们可以使用双指针来寻找b和c，同时需要注意的是，需要一直保持左指针小于右指针，即保证 ，且当a+b+c &gt; 0时，说明c的值过大，右指针需要向做移动，当a+b+c &lt; 0时，说明b的值较小，左指针需要向右移动；当找到对应元组，即a+b+c = 0时，将元组保存到返回结果中，并移动左右指针\n\n同时因为数组中会出现重复元素，即排序后这些重复元素会排列在一起，因此我们进行去重操作，如if(i&gt;0 &amp;&amp; nums[i] == nums[i-1]) continue\n\n\n实现代码如下：\nclass Solution {    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        Arrays.sort(nums);    // 对数组元素进行排序        for (int i = 0; i &lt; nums.length-2; ++i) {    // 寻找元组的第一个数a            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) {    // 跳过重复的数                continue;            }            int a = nums[i];    // 找到元组的第一个数a            // 寻找元组的第二个数b和第三个数c            int j = i+1;            int k = nums.length-1;            while (j &lt; k) {        // 相向双指针 遍历寻找                int s = a + nums[j] + nums[k];                if (s &gt; 0) {    // 说明 c 的值过大                    -- k;        // 移动右指针 往前继续寻找 c 即让c减小                } else if (s &lt; 0) {                    ++ j;        // 移动左指针 往后继续寻找 b                } else {    // 找到符合条件的元组                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                    list.add(a);                    list.add(nums[j]);                    list.add(nums[k]);                    ans.add(list);    // 将元组保存到返回值中                    // 移动左指针                    ++ j;                    while (j &lt; k &amp;&amp; nums[j] == nums[j-1])    // 跳过重复的数 避免重复添加相同的元组                        ++ j;                    // 移动右指针                    -- k;                    while (j &lt; k &amp;&amp; nums[k] == nums[k+1])    // 跳过重复的数 避免重复添加相同元组                        -- k;                }            }        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:29 ms,击败了87.06% 的Java用户    内存消耗:50.4 MB,击败了16.79% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，对数组进行排序的时间复杂度为，对数组进行遍历寻找元素的时间复杂度为，综合起来时间复杂度为\n\n空间复杂度：，忽略排序所需要的空间，其余变量只使用了的空间复杂度。\n\n\n优化解法一(剪枝)思路分析：\n\n在将数组按照非递减顺序排序后，不难确定，当确定一个数a时\n\n若时，即a与右边相近的连续两个数相加结果大于0，那么a继续与后续的其他数相加，也一定大于0，所以此时已不存在满足 a + b + c = 0的元组，那么可以直接break退出循环。\n\n同时若有，即此时的a与数组中两个最大的元素相加 结果依然小于0，那么a与其他数组元素相加的结果依然会小于0，也不存在满足a + b + c = 0的元组，所以continue继续往后遍历寻找a\n\n\n优化代码如下：\nclass Solution {    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        Arrays.sort(nums);    // 对数组元素进行排序        for (int i = 0; i &lt; nums.length-2; ++i) {    // 寻找元组的第一个数a            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) {    // 跳过重复的数                continue;            }            int a = nums[i];    // 找到元组的第一个数a            if (a + nums[i+1] + nums[i+2] &gt; 0)    // 因为数组按非递减排序                break;    // 若此时数组中连续三个数相加结果大于0 则后续不存在别的数使得a+b+c=0成立            if (a + nums[nums.length-2] + nums[nums.length-1] &lt; 0)                continue;    // 若此时a+数组中末尾两个最大的数结果小于0 则此时的a添加其他数依然会小于0            // 寻找元组的第二个数b和第三个数c            int j = i+1;            int k = nums.length-1;            while (j &lt; k) {        // 相向双指针 遍历寻找                int s = a + nums[j] + nums[k];                if (s &gt; 0) {    // 说明 c 的值过大                    -- k;        // 移动右指针 往前继续寻找 c 即让c减小                } else if (s &lt; 0) {                    ++ j;        // 移动左指针 往后继续寻找 b                } else {    // 找到符合条件的元组                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();                    list.add(a);                    list.add(nums[j]);                    list.add(nums[k]);                    ans.add(list);    // 将元组保存到返回值中                    // 移动左指针                    ++ j;                    while (j &lt; k &amp;&amp; nums[j] == nums[j-1])    // 跳过重复的数 避免重复添加相同的元组                        ++ j;                    // 移动右指针                    -- k;                    while (j &lt; k &amp;&amp; nums[k] == nums[k+1])    // 跳过重复的数 避免重复添加相同元组                        -- k;                }            }        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:25 ms,击败了99.46% 的Java用户    内存消耗:50.1 MB,击败了38.47% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n注意对于去重的代码，应该放在最后的添加到结果中，而不是移动左右指针便立马去重，考虑特殊情况，即数组为[0, 0, 0, 0, 0]时\n","categories":["leetcode"],"tags":["刷题","数组","排序","双指针"]},{"title":"两两交换链表中的节点_24","url":"/2023/12/08/%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-24/","content":"两两交换链表中的节点24. 两两交换链表中的节点 - 力扣（LeetCode）\n给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。\n示例 1：\n\n输入： head = [1,2,3,4]输出：[2,1,4,3]\n示例 2：\n输入： head = []输出：[]\n示例 3：\n输入： head = [1]输出：[1]\n提示：\n\n链表中节点的数目在范围 [0, 100] 内\n0 &lt;= Node.val &lt;= 100\n\n解题解法一(双指针迭代)思路分析：\n\n考虑使用双指针，使用双指针遍历链表，并对双指针指向的链表节点进行交换\n\n指针p指向交换的第一个节点，指针q指向交换的第二个节点\n\n先将q指向的下一个节点赋值给p的下一个节点，再让q的下一个节点指向p完成交换\n\n需要注意，使用一个指针pre标记新链表的末尾，将交换好的一组节点与新链表进行链接\n\n\n实现代码如下：\nclass Solution {    public ListNode swapPairs(ListNode head) {        if (head == null || head.next == null) {            // 空链表或链表中只有一个节点 无需交换            return head;        }        ListNode p = head;        ListNode q = head.next;        head = q;    // 此时头节点更新为原链表的第二节点        ListNode pre = null;        while (q != null) {            // 进行节点交换            p.next = q.next;            q.next = p;            // 将交换好的一组节点与 已交换好的链表链接            if (pre != null)                pre.next = q;            // 更新交换好的新链表的尾节点            pre = p;            // 交换一组节点后 移动双指针            p = p.next;            if (p == null) // 若此时已移动到末尾则退出循环                break;            q = p.next;        }        return head;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.4 MB,击败了9.03% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，需要遍历链表\n\n空间复杂度：O(1)，声明使用了常量级变量\n\n\n解法二(递归)思路分析：\n\n实现递归，主要根据解法一双指针迭代来进行，即创建一个新的递归函数，并根据解法一中循环的边界条件，以及迭代的规律来推导递归函数中的规律。\n\n实现代码如下：\nclass Solution {    public ListNode swapPairs(ListNode head) {        if (head == null || head.next == null) {            // 空链表或链表中只有一个节点 无需交换            return head;        }        // 根据链表交换规律 交换后新链表的头节点为head.next        ListNode newHead = head.next;    // 暂时先记录新链表的头节点        swapListNode(head, head.next, null);        return newHead;    // 交换完成后 返回新链表    }    private void swapListNode(ListNode p, ListNode q, ListNode pre) {        if (q == null) return ;        // 进行交换        p.next = q.next;        q.next = p;        // 进行链接        if (pre != null)            pre.next = q;        // 继续交换        if (p.next == null) return ;        swapListNode(p.next, p.next.next, p);    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.5 MB,击败了5.70% 的Java用户\n\n\n时间复杂度：O(n)，需要遍历链表\n\n空间复杂度：O(1)，声明使用了常量级变量\n\n\n","categories":["leetcode"],"tags":["刷题","链表","递归"]},{"title":"两个数组的交集_349","url":"/2023/12/11/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86-349/","content":"两个数组的交集349. 两个数组的交集 - 力扣（LeetCode）\n给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。\n示例 1：\n输入： nums1 = [1,2,2,1], nums2 = [2,2]输出：[2]\n示例 2：\n输入： nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[9,4]解释：[4,9] 也是可通过的\n提示：\n\n\n\n\n解法一(数组哈希)思路分析：\n\n首先考虑数组中值的范围，在，所以可以使用一个数组来作为哈希表\n\n因此可以使用一个哈希数组来统计数组nums1中出现的值，然后对数组nums2进行遍历。\n\n因为题目要求返回的交集中，每个元素是唯一的，因此在找到nums2中的交集元素时，需要将哈希数组的该元素的统计数更新为-1，表示交集中不再需要含有该元素\n\n\n实现代码如下：\nclass Solution {    public int[] intersection(int[] nums1, int[] nums2) {        int[] hash = new int[1001];        // 哈希数组        int[] ans = new int[nums1.length];    // 存储交集        for (int number: nums1) {    // 统计数组nums1中的元素            ++ hash[number];        }        int k = 0;    // ans数组的索引        for (int number: nums2) {    // 遍历数组nums2 寻找交集中的元素            if (hash[number] &gt; 0) {                ans[k++] = number;                hash[number] = -1;    // 更新哈希数组中对应的值 表示交集中不在需要该元素            }        }        int[] anss = new int[k];        // 数组复制    arraycopy(源数组, 源数组中的起始位置, 目标数组, 目标数组的起始位置, 复制的长度)        System.arraycopy(ans, 0, anss, 0, k);        return anss;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:41.4 MB,击败了84.85% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n是数组nums1的长度，m是数组nums2的长度，k则是指两个数组的交集的元素个数\n\n空间复杂度：，最多使用的数组空间是1001，属于已知的常量级，存储交集的数组也包含在内。\n\n\n","categories":["leetcode"],"tags":["刷题","数组","排序","哈希表","二分查找","双指针"]},{"title":"两个数组的交集II_350","url":"/2023/12/12/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86II-350/","content":"两个数组的交集II给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n示例 1：\n输入： nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2]\n示例 2:\n输入： nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9]\n提示：\n\n\n\n\n进阶：\n\n如果给定的数组已经排好序呢？你将如何优化你的算法？\n如果 nums1 的大小比 nums2 小，哪种方法更优？\n如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？\n\n解法一(数组哈希)思路分析：\n\n数组元素值得范围在1000以内，因此使用数组作为哈希表，先对数组nums1进行遍历，并记录对应元素得数量\n\n因为题目要求，交集中相同元素得数量也要与两个数组相对应，所以在对数据nums2进行遍历寻找交集元素时，每找到一个交集元素，需要将哈希数组中存储的该元素的数目-1，表示该元素已经添加一个进入返回数组中\n\n遍历数组nums2结束后，再对返回结果进行处理\n\n\n实现代码如下：\nclass Solution {    public int[] intersect(int[] nums1, int[] nums2) {        int[] hash = new int[1001];\t\t// 哈希数组        int[] ans = new int[nums1.length];\t// 预返回结果数组        int k = 0;\t// 记录交集的元素个数        for (int num: nums1) {\t// 记录数组nums1中的元素及其数量            ++ hash[num];        }        for (int num: nums2) {  // 遍历数组nums2寻找交集中的元素            if (hash[num] &gt; 0) {                ans[k++] = num;\t\t// 将交集中的元素保存到返回数组中                -- hash[num];\t\t// 保存一个交集元素 则记录该元素的数目-1            }        }        // 对返回结果进行处理        int[] anss = new int[k];        for (int i = 0; i &lt; k; ++i)            anss[i] = ans[i];        return anss;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:41.2 MB,击败了72.79% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n指nums1的元素数目，m指nums2的元素数目，k则是指交集中的元素\n\n空间复杂度：，使用常量级的哈希数组变量，返回值数组的大小也控制在一个常量级内。\n\n\n","categories":["leetcode"],"tags":["刷题","数组","排序","哈希表","二分查找","双指针"]},{"title":"两数之和_1","url":"/2023/11/25/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-1/","content":"两数之和原题链接\n给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n示例 2：\n输入：nums = [3,2,4], target = 6输出：[1,2]\n\n示例 3：\n输入：nums = [3,3], target = 6输出：[0,1]\n\n提示：\n\n\n\n\n只会存在一个有效答案\n\n解题\n首先我们可以先将数组元素存储到哈希表中\n\n然后对数组进行遍历\n\n每遍历一个元素，就查询哈希表中是否具有对应的值num，使num+nums[i] = target成立\n\n且查询到的值的索引不能与当前遍历的数组元素的索引相同\n\n若满足条件则退出循环，并返回结果\n\n\n具体代码实现如下：\nclass Solution {    public int[] twoSum(int[] nums, int target) {        // 创建哈希表存储数组元素        HashMap&lt;Integer, Integer&gt; numHash = new HashMap&lt;&gt;();        int n = nums.length;    // 记录数组长度        int i = 0;        int j = 0;        // 将数组元素存储到哈希表中        for (i = 0; i &lt; n; ++i) {            numHash.put(nums[i], i);        }        // 通过遍历数组元素，并查询哈希表找出对应的另一个整数        for (i = 0; i &lt; n; ++i) {            int num = target - nums[i];            if (numHash.containsKey(num) &amp;&amp; numHash.get(num) != i) {                j = numHash.get(num);                break;            }        }        return new int[]{i, j};    }}\n\n提交结果如下所示：\n解答成功:    执行耗时:4 ms,击败了53.42% 的Java用户    内存消耗:43 MB,击败了5.00% 的Java用户\n\n进一步优化，思路如下：\n\n首先关于如何查询 数组中存在的另一个满足条件的元素 target-num[i] 时间复杂度为O(1)，无法再进行优化\n通过与官方题解对比，主要耗费时间在于第一次遍历数组将数组元素存储到哈希表需要耗费不少时间\n可以尝试将第一次遍历数组和第二次遍历数组结合起来\n\n代码实现如下：\nclass Solution {    public int[] twoSum(int[] nums, int target) {        HashMap&lt;Integer, Integer&gt; numHash = new HashMap&lt;&gt;();        int n = nums.length;        for (int i = 0; i &lt; n; ++i) {            int num = target - nums[i];            if (numHash.containsKey(num)) {                return new int[]{i, numHash.get(num)};            } else {                numHash.put(nums[i], i);            }        }        return new int[]{0};    }}\n\n我们对于每一个nums[i]先查询表中是否存在target - nums[i]：\n\n若不存在，则说明对应的target - nums[i]要么不在数组中；要么在数组中，只是还未插入哈希表中，因此可将该元素插入到哈希表中，在后续遍历到值为target - nums[i]的数组元素时，即可获得最终结果。\n若存在，则说明已经找到满足条件的答案，直接将查找结果返回即可\n\n使用如上方法，不但减少时间复杂度以及对空间的损耗，还可以避免查询到的target - nums[i]与自身nums[i]匹配。\n提交结果如下所示：\n解答成功:    执行耗时:1 ms,击败了99.55% 的Java用户    内存消耗:42.5 MB,击败了63.87% 的Java用户\n","categories":["leetcode"],"tags":["刷题","数组","哈希表"]},{"title":"二分查找_704","url":"/2023/11/25/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-704/","content":"二分查找原题链接\n给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。\n示例 1:\n输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4\n\n示例 2:\n输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1\n\n提示：\n\n你可以假设 nums 中的所有元素是不重复的。\nn 将在 [1, 10000]之间。\nnums 的每个元素都将在 [-9999, 9999]之间。\n\n解题解题思路：\n\n使用二分查找对数组进行查找\n每次对数组进行二分，获得中间索引mid，然后比较nums[mid]和target\n如果nums[mid] &lt; target，则说明target在数组的右侧，从mid+1处开始查找\n如果nums[mid] &gt; target，则说明target在数组的左侧，以mid-1为终点，重新查找\n如果nums[mid] = target，即查找到对应值，将其索引返回，否则返回-1即可\n\n实现代码如下：\nclass Solution {    public int search(int[] nums, int target) {        int left = 0;        int right = nums.length - 1;        while (left &lt;= right) {            int mid = (right - left) / 2 + left;    // 避免 right+left超出int范围            if (nums[mid] &lt; target) {                left = mid + 1;            } else if (nums[mid] &gt; target) {                right = mid - 1;            } else {                return mid;            }        }        return -1;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.7 MB,击败了5.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(logn)\n空间复杂度：O(1)\n\n","categories":["leetcode"],"tags":["刷题","数组","二分查找"]},{"title":"二叉树","url":"/2023/12/27/%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"二叉树理论基础二叉树的种类在我们解题过程中二叉树有两种主要的形式：满二叉树和完全二叉树。\n满二叉树如果一棵二叉树只有度为0的结点和度为2的结点，且度为0的结点在同一层上，则这棵二叉树为满二叉树。\n如下图所示：\n\n上述这棵树为满二叉树，也可以说深度为，有个节点的二叉树。\n完全二叉树即在二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下一层的节点都集中在该层左边的若干位置，若最底层为第层(从1开始)，则该层包含个节点。\n例如如下图所示：\n\n例如优先级队列是一个堆，堆就是一颗完全二叉树，同时保证父子节点的顺序关系。\n二叉搜索树二叉搜索数是有树值的，二叉搜索树是一个有序树。\n有以下特点：\n\n若它的左子树不空，则左子树上的所有结点的值均小于它的根结点的值；\n\n若它的右子树不空，则右子树上的所有结点的值均大于它的根节点的值；\n\n它的左、右子树也分别为二叉排序树\n\n\n例如以下两棵搜索树：\n\n平衡二叉搜索树平衡二叉搜索树，又被称为AVL(Adelson-Velsky and Landis)树，且具有以下性质：它是一棵空树 或 它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一颗平衡二叉树。\n例如如图所示：\n\n最后一棵树不是平衡二叉树，是因为它的左右两个子树的高度差的绝对值超过了1。\n注意需要熟悉自己的编程语言是如何实现的\n二叉树的存储方式二叉树可以链式存储，也可以顺序存储。\n链式存储链式存储方式是使用指针，即通过指针把分布在各个地址的节点串联在一起。\n例如如下图所示：\n\n顺序存储顺序存储则是使用数组，即顺序存储的元素在内存是连续分布的；存储方式如下图所示：\n\n对于顺序存储遍历二叉树有以下规律：\n如果父节点的数组下标是，则它的左孩子节点就是，右孩子下标就是。\n结语用链式存储的二叉树，更有利于理解，所以一般使用链式存储二叉树，但是需要了解数组依然可以表示二叉树。\n二叉树的遍历方式二叉树主要有两种遍历方式：\n\n深度优先遍历：先往深走，遇到叶子节点再往回走。\n\n广度优先遍历：一层一层的去遍历\n\n\n这两种遍历也是图论中最基本的两种遍历方式。\n对于上述两种遍历方式再进一步分析，有如下遍历方式：\n\n深度优先遍历\n\n前序遍历(迭代法，递归法)\n\n中序遍历(迭代法，递归法)\n\n后序遍历(递归法，迭代法)\n\n\n\n广度优先遍历\n\n层次遍历(迭代法)\n\n\n\n深度优先遍历在深度优先遍历中，前、中、后序遍历指的是中间节点的遍历顺序，因此前、中、后序遍历根据中间节点遍历的方式如下：\n\n前序遍历：中左右\n\n后序遍历：左右中\n\n中序遍历：左中右\n\n\n具体例子如下图所示：\n\n广度优先遍历按层来一层一层往下遍历二叉树\n具体实现方式在做二叉树相关问题时，经常使用递归的方式来实现深度优先遍历，即对于前中后序遍历，使用递归较为方便。\n同时在讲述栈与队列时，有提过栈其实就是递归的一种实现结果，即前中后序遍历的逻辑可以借助栈使用递归的方式实现。\n对于广度优先遍历的实现，一般使用队列来实现，利用队列先进先出的特点，一层一层的遍历二叉树\n二叉树的定义顺序存储使用数组来存，对于链式存储需要定义二叉树节点，Java定义如下所示：\npublic class TreeNode {    int val;    TreeNode left;    TreeNode right;    TreeNode() {}    TreeNode(int val) { this.val = val; }    TreeNode(int val, TreeNode left, TreeNode right) {        this.val = val;        this.left = left;        this.right = right;    }}\n\n相对于链表，二叉树节点中多了一个指针，即两个指针分别指向左右孩子。\n总结同时需要注意，面试可能要求手写定义代码，因此需要能够手写出二叉树的具体定义，对于其他数据结构也是如此。\n二叉树是一种基本的数据结构，我们需要熟练掌握，同时也不得不学会掌握递归。\n二叉树的递归遍历递归一般写法主要是根据以下三个要素写递归：\n\n确定递归函数的参数和返回值；即确定哪些参数是递归过程中需要处理的，那么就在递归函数里加上该参数，且明确每次递归的返回值是什么从而确定递归函数的返回类型。\n\n确定终止条件：写完递归算法，运行时可能会出现栈溢出的错误，说明没有考虑终止条件或终止条件不对；操作系统是用一个栈结构来保存每一层递归的信息，如果递归没有终止，则操作系统的内存栈必然会溢出。\n\n确定单层递归的逻辑：确定每一层递归需要处理的信息，在这里也会重复调用自己来实现递归的过程。\n\n\n前序遍历示例\n确定递归函数的参数和返回值：因为需要获取二叉树的节点值，且要保存到一个列表中，所以函数中需要两个参数，二叉树节点参数和列表参数，此外不需要返回值，所以确定函数名代码如下\n\nprivate void preorderTraversal(TreeNode node, List&lt;Integer&gt; ans)\n\n\n确定递归终止条件：在遍历过程中，当遍历到二叉树的末尾时，节点为空，不用再继续往下遍历，所以终止递归的条件为 节点为空node == null\n\nif (node == null)    return ;    // 递归终止条件\n\n\n确定单层递归的逻辑：因为前序遍历是中左右，所以先获取中节点的值，然后再继续获取左，最后再右，代码如下：\n\n// 递归过程ans.add(node.val);    // 先遍历父节点preorderTraversal(node.left, ans);    // 再遍历左子节点preorderTraversal(node.right, ans);    // 最后遍历右子节点\n\n综上所述，完整解题代码如下：\nclass Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        preorderTraversal(root, ans);        return ans;    }    private void preorderTraversal(TreeNode node, List&lt;Integer&gt; ans) {        if (node == null)            return ;    // 递归终止条件        // 递归过程        ans.add(node.val);    // 先遍历父节点        preorderTraversal(node.left, ans);    // 再遍历左子节点        preorderTraversal(node.right, ans);    // 最后遍历右子节点    }}\n\n例题如下：LC144.二叉树的前序遍历\nLC145.二叉树的后序遍历\nLC94.二叉树的中序遍历\n二叉树的迭代遍历理论可以使用迭代实现二叉树的前中后序遍历的理论：\n在计算机内部，递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，递归返回时，再从栈顶弹出上一次递归的各项参数，这也是递归为什么可以返回上一层位置的原因。\n例题如下：LC144.二叉树的前序遍历\nLC145.二叉树的后序遍历\nLC94.二叉树的中序遍历\n迭代写法前序遍历根据前序遍历，每次先处理中间节点，所以初始遍历时，要提前将根节点保存到栈中，然后在遍历中，根据栈后进先出的规律；先右孩子入栈，再左孩子入栈；更详细思路看 LC144.二叉树的前序遍历 解法二 \n具体代码如下：\nclass Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)    // 边界条件            return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();    // 用于存储二叉树的节点        stack.push(root);        while (!stack.isEmpty()) {            // 前序遍历先遍历 中            TreeNode node = stack.pop();            ans.add(node.val);            // 根据栈后进先出 先保存右节点            if (node.right != null)    // 空结点不入栈                stack.push(node.right);            // 再保存左节点            if (node.left != null)                stack.push(node.left);        }        return ans;    }}\n\n中序遍历此时对于中序遍历的代码，无法再套用前序遍历的代码，即前序遍历代码的逻辑无法再用到中序遍历上\n中序遍历是左中右，是先访问二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始正式处理节点，即处理节点顺序与访问顺序是不一致的。\n那么再使用迭代法写中序遍历时，可以借助指针的遍历来帮助访问节点，栈则用来处理节点上的元素。\n代码如下：\n// 另一种迭代写法    public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        if (root == null)    // 边界条件            return ans;        Deque&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();        TreeNode cur = root;        while (cur != null || !stack.isEmpty()) {            if (cur != null) {    // 如果该节点不为空 则让其一直往左                stack.push(cur);                cur = cur.left;            } else {                cur = stack.pop();    // 此时处理栈弹出的元素                ans.add(cur.val);                cur = cur.right;            }        }        return ans;    }\n\n后序遍历后续遍历为 左右中，仔细观察可以发现后序遍历和前序遍历的联系，即前序遍历 中左右，改为 中右左 然后再反转 即为 左右中 即后序遍历，因此只需修改前序遍历代码遍历顺序，然后对遍历结果进行反转即可得到后序遍历\n代码如下：\n// 后序遍历顺序 左-右-中 入栈顺序：中-左-右 出栈顺序：中-右-左， 最后翻转结果class Solution {    public List&lt;Integer&gt; postorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        if (root == null){            return result;        }        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        stack.push(root);        while (!stack.isEmpty()){            TreeNode node = stack.pop();            result.add(node.val);            if (node.left != null){                stack.push(node.left);            }            if (node.right != null){                stack.push(node.right);            }        }        Collections.reverse(result);        return result;    }}\n\n例题如下：LC144.二叉树的前序遍历\nLC145.二叉树的后序遍历\nLC94.二叉树的中序遍历\n二叉树的统一迭代法在实现中序遍历时，有意识到，使用栈进行迭代，无法同时解决访问节点和处理节点不一致得情况\n标记法将访问的节点放入栈中，把要处理的节点也放入栈中，但是做出标记。\n即将要处理的节点放入栈之后，再放入一个空指针作为标记。\n中序遍历代码如下：\nclass Solution {public List&lt;Integer&gt; inorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();    Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();    if (root != null) st.push(root);    while (!st.empty()) {        TreeNode node = st.peek();        if (node != null) {            st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中            if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）            st.push(node);                          // 添加中节点            st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。            if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）        } else { // 只有遇到空节点的时候，才将下一个节点放进结果集            st.pop();           // 将空节点弹出            node = st.peek();    // 重新取出栈中元素            st.pop();            result.add(node.val); // 加入到结果集        }    }    return result;}}\n\n前序遍历class Solution {    public List&lt;Integer&gt; preorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();        if (root != null) st.push(root);        while (!st.empty()) {            TreeNode node = st.peek();            if (node != null) {                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）                st.push(node);                          // 添加中节点                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。            } else { // 只有遇到空节点的时候，才将下一个节点放进结果集                st.pop();           // 将空节点弹出                node = st.peek();    // 重新取出栈中元素                st.pop();                result.add(node.val); // 加入到结果集            }        }        return result;    }}\n\n后序遍历class Solution {   public List&lt;Integer&gt; postorderTraversal(TreeNode root) {        List&lt;Integer&gt; result = new LinkedList&lt;&gt;();        Stack&lt;TreeNode&gt; st = new Stack&lt;&gt;();        if (root != null) st.push(root);        while (!st.empty()) {            TreeNode node = st.peek();            if (node != null) {                st.pop(); // 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中                st.push(node);                          // 添加中节点                st.push(null); // 中节点访问过，但是还没有处理，加入空节点做为标记。                if (node.right!=null) st.push(node.right);  // 添加右节点（空节点不入栈）                if (node.left!=null) st.push(node.left);    // 添加左节点（空节点不入栈）                     } else { // 只有遇到空节点的时候，才将下一个节点放进结果集                st.pop();           // 将空节点弹出                node = st.peek();    // 重新取出栈中元素                st.pop();                result.add(node.val); // 加入到结果集            }        }        return result;   }}\n\n二叉树的层序遍历层序遍历二叉树，即一层一层的去遍历二叉树；\n需要借助一个辅助队列来实现，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。\n而这种层序遍历方式就是图论中的广度优先遍历，只是应用在二叉树上。\n代码如下所示：\n// 102.二叉树的层序遍历class Solution {    public List&lt;List&lt;Integer&gt;&gt; resList = new ArrayList&lt;List&lt;Integer&gt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {        //checkFun01(root,0);        checkFun02(root);        return resList;    }    //DFS--递归方式    public void checkFun01(TreeNode node, Integer deep) {        if (node == null) return;        deep++;        if (resList.size() &lt; deep) {            //当层级增加时，list的Item也增加，利用list的索引值进行层级界定            List&lt;Integer&gt; item = new ArrayList&lt;Integer&gt;();            resList.add(item);        }        resList.get(deep - 1).add(node.val);        checkFun01(node.left, deep);        checkFun01(node.right, deep);    }    //BFS--迭代方式--借助队列    public void checkFun02(TreeNode node) {        if (node == null) return;        Queue&lt;TreeNode&gt; que = new LinkedList&lt;TreeNode&gt;();        que.offer(node);        while (!que.isEmpty()) {            List&lt;Integer&gt; itemList = new ArrayList&lt;Integer&gt;();            int len = que.size();            while (len &gt; 0) {                TreeNode tmpNode = que.poll();                itemList.add(tmpNode.val);                if (tmpNode.left != null) que.offer(tmpNode.left);                if (tmpNode.right != null) que.offer(tmpNode.right);                len--;            }            resList.add(itemList);        }    }}\n\n例题如下LC102.二叉树的层序遍历\nLC107.二叉树的层序遍历II\nLC199.二叉树的右视图\nLC637.二叉树的层平均值\nLC429.N叉树的层序遍历\nLC515.在每个树行中找最大值\nLC116.填充每个节点的下一个右侧节点指针\nLC117.填充每个节点的下一个右侧节点指针II\nLC104.二叉树的最大深度\nLC111.二叉树的最小深度\n翻转二叉树对于该题，只需遍历二叉树的每一个节点，然后将每个节点的左右孩子交换一下即可。\n那么重点在于使用哪一些遍历二叉树的方式，解题之前一定要想清楚是前中后序遍历，还是层序遍历。\n//DFS递归class Solution {   /**     * 前后序遍历都可以     * 中序不行，因为先左孩子交换孩子，再根交换孩子（做完后，右孩子已经变成了原来的左孩子），再右孩子交换孩子（此时其实是对原来的左孩子做交换）     */    public TreeNode invertTree(TreeNode root) {        if (root == null) {            return null;        }        invertTree(root.left);        invertTree(root.right);        swapChildren(root);        return root;    }    private void swapChildren(TreeNode root) {        TreeNode tmp = root.left;        root.left = root.right;        root.right = tmp;    }}//BFSclass Solution {    public TreeNode invertTree(TreeNode root) {        if (root == null) {return null;}        ArrayDeque&lt;TreeNode&gt; deque = new ArrayDeque&lt;&gt;();        deque.offer(root);        while (!deque.isEmpty()) {            int size = deque.size();            while (size-- &gt; 0) {                TreeNode node = deque.poll();                swap(node);                if (node.left != null) deque.offer(node.left);                if (node.right != null) deque.offer(node.right);            }        }        return root;    }    public void swap(TreeNode root) {        TreeNode temp = root.left;        root.left = root.right;        root.right = temp;    }}\n\n对称二叉树首先需要想清楚，判断二叉树要比较的是哪两个节点\n代码如下：\n /**     * 递归法     */    public boolean isSymmetric1(TreeNode root) {        return compare(root.left, root.right);    }    private boolean compare(TreeNode left, TreeNode right) {        if (left == null &amp;&amp; right != null) {            return false;        }        if (left != null &amp;&amp; right == null) {            return false;        }        if (left == null &amp;&amp; right == null) {            return true;        }        if (left.val != right.val) {            return false;        }        // 比较外侧        boolean compareOutside = compare(left.left, right.right);        // 比较内侧        boolean compareInside = compare(left.right, right.left);        return compareOutside &amp;&amp; compareInside;    }    /**     * 迭代法     * 使用双端队列，相当于两个栈     */    public boolean isSymmetric2(TreeNode root) {        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offerFirst(root.left);        deque.offerLast(root.right);        while (!deque.isEmpty()) {            TreeNode leftNode = deque.pollFirst();            TreeNode rightNode = deque.pollLast();            if (leftNode == null &amp;&amp; rightNode == null) {                continue;            }//            if (leftNode == null &amp;&amp; rightNode != null) {//                return false;//            }//            if (leftNode != null &amp;&amp; rightNode == null) {//                return false;//            }//            if (leftNode.val != rightNode.val) {//                return false;//            }            // 以上三个判断条件合并            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {                return false;            }            deque.offerFirst(leftNode.left);            deque.offerFirst(leftNode.right);            deque.offerLast(rightNode.right);            deque.offerLast(rightNode.left);        }        return true;    }    /**     * 迭代法     * 使用普通队列     */    public boolean isSymmetric3(TreeNode root) {        Queue&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offer(root.left);        deque.offer(root.right);        while (!deque.isEmpty()) {            TreeNode leftNode = deque.poll();            TreeNode rightNode = deque.poll();            if (leftNode == null &amp;&amp; rightNode == null) {                continue;            }//            if (leftNode == null &amp;&amp; rightNode != null) {//                return false;//            }//            if (leftNode != null &amp;&amp; rightNode == null) {//                return false;//            }//            if (leftNode.val != rightNode.val) {//                return false;//            }            // 以上三个判断条件合并            if (leftNode == null || rightNode == null || leftNode.val != rightNode.val) {                return false;            }            // 这里顺序与使用Deque不同            deque.offer(leftNode.left);            deque.offer(rightNode.right);            deque.offer(leftNode.right);            deque.offer(rightNode.left);        }        return true;    }\n\n相关题目LC100.相同的树\nLC572.另一棵树的子树\n二叉树的最大深度对于本题可以使用前序(中左右)，或后序遍历(左右中)来求，使用前序遍历求的是深度，使用后序遍历求得是高度。\n\n二叉树节点得深度：指从根节点到该节点得最长简单路径边得条数或者节点数(取决于深度从0开始还是深度从1开始)\n\n二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或节点数(取决于高度从0开始还是从1开始)\n\n\n而 根节点的高度就是二叉树的最大深度， 即对于该题可以通过后序求得根节点高度来求得二叉树最大深度。\n递归法求高度代码如下：\nclass solution {    /**     * 递归法     */    public int maxDepth(TreeNode root) {        if (root == null) {            return 0;        }        int leftDepth = maxDepth(root.left);        int rightDepth = maxDepth(root.right);        return Math.max(leftDepth, rightDepth) + 1;    }}\n\n递归法求深度代码如下：\nclass Solution {  /**   * 递归法(求深度法)   */    //定义最大深度    int maxnum = 0;    public int maxDepth(TreeNode root) {        ans(root,0);        return maxnum;    }    //递归求解最大深度    void ans(TreeNode tr,int tmp){        if(tr==null) return;        tmp++;        maxnum = maxnum&lt;tmp?tmp:maxnum;        ans(tr.left,tmp);        ans(tr.right,tmp);        tmp--;    }}\n\n层序遍历迭代代码如下：\nclass solution {    /**     * 迭代法，使用层序遍历     */    public int maxDepth(TreeNode root) {        if(root == null) {            return 0;        }        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offer(root);        int depth = 0;        while (!deque.isEmpty()) {            int size = deque.size();            depth++;            for (int i = 0; i &lt; size; i++) {                TreeNode node = deque.poll();                if (node.left != null) {                    deque.offer(node.left);                }                if (node.right != null) {                    deque.offer(node.right);                }            }        }        return depth;    }}\n\n相关题目推荐LC559.N叉树得最大深度\n二叉树的最小深度后序遍历求高度class Solution {    /**     * 递归法，相比求MaxDepth要复杂点     * 因为最小深度是从根节点到最近**叶子节点**的最短路径上的节点数量     * 所以使用后序遍历求根节点的最小高度     */    public int minDepth(TreeNode root) {        if (root == null) {            return 0;        }        int leftDepth = minDepth(root.left);        int rightDepth = minDepth(root.right);        if (root.left == null) {            return rightDepth + 1;        }        if (root.right == null) {            return leftDepth + 1;        }        // 左右结点都不为null        return Math.min(leftDepth, rightDepth) + 1;    }}\n\n前序遍历求深度class Solution {    /**     * 递归法（思路来自二叉树最大深度的递归法）     * 该题求最小深度，最小深度为根节点到叶子节点的深度，所以在迭代到每个叶子节点时更新最小值。     */    int depth = 0;    // 定义最小深度，初始化最大值    int minDepth = Integer.MAX_VALUE;    public int minDepth(TreeNode root) {        dep(root);        return minDepth == Integer.MAX_VALUE ? 0 : minDepth;    }    void dep(TreeNode root){        if(root == null) return ;        // 递归开始，深度增加        depth++;        dep(root.left);        dep(root.right);        // 该位置表示递归到叶子节点了，需要更新最小深度minDepth        if(root.left == null &amp;&amp; root.right == null)            minDepth = Math.min(minDepth , depth);        // 递归结束，深度减小        depth--;    }}\n\n迭代法class Solution {   /**     * 迭代法，层序遍历     */    public int minDepth(TreeNode root) {        if (root == null) {            return 0;        }        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offer(root);        int depth = 0;        while (!deque.isEmpty()) {            int size = deque.size();            depth++;            for (int i = 0; i &lt; size; i++) {                TreeNode poll = deque.poll();                if (poll.left == null &amp;&amp; poll.right == null) {                    // 是叶子结点，直接返回depth，因为从上往下遍历，所以该值就是最小值                    return depth;                }                if (poll.left != null) {                    deque.offer(poll.left);                }                if (poll.right != null) {                    deque.offer(poll.right);                }            }        }        return depth;    }}\n\n完全二叉树的节点个数后序遍历递归对于普通二叉树，使用递归后序遍历记录节点数量即可。\n代码如下：\nclass Solution {    public int countNodes(TreeNode root) {        return getCountNodes(root);    }    // 后序遍历记录二叉树节点数目    private int getCountNodes(TreeNode node) {        if (node == null)             return 0;        // 后序遍历 左 右 中        return getCountNodes(node.left) + getCountNodes(node.right) + 1;    }}\n\n完全二叉树特性+后序遍历递归在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最后一层节点都集中在该层最左边位置，即若最底层为第h层，则该层节点数范围为\n那么对于完全二叉树，容易发现，一定存在有左子树或右子树为 满二叉树的情况，对于满二叉树，假设层数为x，则节点数可以直接计算得出为。\n因此可以在后序遍历二叉树的过程中，判断某子树是否为满二叉树，若为满二叉树则直接通过公式返回其节点数即可，省略了部分二叉树节点的遍历操作。\n同时在完全二叉树的基础上，判断某子树是否为满二叉树，只需判断该子树；向左遍历的深度与向右遍历的深度是否相等即可。若相等则为满二叉树。\n 实现代码如下：\nclass Solution {    public int countNodes(TreeNode root) {        return getCountNodes(root);    }    // 后序遍历记录二叉树节点数目    private int getCountNodes(TreeNode node) {        if (node == null)             return 0;        // 对该子树是否为满二叉树进行判断        int leftDepth = 0;        int rightDepth = 0;        TreeNode left = node.left;        TreeNode right = node.right;        while (left != null) {  // 计算子树左支深度 0开始计算            ++ leftDepth;            left = left.left;        }        while (right != null) { // 计算子树右支深度 0开始计算            ++ rightDepth;            right = right.right;        }        if (leftDepth == rightDepth) {  // 若为满二叉树 则直接返回其总节点数            return ((2 &lt;&lt; leftDepth) - 1);        }        // 后序遍历 左 右 中        return getCountNodes(node.left) + getCountNodes(node.right) + 1;    }}\n\n\n时间复杂度：O(log n × log n)\n空间复杂度：O(log n）\n\n平衡二叉树此处需要使用后序遍历求二叉树节点的高度；即指从节点到叶子节点的最长简单路径边的条数。\n代码如下\nclass Solution {   /**     * 递归法     */    public boolean isBalanced(TreeNode root) {        return getHeight(root) != -1;    }    private int getHeight(TreeNode root) {        if (root == null) {            return 0;        }        int leftHeight = getHeight(root.left);        if (leftHeight == -1) {            return -1;        }        int rightHeight = getHeight(root.right);        if (rightHeight == -1) {            return -1;        }        // 左右子树高度差大于1，return -1表示已经不是平衡树了        if (Math.abs(leftHeight - rightHeight) &gt; 1) {            return -1;        }        return Math.max(leftHeight, rightHeight) + 1;    }}class Solution {   /**     * 迭代法，效率较低，计算高度时会重复遍历     * 时间复杂度：O(n^2)     */    public boolean isBalanced(TreeNode root) {        if (root == null) {            return true;        }        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode pre = null;        while (root!= null || !stack.isEmpty()) {            while (root != null) {                stack.push(root);                root = root.left;            }            TreeNode inNode = stack.peek();            // 右结点为null或已经遍历过            if (inNode.right == null || inNode.right == pre) {                // 比较左右子树的高度差，输出                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) &gt; 1) {                    return false;                }                stack.pop();                pre = inNode;                root = null;// 当前结点下，没有要遍历的结点了            } else {                root = inNode.right;// 右结点还没遍历，遍历右结点            }        }        return true;    }    /**     * 层序遍历，求结点的高度     */    public int getHeight(TreeNode root) {        if (root == null) {            return 0;        }        Deque&lt;TreeNode&gt; deque = new LinkedList&lt;&gt;();        deque.offer(root);        int depth = 0;        while (!deque.isEmpty()) {            int size = deque.size();            depth++;            for (int i = 0; i &lt; size; i++) {                TreeNode poll = deque.poll();                if (poll.left != null) {                    deque.offer(poll.left);                }                if (poll.right != null) {                    deque.offer(poll.right);                }            }        } return depth;    }}class Solution {   /**     * 优化迭代法，针对暴力迭代法的getHeight方法做优化，利用TreeNode.val来保存当前结点的高度，这样就不会有重复遍历     * 获取高度算法时间复杂度可以降到O(1)，总的时间复杂度降为O(n)。     * 时间复杂度：O(n)     */    public boolean isBalanced(TreeNode root) {        if (root == null) {            return true;        }        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode pre = null;        while (root != null || !stack.isEmpty()) {            while (root != null) {                stack.push(root);                root = root.left;            }            TreeNode inNode = stack.peek();            // 右结点为null或已经遍历过            if (inNode.right == null || inNode.right == pre) {                // 输出                if (Math.abs(getHeight(inNode.left) - getHeight(inNode.right)) &gt; 1) {                    return false;                }                stack.pop();                pre = inNode;                root = null;// 当前结点下，没有要遍历的结点了            } else {                root = inNode.right;// 右结点还没遍历，遍历右结点            }        }        return true;    }    /**     * 求结点的高度     */    public int getHeight(TreeNode root) {        if (root == null) {            return 0;        }        int leftHeight = root.left != null ? root.left.val : 0;        int rightHeight = root.right != null ? root.right.val : 0;        int height = Math.max(leftHeight, rightHeight) + 1;        root.val = height;// 用TreeNode.val来保存当前结点的高度        return height;    }}\n\n二叉树的所有路径本题不但用了递归还使用了回溯。\n递归法  //解法一//方式一class Solution {    /**     * 递归法     */    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        List&lt;String&gt; res = new ArrayList&lt;&gt;();// 存最终的结果        if (root == null) {            return res;        }        List&lt;Integer&gt; paths = new ArrayList&lt;&gt;();// 作为结果中的路径        traversal(root, paths, res);        return res;    }    private void traversal(TreeNode root, List&lt;Integer&gt; paths, List&lt;String&gt; res) {        paths.add(root.val);// 前序遍历，中        // 遇到叶子结点        if (root.left == null &amp;&amp; root.right == null) {            // 输出            StringBuilder sb = new StringBuilder();// StringBuilder用来拼接字符串，速度更快            for (int i = 0; i &lt; paths.size() - 1; i++) {                sb.append(paths.get(i)).append(\"-&gt;\");            }            sb.append(paths.get(paths.size() - 1));// 记录最后一个节点            res.add(sb.toString());// 收集一个路径            return;        }        // 递归和回溯是同时进行，所以要放在同一个花括号里        if (root.left != null) { // 左            traversal(root.left, paths, res);            paths.remove(paths.size() - 1);// 回溯        }        if (root.right != null) { // 右            traversal(root.right, paths, res);            paths.remove(paths.size() - 1);// 回溯        }    }}//方式二class Solution {    List&lt;String&gt; result = new ArrayList&lt;&gt;();    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        deal(root, \"\");        return result;    }    public void deal(TreeNode node, String s) {        if (node == null)            return;        if (node.left == null &amp;&amp; node.right == null) {            result.add(new StringBuilder(s).append(node.val).toString());            return;        }        String tmp = new StringBuilder(s).append(node.val).append(\"-&gt;\").toString();        deal(node.left, tmp);        deal(node.right, tmp);\n\n迭代法// 解法二class Solution {    /**     * 迭代法     */    public List&lt;String&gt; binaryTreePaths(TreeNode root) {        List&lt;String&gt; result = new ArrayList&lt;&gt;();        if (root == null)            return result;        Stack&lt;Object&gt; stack = new Stack&lt;&gt;();        // 节点和路径同时入栈        stack.push(root);        stack.push(root.val + \"\");        while (!stack.isEmpty()) {            // 节点和路径同时出栈            String path = (String) stack.pop();            TreeNode node = (TreeNode) stack.pop();            // 若找到叶子节点            if (node.left == null &amp;&amp; node.right == null) {                result.add(path);            }            //右子节点不为空            if (node.right != null) {                stack.push(node.right);                stack.push(path + \"-&gt;\" + node.right.val);            }            //左子节点不为空            if (node.left != null) {                stack.push(node.left);                stack.push(path + \"-&gt;\" + node.left.val);            }        }        return result;    }}\n\n左叶子之和递归class Solution {    public int sumOfLeftLeaves(TreeNode root) {        if (root == null) return 0;        int leftValue = sumOfLeftLeaves(root.left);    // 左        int rightValue = sumOfLeftLeaves(root.right);  // 右        int midValue = 0;        if (root.left != null &amp;&amp; root.left.left == null &amp;&amp; root.left.right == null) {             midValue = root.left.val;        }        int sum = midValue + leftValue + rightValue;  // 中        return sum;    }}\n\n迭代class Solution {    public int sumOfLeftLeaves(TreeNode root) {        if (root == null) return 0;        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt; ();        stack.add(root);        int result = 0;        while (!stack.isEmpty()) {            TreeNode node = stack.pop();            if (node.left != null &amp;&amp; node.left.left == null &amp;&amp; node.left.right == null) {                result += node.left.val;            }            if (node.right != null) stack.add(node.right);            if (node.left != null) stack.add(node.left);        }        return result;    }}\n\n层序遍历迭代// 层序遍历迭代法class Solution {    public int sumOfLeftLeaves(TreeNode root) {        int sum = 0;        if (root == null) return 0;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        while (!queue.isEmpty()) {            int size = queue.size();            while (size -- &gt; 0) {                TreeNode node = queue.poll();                if (node.left != null) { // 左节点不为空                    queue.offer(node.left);                    if (node.left.left == null &amp;&amp; node.left.right == null){ // 左叶子节点                        sum += node.left.val;                    }                }                if (node.right != null) queue.offer(node.right);            }        }        return sum;    }}\n\n找树左下角的值递归// 递归法class Solution {    private int Deep = -1;    private int value = 0;    public int findBottomLeftValue(TreeNode root) {        value = root.val;        findLeftValue(root,0);        return value;    }    private void findLeftValue (TreeNode root,int deep) {        if (root == null) return;        if (root.left == null &amp;&amp; root.right == null) {            if (deep &gt; Deep) {                value = root.val;                Deep = deep;            }        }        if (root.left != null) findLeftValue(root.left,deep + 1);        if (root.right != null) findLeftValue(root.right,deep + 1);    }}\n\n迭代//迭代法class Solution {    public int findBottomLeftValue(TreeNode root) {        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root);        int res = 0;        while (!queue.isEmpty()) {            int size = queue.size();            for (int i = 0; i &lt; size; i++) {                TreeNode poll = queue.poll();                if (i == 0) {                    res = poll.val;                }                if (poll.left != null) {                    queue.offer(poll.left);                }                if (poll.right != null) {                    queue.offer(poll.right);                }            }        }        return res;    }}\n\n路径总和递归class solution {   public boolean haspathsum(treenode root, int targetsum) {        if (root == null) {            return false;        }        targetsum -= root.val;        // 叶子结点        if (root.left == null &amp;&amp; root.right == null) {            return targetsum == 0;        }        if (root.left != null) {            boolean left = haspathsum(root.left, targetsum);            if (left) {      // 已经找到                return true;            }        }        if (root.right != null) {            boolean right = haspathsum(root.right, targetsum);            if (right) {     // 已经找到                return true;            }        }        return false;    }}// lc112 简洁方法class solution {    public boolean haspathsum(treenode root, int targetsum) {        if (root == null) return false; // 为空退出        // 叶子节点判断是否符合        if (root.left == null &amp;&amp; root.right == null) return root.val == targetsum;        // 求两侧分支的路径和        return haspathsum(root.left, targetsum - root.val) || haspathsum(root.right, targetsum - root.val);    }}\n\n迭代class solution {    public boolean haspathsum(treenode root, int targetsum) {        if(root == null) return false;        stack&lt;treenode&gt; stack1 = new stack&lt;&gt;();        stack&lt;integer&gt; stack2 = new stack&lt;&gt;();        stack1.push(root);        stack2.push(root.val);        while(!stack1.isempty()) {            int size = stack1.size();            for(int i = 0; i &lt; size; i++) {                treenode node = stack1.pop();                int sum = stack2.pop();                // 如果该节点是叶子节点了，同时该节点的路径数值等于sum，那么就返回true                if(node.left == null &amp;&amp; node.right == null &amp;&amp; sum == targetsum) {                    return true;                }                // 右节点，压进去一个节点的时候，将该节点的路径数值也记录下来                if(node.right != null){                    stack1.push(node.right);                    stack2.push(sum + node.right.val);                }                // 左节点，压进去一个节点的时候，将该节点的路径数值也记录下来                if(node.left != null) {                    stack1.push(node.left);                    stack2.push(sum + node.left.val);                }            }        }        return false;    }}\n\n相关题目推荐路径总和 II\n从中序与后序遍历序列构造二叉树递归class Solution {    Map&lt;Integer, Integer&gt; map;  // 方便根据数值查找位置    public TreeNode buildTree(int[] inorder, int[] postorder) {        map = new HashMap&lt;&gt;();        for (int i = 0; i &lt; inorder.length; i++) { // 用map保存中序序列的数值对应位置            map.put(inorder[i], i);        }        return findNode(inorder,  0, inorder.length, postorder,0, postorder.length);  // 前闭后开    }    public TreeNode findNode(int[] inorder, int inBegin, int inEnd, int[] postorder, int postBegin, int postEnd) {        // 参数里的范围都是前闭后开        if (inBegin &gt;= inEnd || postBegin &gt;= postEnd) {  // 不满足左闭右开，说明没有元素，返回空树            return null;        }        int rootIndex = map.get(postorder[postEnd - 1]);  // 找到后序遍历的最后一个元素在中序遍历中的位置        TreeNode root = new TreeNode(inorder[rootIndex]);  // 构造结点        int lenOfLeft = rootIndex - inBegin;  // 保存中序左子树个数，用来确定后序数列的个数        root.left = findNode(inorder, inBegin, rootIndex,                            postorder, postBegin, postBegin + lenOfLeft);        root.right = findNode(inorder, rootIndex + 1, inEnd,                            postorder, postBegin + lenOfLeft, postEnd - 1);        return root;    }}\n\n相关题目推荐LC105.从前序与中序遍历序列构造二叉树\n最大二叉树递归class Solution {    public TreeNode constructMaximumBinaryTree(int[] nums) {        return constructMaximumBinaryTree1(nums, 0, nums.length);    }    public TreeNode constructMaximumBinaryTree1(int[] nums, int leftIndex, int rightIndex) {        if (rightIndex - leftIndex &lt; 1) {// 没有元素了            return null;        }        if (rightIndex - leftIndex == 1) {// 只有一个元素            return new TreeNode(nums[leftIndex]);        }        int maxIndex = leftIndex;// 最大值所在位置        int maxVal = nums[maxIndex];// 最大值        for (int i = leftIndex + 1; i &lt; rightIndex; i++) {            if (nums[i] &gt; maxVal){                maxVal = nums[i];                maxIndex = i;            }        }        TreeNode root = new TreeNode(maxVal);        // 根据maxIndex划分左右子树        root.left = constructMaximumBinaryTree1(nums, leftIndex, maxIndex);        root.right = constructMaximumBinaryTree1(nums, maxIndex + 1, rightIndex);        return root;    }}\n\n总结类似用数组构造二叉树的题目，每次分割数组时，尽量不定义新的数组，而是通过下标索引的方式直接在原数组上操作，这样可以节约空间和时间的开销。\n合并二叉树递归递归三部曲：\n\n递归的参数和返回值\n递归的边界条件\n递归的一般过程\n\nclass Solution {    // 递归    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {        if (root1 == null) return root2;        if (root2 == null) return root1;        root1.val += root2.val;        root1.left = mergeTrees(root1.left,root2.left);        root1.right = mergeTrees(root1.right,root2.right);        return root1;    }}\n\n栈 + 迭代class Solution {    // 使用栈迭代    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {        if (root1 == null) {            return root2;        }        if (root2 == null) {            return root1;        }        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        stack.push(root2);        stack.push(root1);        while (!stack.isEmpty()) {            TreeNode node1 = stack.pop();            TreeNode node2 = stack.pop();            node1.val += node2.val;            if (node2.right != null &amp;&amp; node1.right != null) {                stack.push(node2.right);                stack.push(node1.right);            } else {                if (node1.right == null) {                    node1.right = node2.right;                }            }            if (node2.left != null &amp;&amp; node1.left != null) {                stack.push(node2.left);                stack.push(node1.left);            } else {                if (node1.left == null) {                    node1.left = node2.left;                }            }        }        return root1;    }}\n\n队列 + 迭代class Solution {    // 使用队列迭代    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {        if (root1 == null) return root2;        if (root2 ==null) return root1;        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();        queue.offer(root1);        queue.offer(root2);        while (!queue.isEmpty()) {            TreeNode node1 = queue.poll();            TreeNode node2 = queue.poll();            // 此时两个节点一定不为空，val相加            node1.val = node1.val + node2.val;            // 如果两棵树左节点都不为空，加入队列            if (node1.left != null &amp;&amp; node2.left != null) {                queue.offer(node1.left);                queue.offer(node2.left);            }            // 如果两棵树右节点都不为空，加入队列            if (node1.right != null &amp;&amp; node2.right != null) {                queue.offer(node1.right);                queue.offer(node2.right);            }            // 若node1的左节点为空，直接赋值            if (node1.left == null &amp;&amp; node2.left != null) {                node1.left = node2.left;            }            // 若node1的右节点为空，直接赋值            if (node1.right == null &amp;&amp; node2.right != null) {                node1.right = node2.right;            }        }        return root1;    }}\n\n二叉搜索树中的搜索二叉搜索树是一个有序树：\n\n若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n它的左、右子树也分别为二叉搜索树\n\n递归class Solution {    // 递归，普通二叉树    public TreeNode searchBST(TreeNode root, int val) {        if (root == null || root.val == val) {            return root;        }        TreeNode left = searchBST(root.left, val);        if (left != null) {            return left;        }        return searchBST(root.right, val);    }}class Solution {    // 递归，利用二叉搜索树特点，优化    public TreeNode searchBST(TreeNode root, int val) {        if (root == null || root.val == val) {            return root;        }        if (val &lt; root.val) {            return searchBST(root.left, val);        } else {            return searchBST(root.right, val);        }    }}\n\n迭代class Solution {    // 迭代，普通二叉树    public TreeNode searchBST(TreeNode root, int val) {        if (root == null || root.val == val) {            return root;        }        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        stack.push(root);        while (!stack.isEmpty()) {            TreeNode pop = stack.pop();            if (pop.val == val) {                return pop;            }            if (pop.right != null) {                stack.push(pop.right);            }            if (pop.left != null) {                stack.push(pop.left);            }        }        return null;    }}class Solution {    // 迭代，利用二叉搜索树特点，优化，可以不需要栈    public TreeNode searchBST(TreeNode root, int val) {        while (root != null)            if (val &lt; root.val) root = root.left;            else if (val &gt; root.val) root = root.right;            else return root;        return null;    }}\n\n验证二叉搜索树在中序遍历二叉搜索树的情况下，所得遍历序列是一个递增的序列，利用这个特点，便将检验二叉搜索树转化为，判断遍历序列是否递增的问题。\n统一迭代法//使用統一迭代法class Solution {    public boolean isValidBST(TreeNode root) {        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode pre = null;        if(root != null)            stack.add(root);                while(!stack.isEmpty()){            TreeNode curr = stack.peek();            if(curr != null){                stack.pop();                if(curr.right != null)                    stack.add(curr.right);                stack.add(curr);                stack.add(null);                if(curr.left != null)                    stack.add(curr.left);            }else{                stack.pop();                TreeNode temp = stack.pop();                if(pre != null &amp;&amp; pre.val &gt;= temp.val)                    return false;                pre = temp;            }        }        return true;    }}\n\n递归class Solution {    // 递归    TreeNode max;    public boolean isValidBST(TreeNode root) {        if (root == null) {            return true;        }        // 左        boolean left = isValidBST(root.left);        if (!left) {            return false;        }        // 中        if (max != null &amp;&amp; root.val &lt;= max.val) {            return false;        }        max = root;        // 右        boolean right = isValidBST(root.right);        return right;    }}// 简洁实现·递归解法class Solution {    public boolean isValidBST(TreeNode root) {        return validBST(Long.MIN_VALUE, Long.MAX_VALUE, root);    }    boolean validBST(long lower, long upper, TreeNode root) {        if (root == null) return true;        if (root.val &lt;= lower || root.val &gt;= upper) return false;        return validBST(lower, root.val, root.left) &amp;&amp; validBST(root.val, upper, root.right);    }}// 简洁实现·中序遍历class Solution {    private long prev = Long.MIN_VALUE;    public boolean isValidBST(TreeNode root) {        if (root == null) {            return true;        }        if (!isValidBST(root.left)) {            return false;        }        if (root.val &lt;= prev) { // 不满足二叉搜索树条件            return false;        }        prev = root.val;        return isValidBST(root.right);    }}\n\n迭代class Solution {    // 迭代    public boolean isValidBST(TreeNode root) {        if (root == null) {            return true;        }        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode pre = null;        while (root != null || !stack.isEmpty()) {            while (root != null) {                stack.push(root);                root = root.left;// 左            }            // 中，处理            TreeNode pop = stack.pop();            if (pre != null &amp;&amp; pop.val &lt;= pre.val) {                return false;            }            pre = pop;            root = pop.right;// 右        }        return true;    }}\n\n二叉搜索树的最小绝对差当遇到二叉搜索树时，应该意识到，可以使用二叉树的中序遍历将其转化为一个有序递增数组，即求最小绝对差问题可以转化为求一个有序递增数组的最小绝对差问题。\n递归class Solution {    TreeNode pre;// 记录上一个遍历的结点    int result = Integer.MAX_VALUE;    public int getMinimumDifference(TreeNode root) {       if(root==null)return 0;       traversal(root);       return result;    }    public void traversal(TreeNode root){        if(root==null)return;        //左        traversal(root.left);        //中        if(pre!=null){            result = Math.min(result,root.val-pre.val);        }        pre = root;        //右        traversal(root.right);    }}\n\n统一迭代+中序class Solution {    public int getMinimumDifference(TreeNode root) {        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        TreeNode pre = null;        int result = Integer.MAX_VALUE;        if(root != null)            stack.add(root);        while(!stack.isEmpty()){            TreeNode curr = stack.peek();            if(curr != null){                stack.pop();                if(curr.right != null)                    stack.add(curr.right);                stack.add(curr);                stack.add(null);                if(curr.left != null)                    stack.add(curr.left);            }else{                stack.pop();                TreeNode temp = stack.pop();                if(pre != null)                    result = Math.min(result, temp.val - pre.val);                pre = temp;            }        }        return result;    }}\n\n迭代+中序class Solution {    TreeNode pre;    Stack&lt;TreeNode&gt; stack;    public int getMinimumDifference(TreeNode root) {        if (root == null) return 0;        stack = new Stack&lt;&gt;();        TreeNode cur = root;        int result = Integer.MAX_VALUE;        while (cur != null || !stack.isEmpty()) {            if (cur != null) {                stack.push(cur); // 将访问的节点放进栈                cur = cur.left; // 左            }else {                cur = stack.pop();                 if (pre != null) { // 中                    result = Math.min(result, cur.val - pre.val);                }                pre = cur;                cur = cur.right; // 右            }        }        return result;    }}\n\n总结当遇到二叉搜索树时，都要思考二叉搜索树是有序的，要利用好该特点。\n同时学会在递归遍历的过程中如何记录前后两个指针。\n二叉搜索树中的众数利用中序遍历二叉搜索树所得序列有序的特点来求解。\n递归class Solution {    ArrayList&lt;Integer&gt; resList;    int maxCount;    int count;    TreeNode pre;    public int[] findMode(TreeNode root) {        resList = new ArrayList&lt;&gt;();        maxCount = 0;        count = 0;        pre = null;        findMode1(root);        int[] res = new int[resList.size()];        for (int i = 0; i &lt; resList.size(); i++) {            res[i] = resList.get(i);        }        return res;    }    public void findMode1(TreeNode root) {        if (root == null) {            return;        }        findMode1(root.left);        int rootValue = root.val;        // 计数        if (pre == null || rootValue != pre.val) {            count = 1;        } else {            count++;        }        // 更新结果以及maxCount        if (count &gt; maxCount) {            resList.clear();            resList.add(rootValue);            maxCount = count;        } else if (count == maxCount) {            resList.add(rootValue);        }        pre = root;        findMode1(root.right);    }}\n\n迭代法class Solution {    public int[] findMode(TreeNode root) {        TreeNode pre = null;        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();        int maxCount = 0;        int count = 0;        TreeNode cur = root;        while (cur != null || !stack.isEmpty()) {            if (cur != null) {                stack.push(cur);                cur =cur.left;            }else {                cur = stack.pop();                // 计数                if (pre == null || cur.val != pre.val) {                    count = 1;                }else {                    count++;                }                // 更新结果                if (count &gt; maxCount) {                    maxCount = count;                    result.clear();                    result.add(cur.val);                }else if (count == maxCount) {                    result.add(cur.val);                }                pre = cur;                cur = cur.right;            }        }        return result.stream().mapToInt(Integer::intValue).toArray();    }}\n\n统一迭代法class Solution {    public int[] findMode(TreeNode root) {        int count = 0;        int maxCount = 0;        TreeNode pre = null;        LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        if(root != null)            stack.add(root);                while(!stack.isEmpty()){            TreeNode curr = stack.peek();            if(curr != null){                stack.pop();                if(curr.right != null)                    stack.add(curr.right);                stack.add(curr);                stack.add(null);                if(curr.left != null)                    stack.add(curr.left);            }else{                stack.pop();                TreeNode temp = stack.pop();                if(pre == null)                    count = 1;                else if(pre != null &amp;&amp; pre.val == temp.val)                    count++;                else                    count = 1;                pre = temp;                if(count == maxCount)                    res.add(temp.val);                if(count &gt; maxCount){                    maxCount = count;                    res.clear();                    res.add(temp.val);                }            }        }        int[] result = new int[res.size()];        int i = 0;        for (int x : res){            result[i] = x;            i++;        }        return result;        }}\n\n暴力普通二叉树通用class Solution {    public int[] findMode(TreeNode root) {        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        if (root == null) return list.stream().mapToInt(Integer::intValue).toArray();        // 获得频率 Map        searchBST(root, map);        List&lt;Map.Entry&lt;Integer, Integer&gt;&gt; mapList = map.entrySet().stream()                .sorted((c1, c2) -&gt; c2.getValue().compareTo(c1.getValue()))                .collect(Collectors.toList());        list.add(mapList.get(0).getKey());        // 把频率最高的加入 list        for (int i = 1; i &lt; mapList.size(); i++) {            if (mapList.get(i).getValue() == mapList.get(i - 1).getValue()) {                list.add(mapList.get(i).getKey());            } else {                break;            }        }        return list.stream().mapToInt(Integer::intValue).toArray();    }    void searchBST(TreeNode curr, Map&lt;Integer, Integer&gt; map) {        if (curr == null) return;        map.put(curr.val, map.getOrDefault(curr.val, 0) + 1);        searchBST(curr.left, map);        searchBST(curr.right, map);    }}\n\n二叉树的最近公共祖先主要有两种情况：\n\n节点p和节点q位于两侧\n节点p和节点q位于一侧，即节点p或q为最近公共祖先\n\n对于该题，使用递归后序遍历的方式进行求解，详细思路\n注意：对于递归函数有返回值的情况下，需要通过回溯，一层一层将返回结果从下往上传递。\n实现代码如下：\nclass Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if (root == null || root == p || root == q) { // 递归结束条件            return root;        }        // 后序遍历        TreeNode left = lowestCommonAncestor(root.left, p, q);        TreeNode right = lowestCommonAncestor(root.right, p, q);        if(left == null &amp;&amp; right == null) { // 若未找到节点 p 或 q            return null;        }else if(left == null &amp;&amp; right != null) { // 若找到一个节点            return right;        }else if(left != null &amp;&amp; right == null) { // 若找到一个节点            return left;        }else { // 若找到两个节点            return root;        }    }}\n\n二叉搜索树的最近公共祖先递归法class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) return lowestCommonAncestor(root.left, p, q);        if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) return lowestCommonAncestor(root.right, p, q);        return root;    }}\n\n迭代法class Solution {    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {        while (true) {            if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val) {                root = root.left;            } else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val) {                root = root.right;            } else {                break;            }        }        return root;    }}\n701. 二叉搜索树中的插入操作迭代class Solution {    public TreeNode insertIntoBST(TreeNode root, int val) {        if (root == null) return new TreeNode(val);        TreeNode newRoot = root;        TreeNode pre = root;        while (root != null) {            pre = root;            if (root.val &gt; val) {                root = root.left;            } else if (root.val &lt; val) {                root = root.right;            }         }        if (pre.val &gt; val) {            pre.left = new TreeNode(val);        } else {            pre.right = new TreeNode(val);        }        return newRoot;    }}\n\n递归class Solution {    public TreeNode insertIntoBST(TreeNode root, int val) {        if (root == null) // 如果当前节点为空，也就意味着val找到了合适的位置，此时创建节点直接返回。            return new TreeNode(val);                    if (root.val &lt; val){            root.right = insertIntoBST(root.right, val); // 递归创建右子树        }else if (root.val &gt; val){            root.left = insertIntoBST(root.left, val); // 递归创建左子树        }        return root;    }}\n\n删除二叉搜索树中的节点迭代class Solution {  public TreeNode deleteNode(TreeNode root, int key) {    if (root == null){      return null;    }    //寻找对应的对应的前面的节点，以及他的前一个节点    TreeNode cur = root;    TreeNode pre = null;    while (cur != null){      if (cur.val &lt; key){        pre = cur;        cur = cur.right;      } else if (cur.val &gt; key) {        pre = cur;        cur = cur.left;      }else {        break;      }    }    if (pre == null){      return deleteOneNode(cur);    }    if (pre.left !=null &amp;&amp; pre.left.val == key){      pre.left = deleteOneNode(cur);    }    if (pre.right !=null &amp;&amp; pre.right.val == key){      pre.right = deleteOneNode(cur);    }    return root;  }  public TreeNode deleteOneNode(TreeNode node){    if (node == null){      return null;    }    if (node.right == null){      return node.left;    }    TreeNode cur = node.right;    while (cur.left !=null){      cur = cur.left;    }    cur.left = node.left;    return node.right;  }}\n\n递归(不考虑优化树结构)// 解法1(最好理解的版本)class Solution {  public TreeNode deleteNode(TreeNode root, int key) {    if (root == null) return root;    if (root.val == key) {      if (root.left == null) {        return root.right;      } else if (root.right == null) {        return root.left;      } else {        TreeNode cur = root.right;        while (cur.left != null) {          cur = cur.left;        }        cur.left = root.left;        root = root.right;        return root;      }    }    if (root.val &gt; key) root.left = deleteNode(root.left, key);    if (root.val &lt; key) root.right = deleteNode(root.right, key);    return root;  }}\n\n递归(考虑优化树结构)class Solution {    public TreeNode deleteNode(TreeNode root, int key) {        root = delete(root,key);        return root;    }    private TreeNode delete(TreeNode root, int key) {        if (root == null) return null;        if (root.val &gt; key) {            root.left = delete(root.left,key);        } else if (root.val &lt; key) {            root.right = delete(root.right,key);        } else {            if (root.left == null) return root.right;            if (root.right == null) return root.left;            TreeNode tmp = root.right;            while (tmp.left != null) {                tmp = tmp.left;            }            root.val = tmp.val;            root.right = delete(root.right,tmp.val);        }        return root;    }}\n\n修剪二叉搜索树递归法class Solution {    public TreeNode trimBST(TreeNode root, int low, int high) {        if (root == null) {            return null;        }        if (root.val &lt; low) {            return trimBST(root.right, low, high);        }        if (root.val &gt; high) {            return trimBST(root.left, low, high);        }        // root在[low,high]范围内        root.left = trimBST(root.left, low, high);        root.right = trimBST(root.right, low, high);        return root;    }}\n\n迭代法因为二叉搜索树的有序性，不需要使用栈模拟递归的过程。\n在剪枝的时候，可以分为三步：\n\n将root移动到[L, R] 范围内，注意是左闭右闭区间\n剪枝左子树\n剪枝右子树\n\nclass Solution {    //iteration    public TreeNode trimBST(TreeNode root, int low, int high) {        if(root == null)            return null;        while(root != null &amp;&amp; (root.val &lt; low || root.val &gt; high)){            if(root.val &lt; low)                root = root.right;            else                root = root.left;        }        TreeNode curr = root;                //deal with root's left sub-tree, and deal with the value smaller than low.        while(curr != null){            while(curr.left != null &amp;&amp; curr.left.val &lt; low){                curr.left = curr.left.right;            }            curr = curr.left;        }        //go back to root;        curr = root;        //deal with root's righg sub-tree, and deal with the value bigger than high.        while(curr != null){            while(curr.right != null &amp;&amp; curr.right.val &gt; high){                curr.right = curr.right.left;            }            curr = curr.right;        }        return root;    }}\n将有序数组转换为二叉搜索树解决该题，本质就是寻找分割点，将分割点作为当前节点，然后递归左区间和右区间\n递归(左闭右开)class Solution {    public TreeNode sortedArrayToBST(int[] nums) {        return sortedArrayToBST(nums, 0, nums.length);    }        public TreeNode sortedArrayToBST(int[] nums, int left, int right) {        if (left &gt;= right) {            return null;        }        if (right - left == 1) {            return new TreeNode(nums[left]);        }        int mid = left + (right - left) / 2;        TreeNode root = new TreeNode(nums[mid]);        root.left = sortedArrayToBST(nums, left, mid);        root.right = sortedArrayToBST(nums, mid + 1, right);        return root;    }}\n\n递归(左闭右闭)class Solution {    public TreeNode sortedArrayToBST(int[] nums) {        TreeNode root = traversal(nums, 0, nums.length - 1);        return root;    }    // 左闭右闭区间[left, right]    private TreeNode traversal(int[] nums, int left, int right) {        if (left &gt; right) return null;        int mid = left + ((right - left) &gt;&gt; 1);        TreeNode root = new TreeNode(nums[mid]);        root.left = traversal(nums, left, mid - 1);        root.right = traversal(nums, mid + 1, right);        return root;    }}\n\n迭代(左闭右闭)class Solution {    public TreeNode sortedArrayToBST(int[] nums) {        if (nums.length == 0) return null;        //根节点初始化        TreeNode root = new TreeNode(-1);        Queue&lt;TreeNode&gt; nodeQueue = new LinkedList&lt;&gt;();        Queue&lt;Integer&gt; leftQueue = new LinkedList&lt;&gt;();        Queue&lt;Integer&gt; rightQueue = new LinkedList&lt;&gt;();        // 根节点入队列        nodeQueue.offer(root);        // 0为左区间下标初始位置        leftQueue.offer(0);        // nums.size() - 1为右区间下标初始位置        rightQueue.offer(nums.length - 1);        while (!nodeQueue.isEmpty()) {            TreeNode currNode = nodeQueue.poll();            int left = leftQueue.poll();            int right = rightQueue.poll();            int mid = left + ((right - left) &gt;&gt; 1);            // 将mid对应的元素给中间节点            currNode.val = nums[mid];            // 处理左区间            if (left &lt;= mid - 1) {                currNode.left = new TreeNode(-1);                nodeQueue.offer(currNode.left);                leftQueue.offer(left);                rightQueue.offer(mid - 1);            }            // 处理右区间            if (right &gt;= mid + 1) {                currNode.right = new TreeNode(-1);                nodeQueue.offer(currNode.right);                leftQueue.offer(mid + 1);                rightQueue.offer(right);            }        }        return root;    }}\n\n把二叉搜索树转换为累加树递归class Solution {    int sum;    public TreeNode convertBST(TreeNode root) {        sum = 0;        convertBST1(root);        return root;    }    // 按右中左顺序遍历，累加即可    public void convertBST1(TreeNode root) {        if (root == null) {            return;        }        convertBST1(root.right);        sum += root.val;        root.val = sum;        convertBST1(root.left);    }}\n\n迭代class Solution {    //DFS iteraion統一迭代法    public TreeNode convertBST(TreeNode root) {        int pre = 0;        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();        if(root == null) //edge case check            return null;        stack.add(root);        while(!stack.isEmpty()){            TreeNode curr = stack.peek();            //curr != null的狀況，只負責存node到stack中            if(curr != null){                 stack.pop();                if(curr.left != null)       //左                    stack.add(curr.left);                stack.add(curr);            //中                stack.add(null);                if(curr.right != null)      //右                    stack.add(curr.right);            }else{            //curr == null的狀況，只負責做單層邏輯                stack.pop();                TreeNode temp = stack.pop();                temp.val += pre;                pre = temp.val;            }        }        return root;    }}\n\n总结二叉树题目大致分为以下三类：\n\n涉及到二叉树的构造，即无论普通二叉树还是二叉搜索树一定前序，先构造中间节点\n求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算\n求二叉搜索树的属性，一定是中序，利用二叉搜索树左中右顺序遍历的 有序性\n\n\n学习文章代码随想录 (programmercarl.com)\n图片主要来源代码随想录 (programmercarl.com)\n","categories":["代码随想录","二叉树"],"tags":["二叉树","算法"]},{"title":"删除字符串中的所有相邻重复项_1047","url":"/2023/12/21/%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9-1047/","content":"删除字符串中的所有相邻重复项给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。\n在 S 上反复执行重复项删除操作，直到无法继续删除。\n在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。\n示例：\n输入：“abbaca”输出：“ca”解释：例如，在 “abbaca” 中，我们可以删除 “bb” 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 “aaca”，其中又只有 “aa” 可以执行重复项删除操作，所以最后的字符串为 “ca”。\n提示：\n\n\nS 仅由小写英文字母组成。\n\n解法一(栈+模拟)思路分析：\n\n使用栈来模拟重复项删除的操作，首先将第一个元素保存到栈中，然后从字符串的第二个元素开始遍历字符串\n\n在重复删除的过程中，如果栈顶的字符(即此时字符串字符的前一个字符)和此时字符串的字符相等，则说明该字母需要被删除，stack.pop()\n\n若栈顶没有元素或者栈顶的元素与此时的字符串不相等，则继续将该字符串的字符进栈\n\n在遍历完字符串后，此时栈内的元素组成的字符串为 重复删除后得到的字符串\n\n\n实现代码如下：\nclass Solution {    public String removeDuplicates(String s) {        int n = s.length();        // 字符串s的长度        if (n == 1) return s;    // 字符串只有一个字符 无需删除        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        stack.push(s.charAt(0));    // 提前将一个字符压入栈中        for (int i = 1; i &lt; n; ++i) {            char ch = s.charAt(i);            if (!stack.empty() &amp;&amp; stack.peek() == ch) {                // 若此时栈顶元素与字符串字符相等 则有重复项 并删除                stack.pop();            } else {                stack.push(ch);            }        }        // 栈内剩余字符 即为字符串反复执行重复项删除后的结果        // 将其转化为字符串 返回        char[] ans = new char[stack.size()];        for (int i = ans.length-1; i &gt;= 0; -- i)            ans[i] = stack.pop();        return new String(ans);    }}\n\n提交结果如下：\n解答成功:    执行耗时:69 ms,击败了53.40% 的Java用户    内存消耗:44.1 MB,击败了33.95% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历字符串\n\n空间复杂度：，栈保存字符串中的元素\n\n\n解法二(数组代替栈)思路分析：\n\n使用数组来代替栈，但是设计到了数据范围，通过对该题测试，字符串最长长度为1000000，但是经过提交测试 数组空间50005可以通过\n\n实现代码如下：\nclass Solution {    public String removeDuplicates(String s) {        int n = s.length();        // 字符串s的长度        if (n == 1) return s;    // 字符串只有一个字符 无需删除        char[] stack = new char[50005];        int index = -1;        for (int i = 0; i &lt; n; ++i) {            char ch = s.charAt(i);            if (index &gt;= 0 &amp;&amp; stack[index] == ch) {                index --;            } else {                ++ index;                stack[index] = ch;            }        }        char[] ans = new char[index+1];        System.arraycopy(stack, 0, ans, 0, index+1);        return new String(ans);    }}\n\n提交结果如下：\n解答成功:    执行耗时:5 ms,击败了93.17% 的Java用户    内存消耗:44 MB,击败了34.60% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，依旧为遍历字符串\n\n空间复杂度：定义的数组空间是已知常数\n\n\n","categories":["leetcode"],"tags":["刷题","字符串","栈"]},{"title":"删除有序数组中的重复项_26","url":"/2023/11/27/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-26/","content":"删除有序数组中的重复项26. 删除有序数组中的重复项 - 力扣（LeetCode）\n给你一个 非严格递增排列 的数组 nums ，请你** 原地** 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。\n返回 k 。\n\n判题标准:\n系统会用下面的代码来测试你的题解:\nint[] nums = [...]; // 输入数组int[] expectedNums = [...]; // 长度正确的期望答案int k = removeDuplicates(nums); // 调用assert k == expectedNums.length;for (int i = 0; i &lt; k; i++) {    assert nums[i] == expectedNums[i];}\n\n如果所有断言都通过，那么您的题解将被 通过。\n示例 1：\n输入：nums = [1,1,2]输出：2, nums = [1,2,_]解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。\n\n示例 2：\n输入：nums = [0,0,1,1,1,2,2,3,3,4]输出：5, nums = [0,1,2,3,4]解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。\n\n提示：\n\n1 &lt;= nums.length &lt;= 3 * 104\n-104 &lt;= nums[i] &lt;= 104\nnums 已按 非严格递增 排列\n\n解题解法一思路分析：\n\n首先考虑暴力求解，使用双循环遍历来修改原数组，但是这样时间复杂度为O(n^2)，不推荐。\n那么在原数组上对原数组进行修改，我们可以考虑使用双指针，通过双指针单循环来代替暴力双循环的做法，从而将时间复杂度降为O(n)。\n因为nums按非严格递增排列，那么有数组中的重复项均排列在一起；且元素的相对顺序要保持一致，那么考虑使用快慢双指针法来解决。\nslow慢指针用于指向新数组的索引，fast快指针用于遍历旧数组，寻找新数组的元素。\n且slow指针和fast指针应该从索引为1的地方开始遍历，因为数组的第一个元素不需要考虑是否存在重复项\n\n实现代码如下：\nclass Solution {    public int removeDuplicates(int[] nums) {       // 使用快慢指针 保持元素的相对顺序一致       int slow = 1;  // 从索引为1开始 新数组肯定包含旧数组的第一个元素       int fast;       int val = nums[0]; // 保留数组第一个元素的值进行 用于判断是否有重复项       for (fast = 1; fast &lt; nums.length; ++fast) {          if (nums[fast] != val) {             // 出现不重复项 保存到新数组中 并更新重复值             val = nums[fast];             nums[slow++] = val;          }       }       // 再保存新数组最后一个元素后 slow指针值刚好为新数组的元素个数       return slow;    }}\n\n提交结果如下：\n第一次提交结果：解答成功:    执行耗时:1 ms,击败了27.24% 的Java用户    内存消耗:43.3 MB,击败了5.07% 的Java用户第二次提交结果：解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.1 MB,击败了9.89% 的Java用户\n\n对以上代码再进行优化，如下：\nclass Solution {    public int removeDuplicates(int[] nums) {       // 使用快慢指针 保持元素的相对顺序一致       int slow = 1;  // 从索引为1开始 新数组肯定包含旧数组的第一个元素       int fast;       for (fast = 1; fast &lt; nums.length; ++fast) {          if (nums[fast] != nums[fast-1]) {             // 前项与后项不一致 则说明找到新数组的元素 将其保存到新数组中             nums[slow++] = nums[fast];          }       }       // 再保存新数组最后一个元素后 slow指针值刚好为新数组的元素个数       return slow;    }}\n\n复杂度分析：\n\n时间复杂度分析：O(n)\n空间复杂度分析：O(1)\n\n再对以上双指针代码进行优化，如下：\nclass Solution {    public int removeDuplicates(int[] nums) {       // 使用快慢指针 保持元素的相对顺序一致       int slow = 1;  // 从索引为1开始 新数组肯定包含旧数组的第一个元素       for (int fast = 1; fast &lt; nums.length; ++fast) {          if (nums[fast] != nums[slow-1]) {              // 出现与新数组中不重复的项(注意slow-1 才是指向上次添加的新数组元素位置)             if (fast-slow &gt; 0)        // 增加一次判断 避免原数组不含有重复项时 重新赋值一遍                nums[slow] = nums[fast];             slow ++;          }       }       // 再保存新数组最后一个元素后 slow指针值刚好为新数组的元素个数       return slow;    }}\n\n进行以上优化后，if (fast-slow &gt; 0)才进行赋值的判断，减少了 当数组为[1, 2, 3, 4, 5]这样不含重复项的数组时，重新赋值一遍的赋值开销，同时nums[fast] != nums[slow-1]也显得更加清晰简洁。\n","categories":["leetcode"],"tags":["刷题","数组","双指针"]},{"title":"删除链表的倒数第N个结点_19","url":"/2023/12/08/%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9-19/","content":"删除链表的倒数第 N 个结点19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）\n给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。\n示例 1：\n\n输入： head = [1,2,3,4,5], n = 2输出：[1,2,3,5]\n示例 2：\n输入： head = [1], n = 1输出：[]\n示例 3：\n输入： head = [1,2], n = 1输出：[1]\n提示：\n\n链表中结点的数目为 sz\n1 &lt;= sz &lt;= 30\n0 &lt;= Node.val &lt;= 100\n1 &lt;= n &lt;= sz\n\n进阶： 你能尝试使用一趟扫描实现吗？\n解题解法一(暴力)思路分析：\n\n先采用直接遍历统计链表中元素个数，然后再寻找 需要被删除节点的前一个节点进行删除\n\n实现代码如下：\nclass Solution {    public ListNode removeNthFromEnd(ListNode head, int n) {        int count = 0;        ListNode p = head;        while (p != null) {            ++ count;            p = p.next;        }        if (count == 1) {            return null;    // 只有一个节点 删除后链表为空        }        int index = count - n;        // 获得待删除节点位置索引 且索引从0开始计算        ListNode pre = new ListNode(-1);    // 虚拟头节点        pre.next = head;        ListNode cur = pre;        for (int i = 0; i &lt; index; ++i) {            cur = cur.next;        }        cur.next = cur.next.next;        return pre.next;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.6 MB,击败了21.41% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，至少需要遍历一遍链表\n\n空间复杂度：O(1)，使用常量级变量\n\n\n解法二(双指针)思路分析：\n\n首先定义一个指针p，按照n的值，对链表进行遍历，n--，当n=0时，终止指针p的遍历\n\n然后再定义一个指针q，保证p!=null的情况下，两个指针同时往后遍历链表\n\n当p == null时，此时指针q恰好指向需要被删除的链表\n\n对于以上双指针过程。需要考虑遍历时的边界问题，同时需要对遍历位置进行调整，需要将指针q指向需要被删除的节点的前一个节点，才能实现删除功能\n\n\n实现代码如下：\nclass Solution {    public ListNode removeNthFromEnd(ListNode head, int n) {        // 定义一个虚拟头节点        ListNode dummy = new ListNode(-1);        dummy.next = head;        ListNode p = dummy;        for (int i = 0; i &lt; n; ++i) {            p = p.next;        }        ListNode q = dummy;        while (p.next != null) {            p = p.next;            q = q.next;        }        q.next = q.next.next;        return dummy.next;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.9 MB,击败了7.38% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，只需扫描一遍链表\n\n空间复杂度：O(1)，定义了常量级的变量\n\n\n","categories":["leetcode"],"tags":["刷题","链表","双指针"]},{"title":"前k个高频元素_347","url":"/2023/12/26/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0-347/","content":"前k个高频元素给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。\n示例 1:\n输入: nums = [1,1,1,2,2,3], k = 2输出: [1,2]\n示例 2:\n输入: nums = [1], k = 1输出: [1]\n提示：\n\n\nk 的取值范围是 [1, 数组中不相同的元素的个数]\n题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的\n\n进阶： 你所设计算法的时间复杂度 必须 优于 O(n log n) ，其中 n 是数组大小。\n解法一(大顶堆优先队列)思路分析：\n\n根据题目需要返回出现频率前k高的元素，考虑使用优先队列来解决\n\n首先思考优先队列中元素的含义，优先队列中存储的元素应该是一个二元组[num, sum]，num是数组中元素的值，sum则是数组中元素值为num的元素个数\n\n因为需要对数组中每个元素出现的个数进行统计，所以需要使用哈希表来对数组中的元素进行统计，且key为数组元素值，value为该值出现的次数\n\n统计后再将哈希表的键值对构成一个二元组保存到优先队列中，根据出现次数单调递减排序\n\n排好序后，将队列的前k个二元组弹出，获取数组中出现频率前k高的元素\n\n\n实现代码如下：\nclass Solution {    public int[] topKFrequent(int[] nums, int k) {        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        for (int num : nums) {    // 使用哈希表对数组元素个数进行统计            hashMap.put(num, hashMap.getOrDefault(num, 0)+1);        }        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; {            return o2[1] - o1[1];        }));        hashMap.forEach((key, value) -&gt; {    // 将哈希表元素保存到优先队列中进行排序            pq.offer(new int[]{key ,value});        });        int[] ans = new int[k];        for (int i = 0; i &lt; k; ++i) {    // 获取前k个高频元素            ans[i] = pq.poll()[0];        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:13 ms,击败了45.40% 的Java用户    内存消耗:47.3 MB,击败了5.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历数组时间复杂度为，将哈希表元素保存到优先队列中时间复杂度为，m为数组中不同元素的个数\n\n空间复杂度：，需要使用哈希表和优先队列来存储统计结果\n\n\n解法二(小顶堆优先队列)思路分析：\n\n根据解法一使用大顶堆优先队列，将map中的二元组按照value值从大到小排列，花费时间复杂度不易控制\n\n考虑使用小顶堆优先队列尝试剪枝和优化，即根据二元组的value值从小到大排列，每次排列k个二元组，当队列元素个数超过k个时，将队首的较小元素移除，维护队列中只排列k个二元组\n\n\n实现代码如下：\nclass Solution {    // 小顶堆优先队列    public int[] topKFrequent(int[] nums, int k) {        HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();        for (int num : nums) {    // 使用哈希表对数组元素个数进行统计            hashMap.put(num, hashMap.getOrDefault(num, 0)+1);        }        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(((o1, o2) -&gt; {            return o1[1] - o2[1];        }));        hashMap.forEach((key, value) -&gt; {    // 将哈希表元素保存到优先队列中进行排序            pq.offer(new int[]{key ,value});            if (pq.size() &gt; k)     // 维护队列中只排序k个元组                pq.poll();        });        int[] ans = new int[k];        for (int i = k-1; i &gt;= 0; -- i) {    // 获取前k个高频元素            ans[i] = pq.poll()[0];        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:13 ms,击败了45.40% 的Java用户    内存消耗:47.8 MB,击败了5.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","数组","排序","哈希表","分治","桶排序","计数","快速选择","堆(优先队列)"]},{"title":"反转字符串_344","url":"/2023/12/16/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-344/","content":"344. 反转字符串编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须 原地修改输入数组  、使用 O(1) 的额外空间解决这一问题。\n示例 1：\n输入： s = [“h”,”e”,”l”,”l”,”o”]输出：[“o”,”l”,”l”,”e”,”h”]\n示例 2：\n输入： s = [“H”,”a”,”n”,”n”,”a”,”h”]输出：[“h”,”a”,”n”,”n”,”a”,”H”]\n提示：\n\n\ns[i] 都是 ASCII 码表中的可打印字符\n\n解法一(相向双指针)思路分析：\n\n题目要求在”原地”修改数组，并使用的额外空间解决\n\n对于 原地反转 之类的操作，一般首先想到的都是 双向双指针\n\n即左指针从左向右，右指针从右向左，每次交换左右指针指向的数组元素，且保证left &lt; right，因为当left == right时，交换无意义\n\n\n实现代码如下：\nclass Solution {    public void reverseString(char[] s) {        int left = 0;    // 定义左指针        int right = s.length - 1;    // 定义右指针        while (left &lt; right) {            // 交换 左右指针指向的元素            char ch = s[left];            s[left] = s[right];            s[right] = ch;            // 移动左指针            ++ left;            // 移动右指针            -- right;        }    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:49.9 MB,击败了6.05% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，左右指针各自遍历一半的数组长度\n\n空间复杂度：，只使用了两个指针变量，以及一个交换变量\n\n\n","categories":["leetcode"],"tags":["刷题","字符串","双指针"]},{"title":"反转字符串II_541","url":"/2023/12/17/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II-541/","content":"反转字符串 II给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。\n\n如果剩余字符少于 k 个，则将剩余字符全部反转。\n如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。\n\n示例 1：\n输入： s = “abcdefg”, k = 2输出：“bacdfeg”\n示例 2：\n输入： s = “abcd”, k = 2输出：“bacd”\n提示：\n\n\ns 仅由小写英文组成\n\n\n解法一(相向双指针+模拟)思路分析：\n\n首先对于反转k个字符串，我们可以使用相向双指针来实现，可以单独编写一个反转函数reverseStr()进行反转\n\n然后根据题目的要求对情况做不同的处理；每次计算前对剩余字符做判断\n\n若剩余字符大于2k则反转reverseStr(i, i+k-1, s)\n\n若剩余字符小于2k大于k则反转reverseStr(i, i+k-1, s)\n\n若剩余字符少于k个，则将剩余字符全部反转，即reverseStr(i, s.length-1, s)\n\n\n\n\n实现代码如下：\nclass Solution {    public String reverseStr(String s, int k) {        int n = s.length();        // 字符串长度        if (n == 1)        // 若字符串长度为1 则不需要反转            return s;        char[] str = s.toCharArray();    // 将字符串转化为字符数组        int i = 0;    // 每次反转字符串的起始点        while (true) {            if (n-i &gt;= 2*k) {                reverseStr(i, i+k-1, str);                i += 2*k;            } else if (n-i &gt;= k) {                reverseStr(i, i+k-1, str);                break;            } else {                reverseStr(i, n-1, str);                break;            }        }        return new String(str);    }    // 反转字符串函数    public void reverseStr(int left, int right, char[] str) {        while (left &lt; right) {            char ch = str[left];            str[left ++] = str[right];            str[right --] = ch;        }    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:42.6 MB,击败了11.33% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，其中，即每次循环指针i都会增加2k的长度，因此寻找需要反转的字符串花费的时间复杂度为，同时每次对寻找到的字符串进行反转花费的时间复杂度为，综合则时间复杂度为\n\n空间复杂度：，不包括将字符串s转化为字符数组所花费的空间，即每次调用函数reverseStr()花费空间复杂度为\n\n\n","categories":["leetcode"],"tags":["刷题","字符串","双指针"]},{"title":"反转字符串的单词_151","url":"/2023/12/18/%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%8D%95%E8%AF%8D-151/","content":"反转字符串的单词151. 反转字符串中的单词 - 力扣（LeetCode）\n给你一个字符串 s ，请你反转字符串中 单词 的顺序。\n单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。\n返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。\n注意： 输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。\n示例 1：\n输入： s = \"the sky is blue\"输出：\"blue is sky the\"\n示例 2：\n输入： s = \"  hello world  \"输出：\"world hello\"解释： 反转后的字符串中不能存在前导空格和尾随空格。\n示例 3：\n输入： s = \"a good   example\"输出：\"example good a\"解释： 如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。\n提示：\n\n\ns 包含英文大小写字母、数字和空格 ' '\ns 中 至少存在一个 单词\n\n进阶： 如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 O(1) 额外空间复杂度的 原地 解法。\n解法一(快慢双指针)思路分析：\n\n使用快慢双指针法，快慢指针从后往前遍历 如此先找到的单词则放在返回结果的前面 实现反转；\n\n快指针指向一个单词的起始位置，慢指针则指向一个单词的末尾位置\n\n每当找到一个单词后，则将单词保存到ans中，然后继续移动快慢指针\n\n\n实现代码如下：\nclass Solution {    public String reverseWords(String s) {        int n = s.length();        // 字符串s的长度        if (n == 1)            return s;    // 当只有一个单词时 无需反转        StringBuffer ans = new StringBuffer();    // 记录反转后的字符串        int slow = n-1;    // 慢指针 记录一个单词的末尾位置        while (slow &gt;= 0 &amp;&amp; s.charAt(slow) == ' ')            -- slow;    // 跳过后置空格 并指向第一个单词的末尾位置        int fast = slow;    // 快指针 指向单词的起始位置        while (fast &gt;= 0) {            // 移动快指针到 一个单词的起始            while (fast &gt;= 0 &amp;&amp; s.charAt(fast) != ' ')                -- fast;            // 找到一个单词 则将单词保存到返回值中            ans.append(s, fast+1, slow+1).append(' ');            // 继续移动慢指针 到下一个单词的末尾位置            slow = fast;            while (slow &gt;= 0 &amp;&amp; s.charAt(slow) == ' ')                -- slow;            fast = slow;    // 更新快指针下一次移动的起始位置        }        ans.deleteCharAt(ans.length()-1);    // 删除末尾多余的空格        return new String(ans);    }}\n\n提交结果如下：\n解答成功:    执行耗时:3 ms,击败了90.82% 的Java用户    内存消耗:40.6 MB,击败了73.99% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n为字符串s的长度，快慢指针一共遍历字符串一次，不包括ans.append(s, fast+1, slow+1)的时间复杂度\n\n空间复杂度：，不计算返回值所消耗的空间，则双指针花费的空间复杂度为\n\n\n解法二(不使用Java内置函数)思路分析：\n\n先去除字符串前后空格和中间多余的空格，参考移除元素，使用快慢双指针法\n\n然后反转整个字符串 使用相向双指针进行反转\n\n最后反转每个单词\n\n使用s.toCharArray()获取一个可修改的字符数组，在该数组的基础上进行修改\n\n\n实现代码如下：\nclass Solution {    public String reverseWords(String s) {        int n = s.length();        // 字符串s的长度        if (n == 1)            return s;    // 当只有一个单词时 无需反转        char[] str = s.toCharArray();    // 将字符串转化为字符数组        str = removeExtraSpaces(str);    // 去除多余的空格        // 反转整个字符串        reverseString(0, str.length-1, str);        // 反转新字符串数组中的 每个单词        int start = 0;    // 单词的起始索引        for (int end = 0; end &lt;= str.length; ++end) {            if (end == str.length || str[end] == ' ') {    // end==str.length时 反转末尾的单词                reverseString(start, end-1, str);                start = end + 1;            }        }        return new String(str);    }    // 相向双指针 反转字符串    private void reverseString(int left, int right, char[] str) {        while (left &lt; right) {            // 交换左右指针 指向的数组元素            str[left] ^= str[right];            str[right] ^= str[left];            str[left] ^= str[right];            // 移动左右指针            ++ left;            -- right;        }    }    // 去除字符串 前后及中间的多余空格    private char[] removeExtraSpaces(char[] str) {        // 使用快慢双指针法        int n = str.length;        // 数组长度        int slow = 0;        for (int fast = 0; fast &lt; str.length; ++fast) {            if (str[fast] != ' ') {    // 快指针开始遍历一个单词                if (slow != 0) {    // 若此时遍历的单词不是第一个单词 则需要用空格隔开                    str[slow++] = ' ';                }                while (fast &lt; n &amp;&amp; str[fast] != ' ')    // 快指针遍历到一个单词的末尾                    str[slow++] = str[fast++];            }        }        // 去除多余空格后的数组 长度为 slow        // 因此需要返回新的数组        char[] newStr = new char[slow];        System.arraycopy(str, 0, newStr, 0, slow);        return newStr;    }}\n\n提交结果如下：\n解答成功:    执行耗时:2 ms,击败了97.62% 的Java用户    内存消耗:40.7 MB,击败了66.51% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，移除多余空格和反转字符串的时间复杂度均为\n\n空间复杂度：，因为需要改变字符串长度，需要使用新的数组，所以消耗空间为\n\n\n","categories":["leetcode"],"tags":["刷题","字符串","双指针"]},{"title":"反转链表_206","url":"/2023/12/06/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-206/","content":"反转链表给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1：\n\n输入： head = [1,2,3,4,5]输出：[5,4,3,2,1]\n示例 2：\n\n输入： head = [1,2]输出：[2,1]\n示例 3：\n输入： head = []输出：[]\n提示：\n\n链表中节点的数目范围是 [0, 5000]\n-5000 &lt;= Node.val &lt;= 5000\n\n进阶： 链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n解题解法一(双指针迭代)思路分析：\n\n首先考虑head == null的情况，此时直接返回null\n\n然后使用两个指针，指针p在前，指针q在后，将指针q的指向改为指向p，即q.next=p，完成反转\n\n然后再依次移动指针p和指针q，当遍历结束后，q=null已经没有需要反转的节点，p则刚好指向最后一个节点，即反转链表的第一个节点；将其返回\n\n\n实现代码如下：\nclass Solution {    public ListNode reverseList(ListNode head) {        if (head == null)    // head为空 直接返回            return null;        // p为q的前一个节点        ListNode p = head;        ListNode q = head.next;        while (q != null) {            ListNode t = q.next;    // 记录下q的下一个节点            q.next = p;        // 改变节点的指向 将其反转指向前一个节点            p = q;            // 重新移动p为 未反转节点的前一个节点            q = t;            // 移动q到还未反转的节点        }        head.next = null;    // 第一个节点的指向需要改为空        return p;        // 返回新的头节点 即原链表的尾节点    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.9 MB,击败了91.80% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，即遍历原链表\n\n空间复杂度：O(1)，使用常量级变量\n\n\n解法二(递归)思路分析：\n\n首先一直递归，知道递归到最后一个节点，此时最后一个节点的下一个节点为空，直接返回即可\n\n然后返回的新链表是已经反转好的链表，并且返回的是头节点，此时的head，指向的是已经反转好的链表的最后一个节点，改变其方向，将其指向自己\n\n即将此时的节点head加入到反转链表中，并将其指向的值更改为null\n\n最后依次回调\n\n\n实现代码如下：\nclass Solution {    public ListNode reverseList(ListNode head) {        if (head == null || head.next == null)    // head为空 直接返回            return head;        ListNode p = reverseList(head.next);        head.next.next = head;        head.next = null;        return p;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40 MB,击败了83.06% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n","categories":["leetcode"],"tags":["刷题","链表","递归"]},{"title":"哈希表理论基础","url":"/2023/12/10/%E5%93%88%E5%B8%8C%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","content":"哈希表理论基础哈希表    哈希表(Hash table) 是根据 关键码的值 而直接进行访问的数据结构；直白来讲数组就是一张哈希表。即哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素；如下图所示：\n\n一般哈希表都用来判断一个元素是否出现在集合里。\n哈希函数    哈希函数，一般是把 关键值 映射为哈希表上的索引，然后通过查询索引下标快速得出 键值(key)对应的 值(value)。\n    哈希函数如下图所示，通过hashCode把名字转化为数值，一般hashcode是通过特定编码方式，可以将其他数据格式转化为不同的数值，这样就把学生名字映射为哈希表上的索引数字了。\n\n当键值对的数量超过哈希表的大小时，需要用到 哈希碰撞。\n哈希碰撞如图，即当两个关键值都映射到了同一个索引的位置，这个现象就叫哈希碰撞。\n\n一般解决哈希碰撞有两种方法，拉链法和线性探测法。\n拉链法    若两个关键值映射到同一个索引位置发生冲突，则发生冲突的元素都被存储到链表中，这样就可以通过索引找到这两个关键值。\n\n    即拉链法需要选择适合的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。\n线性探测法    线性探测法，一定要保证tableSize(哈希表大小)大于dataSize(数据规模)。 我们需要依靠哈希表中的空位来解决碰撞问题。\n    例如，冲突的位置，已经存放了关键值，那么往下寻找下一个空位放置另一个关键值，所以要求 tableSize 一定要大于 dataSize，不然哈希表没有多余空位来存放 冲突的数据了；如图：\n \n常见的三种哈希结构 使用哈希法来解决问题时，一般会选择如下三种数据结构：\n\n数组\n\nset 集合\n\nmap (映射)\n\n\n哈希结构比较参考文章：\nJava中的hash结构总结：HashSet、HashMap、HashTable_hashset hashmap hashtable-CSDN博客\n总结    当需要快速判断一个元素是否出现在集合中的时候，优先考虑哈希法。\n    但是哈希法是 牺牲空间换取时间，因为要使用额外的空间来存放数据，才能实现快速查找。\n例题有效的字母异位词题目链接\n数组是最简单的哈希表，但是数组的大小不是无限开辟的。\n数组哈希    数组其实是一个简单的哈希表。\n    题目中字符均为小写字母，因此出现字符区间为[‘a’, ‘z’]，最多是26个字母，所以我们可以使用数组record，来统计字符。\n    遍历字符串s时，遇到一个字符，则对应字符的数量增加，遍历字符串t时，遇到一个字符，则对应字符的数量减少，然后再对数组record进行遍历检查，若有元素不为0，则不满足题意。\n代码如下：\nclass Solution {    public boolean isAnagram(String s, String t) {        int[] record = new int[26];        for (int i = 0; i &lt; s.length(); i++) {            record[s.charAt(i) - 'a']++;     // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了        }        for (int i = 0; i &lt; t.length(); i++) {            record[t.charAt(i) - 'a']--;        }        for (int count: record) {            if (count != 0) {               // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。                return false;            }        }        return true;                        // record数组所有元素都为零0，说明字符串s和t是字母异位词    }}\n\n\n时间复杂度: O(n)\n空间复杂度: O(1)\n\n相关题目赎金信_383\n字母异位词分组_49\n找到字符串中所有字母异位词_438\n两个数组的交集题目链接\n    如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费。\n    根据题目数据的值在1000以内，直接用数组做哈希表即可。\n考虑数据范围小+数组哈希实现代码如下：\nclass Solution {    public int[] intersection(int[] nums1, int[] nums2) {        int[] hash = new int[1001];        // 哈希数组        int[] ans = new int[nums1.length];    // 存储交集        for (int number: nums1) {    // 统计数组nums1中的元素            ++ hash[number];        }        int k = 0;    // ans数组的索引        for (int number: nums2) {    // 遍历数组nums2 寻找交集中的元素            if (hash[number] &gt; 0) {                ans[k++] = number;                hash[number] = -1;    // 更新哈希数组中对应的值 表示交集中不在需要该元素            }        }        int[] anss = new int[k];        // 数组复制    arraycopy(源数组, 源数组中的起始位置, 目标数组, 目标数组的起始位置, 复制的长度)        System.arraycopy(ans, 0, anss, 0, k);        return anss;    }}\n\n默认数据范围很大+Set哈希class Solution {    public int[] intersection(int[] nums1, int[] nums2) {        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {            return new int[0];        }        Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;();        Set&lt;Integer&gt; resSet = new HashSet&lt;&gt;();        //遍历数组1        for (int i : nums1) {            set1.add(i);        }        //遍历数组2的过程中判断哈希表中是否存在该元素        for (int i : nums2) {            if (set1.contains(i)) {                resSet.add(i);            }        }        //方法1：将结果集合转为数组        return resSet.stream().mapToInt(x -&gt; x).toArray();        //方法2：另外申请一个数组存放setRes中的元素,最后返回数组        int[] arr = new int[resSet.size()];        int j = 0;        for(int i : resSet){            arr[j++] = i;        }        return arr;    }}\n\n相关题目两个数组的交集II_350\n快乐数题目及解题参考链接\n两数之和题目链接\n    当我们需要查询一个元素是否出现过，或者一个元素是否在集合里得时候，一般第一时间想到哈希法。\n    对于本题，需要我们查询一个元素是否出现过，并且还需要知道这个元素对应得下标；如果我们使用数组或Set来做哈希得话，会有以下局限\n\n数组大小受到限制，当元素很少时，若哈希值太大则会造成内存空间得浪费\n\nSet是一个集合，但是里面存放得元素只有一个key，对于该题来说，不但需要知道key是否存在集合，还需要返回key对应的下标，因此Set不适用。\n\n\n    所以我们需要使用Map来做哈希，则接下来需要明确两点：\n\nmap用来做什么\n\nkey和value分别表示什么\n\n\n即对于该题\n\nmap用来存放访问过的元素，因为遍历数组得时候，需要记录之前遍历过得元素和对应下表，这样才能找到与当前元素相匹配的值\n\n那么为了判断一个元素是否出现，出现则返回元素下标，即key用来存储遍历的元素，value存储数组元素对应的下标\n\n\n在遍历数组时，向map查询是否有与当前元素匹配的数值，有则找到并返回，无则将当前元素继续保存到map中\n具体实现代码如下：\npublic int[] twoSum(int[] nums, int target) {    int[] res = new int[2];    if(nums == null || nums.length == 0){        return res;    }    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for(int i = 0; i &lt; nums.length; i++){        int temp = target - nums[i];   // 遍历当前元素，并在map中寻找是否有匹配的key        if(map.containsKey(temp)){            res[1] = i;            res[0] = map.get(temp);            break;        }        map.put(nums[i], i);    // 如果没找到匹配对，就把访问过的元素和下标加入到map中    }    return res;}\n\n\n时间复杂度: O(n)\n空间复杂度: O(n)\n\n总结对于该题有四个重点：\n\n为什么想到要用哈希表\n\n哈希表为什么使用map\n\n本题中 map用来存什么\n\nmap中的key和value用来存什么\n\n\n四数相加 II四数相加II_454\n分组+Map哈希    将四个数组分成两组 分别求和，再将求和得到的新的两个数组再求和，在第二次求和时，使用Map作为哈希表，Map中key用来表示第一组求和的元素，value则表示第一组求和元素出现的个数。思路详情\n代码如下所示：\nclass Solution {    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {        int res = 0;        Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;();        //统计两个数组中的元素之和，同时统计出现的次数，放入map        for (int i : nums1) {            for (int j : nums2) {                int sum = i + j;                map.put(sum, map.getOrDefault(sum, 0) + 1);            }        }        //统计剩余的两个元素的和，在map中找是否存在相加为0的情况，同时记录次数        for (int i : nums3) {            for (int j : nums4) {                res += map.getOrDefault(0 - i - j, 0);            }        }        return res;    }}\n\n\n时间复杂度: O(n^2)\n空间复杂度: O(n^2)，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2\n\n三数之和题目链接\n排序+双指针具体思路：\n四数之和四数之和_18\n排序+双指针    即在三树之和的基础上 在添加一个循环 多寻找一个元组，同时还有对循环进行剪枝。\n    具体思路\n总结\n学习文章代码随想录 (programmercarl.com)\n","categories":["代码随想录","哈希表"],"tags":["哈希表","算法"]},{"title":"四数之和_18","url":"/2023/12/15/%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C-18/","content":"四数之和18. 四数之和 - 力扣（LeetCode）\n给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：\n\n0 &lt;= a, b, c, d &lt; n\na、b、c 和 d 互不相同\nnums[a] + nums[b] + nums[c] + nums[d] == target\n\n你可以按 任意顺序 返回答案 。\n示例 1：\n输入： nums = [1,0,-1,0,-2,2], target = 0输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n示例 2：\n输入： nums = [2,2,2,2,2], target = 8输出：[[2,2,2,2]]\n提示：\n\n\n\n\n\n解法一(排序+双指针+剪枝)思路分析：\n\n根据题目三数之和，对于该题采用同样的做法\n\n首先对数组nums进行排序，保证获取的元组[a, b, c, d]，符合，这样便于排除重复的四元组\n\n然后对于前两个元素采取循环遍历的方式，每次查找四元组，先确认a和b，然后再对排序后的数组，使用双指针进行查找\n\n同时可以对前两个循环进行剪枝\n\n确定a后，若a + nums[i+1] + nums[i+2] + nums[i+3] &gt; targte，则不用再继续遍历查找元组的其他元素了，break退出即可\n\n同时确定a后，若a + nums[n-3] + nums[n-2] + nums[n-1] &lt; targte，则接下来的查询中不会含有满足条件的元组，continue继续查找新的a\n\n同理确定a和b后同样可以剪枝\n\n\n\n同时需要注意的是 nums[i]的返回，四数之和可能会超过int型的范围，因此在求和时，要注意类型强转为long\n\n\n实现代码如下：\nclass Solution {    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) {        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();        int n = nums.length;    // 数组长度        if (n &lt; 4)        // 数组元素小于4 则不存在四元组            return ans;        Arrays.sort(nums);    // 对数组进行排序        // 查找元组        for (int i = 0; i &lt; n-3; ++ i) {            int a = nums[i];    // 元组第一个元素 a            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) {    // 排除重复的元素a                continue;            }            if ((long)a + nums[i+1] + nums[i+2] + nums[i+3] &gt; target)                break;    // 确定a后 进行剪枝            if ((long)a + nums[n-3] + nums[n-2] + nums[n-1] &lt; target)                continue;    // 确定a后 进行剪枝            for (int j = i+1; j &lt; n-2; ++ j) {                int b = nums[j];    // 元组第二个元素 b                if (j &gt; i+1 &amp;&amp; nums[j] == nums[j-1]) {    // 排除重复的元素 b                    continue;                }                if ((long)a + b + nums[j+1] + nums[j+2] &gt; target)                    break;    // 确定a和b后 进行剪枝                if ((long)a + b + nums[n-2] + nums[n-1] &lt; target)                    continue;    // 确定a和b后 进行剪枝                // 双指针遍历 查找元素c和d                int k = j+1;                int l = n-1;                while (k &lt; l) {                    // 因为nums[i]的值为10^9 四数和可能会出现溢出 需要使用long来存储                    long s = (long)a + b + nums[k] + nums[l];                    if (s &gt; target) {    // 四个元素和过大 说明d的值需要减小                        -- l;    // 右指针左移                    } else if (s &lt; target) {    // 四个元素和过小 说明c的值需要增大                        ++ k;    // 左指针右移                    } else {                        ans.add(Arrays.asList(a, b, nums[k], nums[l])); // 将找到的元组记录到返回值                        // 移动左指针 并去重                        ++ k;                        while (k &lt; l &amp;&amp; nums[k] == nums[k-1])                            ++ k;                        // 移动右指针 并去重                        -- l;                        while (k &lt; l &amp;&amp; nums[l] == nums[l+1])                            -- l;                    }                }            }        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:2 ms,击败了99.81% 的Java用户    内存消耗:42.8 MB,击败了48.03% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，对数组排序需要的时间复杂度为，遍历寻找元组的时间复杂度为，综合得出时间复杂度为\n\n空间复杂度：，忽略排序消耗的空间和返回值的消耗，使用的空间复杂度\n\n\n","categories":["leetcode"],"tags":["刷题","数组","排序","双指针"]},{"title":"四数相加II_454","url":"/2023/12/13/%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0II-454/","content":"四数相加 II454. 四数相加 II - 力扣（LeetCode）\n给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：\n\n\n\n\n示例 1：\n输入： nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]输出： 2解释：两个元组如下：\n\n(0, 0, 0, 1) -&gt; nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0\n(1, 1, 0, 0) -&gt; nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0\n\n示例 2：\n输入： nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]输出： 1\n提示：\n\n\n\n\n\n\n\n\n解法一(分组+Map哈希)思路分析：\n\n结合题目两数之和，先对数组nums1和数组nums2进行求和得到一个新的数组x，再对数组nums3和数组元素nums4求和得到一个新的数组y。如此题目便转换为，求数组x和y中元素和为0的二元元组\n\n因为不同元素求和后可能会有同样的值，所以不考虑使用Set作为哈希表，同时元素的值跨度较大，也不考虑使用数组作为哈希。因此使用Map作为哈希表。\n\n同时我们可以在求数组x的元素时，便直接将nums1[i]+nums2[j]的元素加入到哈希表中，然后再求新数组y的元素时，亦不再新建数组，每求出一个y的元素，便查询哈希表检测是否符合题意，符合则元组数+1\n\n同时需要思考Map用来存放什么，即Map用来存放nums1和nums2求和的元素，其key用来表示求和后的值，而value应该表示所求和得到的元素出现的个数，因为题目不要求知晓元组内元素的索引，因此value表示求和元素的索引没有意义\n\nvalue表示新数组x中相同元素的个数，即出现y中元素与某个key符合条件，则此时元组数ans应该添加value个。因为这value个元素是 值相等却又由不同的nums1和nums2的数组元素求和得到的\n\n\n实现代码如下：\nclass Solution {    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {        // 存储数组nums1和nums2各个元素和 且(key-&gt; nums1[i]+nums2[j], value-&gt; 出现次数)        HashMap&lt;Integer, Integer&gt; sumHash = new HashMap&lt;&gt;();        int ans = 0;    // 统计满足条件的元组数        // 计算 nums1[i]+nums2[j] 并记录到sumHash中        for (int i = 0; i &lt; nums1.length; ++i) {            for (int j = 0; j &lt; nums2.length; ++j) {                int x = nums1[i] + nums2[j];                sumHash.put(x, sumHash.getOrDefault(x, 0) + 1);            }        }        // 计算 nums3[k]+nums4[l] 并寻找符合条件的元组        for (int k = 0; k &lt; nums3.length; ++k) {            for (int l = 0; l &lt; nums4.length; ++l) {                int y = nums3[k] + nums4[l];                y = -y;        // 由x+y=0 得 此时应查询sumHash中是否有x = -y的key                ans += sumHash.getOrDefault(y, 0);    // 存在则添加元组个数 不存在则默认添加0            }        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:113 ms,击败了73.13% 的Java用户    内存消耗:43.1 MB,击败了6.57% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，需要分别对 数组nums1与nums2求和、数组nums3与nums4求和，两者时间复杂度均为\n\n空间复杂度：，需要使用哈希表来存储数组nums1与nums3求和后的值\n\n\n","categories":["leetcode"],"tags":["刷题","数组","哈希表"]},{"title":"回溯算法","url":"/2024/03/04/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","content":"理论基础什么是回溯法回溯法也可以叫做回溯搜索法，是一种搜索的方式。\n回溯是递归的副产品，只要有递归就会有回溯。\n即回溯函数也就是递归函数，指的都是一个函数。\n回溯法的效率回溯法并不是高效的算法；因为回溯的本质是穷举，穷举所有可能，然后选出我们需要的答案。\n如果想要提高回溯算法的效率，可以尝试一些剪枝的操作。\n回溯法解决的问题一般可以解决如下几种问题：\n\n组合问题：N个数里按一定规则找出k个数的集合\n切割问题：一个字符串按一定规则有几种切割方式\n子集问题：N个数的集合里有多少符合条件的子集\n排列问题：N个数按一定规则全排列，有几种方式\n棋盘问题：N皇后、解数独等\n\n注意：组合是不强调元素顺序的，排列强调元素顺序。\n如何理解回溯法回溯法解决的问题都可以抽象为 树形结构；因为回溯法解决的是在集合中递归查找子集，集合的大小就构成了树的宽度；递归的深度就构成了树的高度。\n且递归需要有终止条件，所以构成的树形结构 必然是一棵高度有限的N叉树。\n回溯法模板回溯三部曲：\n\n回溯函数模板返回值以及参数\n\n一般给函数取名backtracking。\n回溯算法中函数返回值一般为 void。\n因为回溯算法需要的参数不容易一次性确定，所以先确定一个逻辑，再需要参数的时候，再添加对应参数。\n第一步伪代码如下：\npublic void backtracking(参数)\n\n回溯函数终止条件\n\n回溯法会形成一个 树形结构，即搜索到叶子节点时，结束递归。即找到满足条件的一条答案，就将答案存起来，并结束本层递归。\n第二步伪代码如下：\nif (终止条件) {    存放结果;    return ;}\n\n回溯算法的遍历过程\n\n使用for循环遍历树的宽度，递归形成树的深度。即for循环是横向遍历，backtracking（递归）是纵向遍历。\n第三步伪代码如下：\nfor (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {    处理节点;    backtracking(路径，选择列表); // 递归    回溯，撤销处理结果}\n\n根据上述回溯三部曲，得到最终模板如下：\npublic void backtracking(参数) {    if (终止条件) {        存放结果;        return;    }    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {        处理节点;        backtracking(路径，选择列表); // 递归        回溯，撤销处理结果    }}\n\n组合回溯+未剪枝class Solution {    List&lt;List&lt;Integer&gt;&gt; result= new ArrayList&lt;&gt;();    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {        backtracking(n,k,1);        return result;    }    public void backtracking(int n,int k,int startIndex){        if (path.size() == k){            result.add(new ArrayList&lt;&gt;(path));            return;        }        for (int i =startIndex;i&lt;=n;i++){            path.add(i);            backtracking(n,k,i+1);            path.removeLast();        }    }}\n\n回溯+剪枝class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {        combineHelper(n, k, 1);        return result;    }    /**     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。     */    private void combineHelper(int n, int k, int startIndex){        //终止条件        if (path.size() == k){            result.add(new ArrayList&lt;&gt;(path));            return;        }        for (int i = startIndex; i &lt;= n - (k - path.size()) + 1; i++){            path.add(i);            combineHelper(n, k, i + 1);            path.removeLast();        }    }}\n\n组合总和III回溯 + 剪枝class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {        backTracking(n, k, 1, 0);        return result;    }    private void backTracking(int targetSum, int k, int startIndex, int sum) {        // 减枝        if (sum &gt; targetSum) {            return;        }        if (path.size() == k) {            if (sum == targetSum) result.add(new ArrayList&lt;&gt;(path));            return;        }        // 减枝 9 - (k - path.size()) + 1        for (int i = startIndex; i &lt;= 9 - (k - path.size()) + 1; i++) {            path.add(i);            sum += i;            backTracking(targetSum, k, i + 1, sum);            //回溯            path.removeLast();            //回溯            sum -= i;        }    }}\n\n回溯 + 另一种形式剪枝// 上面剪枝 i &lt;= 9 - (k - path.size()) + 1; 如果还是不清楚// 也可以改为 if (path.size() &gt; k) return; 执行效率上是一样的class Solution {    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {        build(k, n, 1, 0);        return ans;    }    private void build(int k, int n, int startIndex, int sum) {        if (sum &gt; n) return;        if (path.size() &gt; k) return;        if (sum == n &amp;&amp; path.size() == k) {            ans.add(new ArrayList&lt;&gt;(path));            return;        }        for(int i = startIndex; i &lt;= 9; i++) {            path.add(i);            sum += i;            build(k, n, i + 1, sum);            sum -= i;            path.removeLast();        }    }}\n其他方法class Solution {    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; combinationSum3(int k, int n) {        res.clear();        list.clear();        backtracking(k, n, 9);        return res;    }    private void backtracking(int k, int n, int maxNum) {        if (k == 0 &amp;&amp; n == 0) {            res.add(new ArrayList&lt;&gt;(list));            return;        }        // 因为不能重复，并且单个数字最大值是maxNum，所以sum最大值为        // （maxNum + (maxNum - 1) + ... + (maxNum - k + 1)） == k * maxNum - k*(k - 1) / 2        if (maxNum == 0                || n &gt; k * maxNum - k * (k - 1) / 2                || n &lt; (1 + k) * k / 2) {            return;        }        list.add(maxNum);        backtracking(k - 1, n - maxNum, maxNum - 1);        list.remove(list.size() - 1);        backtracking(k, n, maxNum - 1);    }}\n\n电话号码的字母组合回溯class Solution {    //设置全局列表存储最后的结果    List&lt;String&gt; list = new ArrayList&lt;&gt;();    public List&lt;String&gt; letterCombinations(String digits) {        if (digits == null || digits.length() == 0) {            return list;        }        //初始对应所有的数字，为了直接对应2-9，新增了两个无效的字符串\"\"        String[] numString = {\"\", \"\", \"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};        //迭代处理        backTracking(digits, numString, 0);        return list;    }    //每次迭代获取一个字符串，所以会设计大量的字符串拼接，所以这里选择更为高效的 StringBuild    StringBuilder temp = new StringBuilder();    //比如digits如果为\"23\",num 为0，则str表示2对应的 abc    public void backTracking(String digits, String[] numString, int num) {        //遍历全部一次记录一次得到的字符串        if (num == digits.length()) {            list.add(temp.toString());            return;        }        //str 表示当前num对应的字符串        String str = numString[digits.charAt(num) - '0'];        for (int i = 0; i &lt; str.length(); i++) {            temp.append(str.charAt(i));            //c            backTracking(digits, numString, num + 1);            //剔除末尾的继续尝试            temp.deleteCharAt(temp.length() - 1);        }    }}\n\n组合总和回溯+剪枝// 剪枝优化class Solution {    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) {        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();        Arrays.sort(candidates); // 先进行排序        backtracking(res, new ArrayList&lt;&gt;(), candidates, target, 0, 0);        return res;    }    public void backtracking(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, int[] candidates, int target, int sum, int idx) {        // 找到了数字和为 target 的组合        if (sum == target) {            res.add(new ArrayList&lt;&gt;(path));            return;        }        for (int i = idx; i &lt; candidates.length; i++) {            // 如果 sum + candidates[i] &gt; target 就终止遍历            if (sum + candidates[i] &gt; target) break;            path.add(candidates[i]);            backtracking(res, path, candidates, target, sum + candidates[i], i);            path.remove(path.size() - 1); // 回溯，移除路径 path 最后一个元素        }    }}\n\n组合总和II可以将回溯算法递归形成的树形结构，分为树层和数枝，当题目要求不能出现重复的组合时，需要想清楚，是在树层去重还是在树枝去重。\n解决该题的关键在于树层去重。\n使用标记数组class Solution {  LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();  List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();  boolean[] used;  int sum = 0;  public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) {    used = new boolean[candidates.length];    // 加标志数组，用来辅助判断同层节点是否已经遍历    Arrays.fill(used, false);    // 为了将重复的数字都放到一起，所以先进行排序    Arrays.sort(candidates);    backTracking(candidates, target, 0);    return ans;  }  private void backTracking(int[] candidates, int target, int startIndex) {    if (sum == target) {      ans.add(new ArrayList(path));    }    for (int i = startIndex; i &lt; candidates.length; i++) {      if (sum + candidates[i] &gt; target) {        break;      }      // 出现重复节点，同层的第一个节点已经被访问过，所以直接跳过      if (i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; !used[i - 1]) {        continue;      }      used[i] = true;      sum += candidates[i];      path.add(candidates[i]);      // 每个节点仅能选择一次，所以从下一位开始      backTracking(candidates, target, i + 1);      used[i] = false;      sum -= candidates[i];      path.removeLast();    }  }}\n\n不使用标记数组class Solution {  List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();  LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();  int sum = 0;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2( int[] candidates, int target ) {    //为了将重复的数字都放到一起，所以先进行排序    Arrays.sort( candidates );    backTracking( candidates, target, 0 );    return res;  }    private void backTracking( int[] candidates, int target, int start ) {    if ( sum == target ) {      res.add( new ArrayList&lt;&gt;( path ) );      return;    }    for ( int i = start; i &lt; candidates.length &amp;&amp; sum + candidates[i] &lt;= target; i++ ) {      //正确剔除重复解的办法      //跳过同一树层使用过的元素      if ( i &gt; start &amp;&amp; candidates[i] == candidates[i - 1] ) {        continue;      }      sum += candidates[i];      path.add( candidates[i] );      // i+1 代表当前组内元素只选取一次      backTracking( candidates, target, i + 1 );      int temp = path.getLast();      sum -= temp;      path.removeLast();    }  }}\n\n分割回文串解决该题主要有以下难点：\n\n切割问题抽象为组合问题\n如何模拟切割线\n切割问题如何终止递归\n递归循环中如何截取子串\n如何判断回文\n\n回溯class Solution {    List&lt;List&lt;String&gt;&gt; lists = new ArrayList&lt;&gt;();    Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();    public List&lt;List&lt;String&gt;&gt; partition(String s) {        backTracking(s, 0);        return lists;    }    private void backTracking(String s, int startIndex) {        //如果起始位置大于s的大小，说明找到了一组分割方案        if (startIndex &gt;= s.length()) {            lists.add(new ArrayList(deque));            return;        }        for (int i = startIndex; i &lt; s.length(); i++) {            //如果是回文子串，则记录            if (isPalindrome(s, startIndex, i)) {                String str = s.substring(startIndex, i + 1);                deque.addLast(str);            } else {                continue;            }            //起始位置后移，保证不重复            backTracking(s, i + 1);            deque.removeLast();        }    }    //判断是否是回文串    private boolean isPalindrome(String s, int startIndex, int end) {        for (int i = startIndex, j = end; i &lt; j; i++, j--) {            if (s.charAt(i) != s.charAt(j)) {                return false;            }        }        return true;    }}\n\n复原 IP 地址String记录class Solution {    List&lt;String&gt; result = new ArrayList&lt;&gt;();    public List&lt;String&gt; restoreIpAddresses(String s) {        if (s.length() &gt; 12) return result; // 算是剪枝了        backTrack(s, 0, 0);        return result;    }    // startIndex: 搜索的起始位置， pointNum:添加逗点的数量    private void backTrack(String s, int startIndex, int pointNum) {        if (pointNum == 3) {// 逗点数量为3时，分隔结束            // 判断第四段⼦字符串是否合法，如果合法就放进result中            if (isValid(s,startIndex,s.length()-1)) {                result.add(s);            }            return;        }        for (int i = startIndex; i &lt; s.length(); i++) {            if (isValid(s, startIndex, i)) {                s = s.substring(0, i + 1) + \".\" + s.substring(i + 1);    //在str的后⾯插⼊⼀个逗点                pointNum++;                backTrack(s, i + 2, pointNum);// 插⼊逗点之后下⼀个⼦串的起始位置为i+2                pointNum--;// 回溯                s = s.substring(0, i + 1) + s.substring(i + 2);// 回溯删掉逗点            } else {                break;            }        }    }    // 判断字符串s在左闭⼜闭区间[start, end]所组成的数字是否合法    private Boolean isValid(String s, int start, int end) {        if (start &gt; end) {            return false;        }        if (s.charAt(start) == '0' &amp;&amp; start != end) { // 0开头的数字不合法            return false;        }        int num = 0;        for (int i = start; i &lt;= end; i++) {            if (s.charAt(i) &gt; '9' || s.charAt(i) &lt; '0') { // 遇到⾮数字字符不合法                return false;            }            num = num * 10 + (s.charAt(i) - '0');            if (num &gt; 255) { // 如果⼤于255了不合法                return false;            }        }        return true;    }}\n\n使用StringBuilder记录//方法一：但使用stringBuilder，故优化时间、空间复杂度，因为向字符串插入字符时无需复制整个字符串，从而减少了操作的时间复杂度，也不用开新空间存subString，从而减少了空间复杂度。class Solution {    List&lt;String&gt; result = new ArrayList&lt;&gt;();    public List&lt;String&gt; restoreIpAddresses(String s) {        StringBuilder sb = new StringBuilder(s);        backTracking(sb, 0, 0);        return result;    }    private void backTracking(StringBuilder s, int startIndex, int dotCount){        if(dotCount == 3){            if(isValid(s, startIndex, s.length() - 1)){                result.add(s.toString());            }            return;        }        for(int i = startIndex; i &lt; s.length(); i++){            if(isValid(s, startIndex, i)){                s.insert(i + 1, '.');                backTracking(s, i + 2, dotCount + 1);                s.deleteCharAt(i + 1);            }else{                break;            }        }    }    //[start, end]    private boolean isValid(StringBuilder s, int start, int end){        if(start &gt; end)            return false;        if(s.charAt(start) == '0' &amp;&amp; start != end)            return false;        int num = 0;        for(int i = start; i &lt;= end; i++){            int digit = s.charAt(i) - '0';            num = num * 10 + digit;            if(num &gt; 255)                return false;        }        return true;    }}\n\n方法二//方法二：比上面的方法时间复杂度低，更好地剪枝，优化时间复杂度class Solution {    List&lt;String&gt; result = new ArrayList&lt;String&gt;();    StringBuilder stringBuilder = new StringBuilder();    public List&lt;String&gt; restoreIpAddresses(String s) {        restoreIpAddressesHandler(s, 0, 0);        return result;    }    // number表示stringbuilder中ip段的数量    public void restoreIpAddressesHandler(String s, int start, int number) {        // 如果start等于s的长度并且ip段的数量是4，则加入结果集，并返回        if (start == s.length() &amp;&amp; number == 4) {            result.add(stringBuilder.toString());            return;        }        // 如果start等于s的长度但是ip段的数量不为4，或者ip段的数量为4但是start小于s的长度，则直接返回        if (start == s.length() || number == 4) {            return;        }        // 剪枝：ip段的长度最大是3，并且ip段处于[0,255]        for (int i = start; i &lt; s.length() &amp;&amp; i - start &lt; 3 &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &gt;= 0                &amp;&amp; Integer.parseInt(s.substring(start, i + 1)) &lt;= 255; i++) {            // 如果ip段的长度大于1，并且第一位为0的话，continue            if (i + 1 - start &gt; 1 &amp;&amp; s.charAt(start) - '0' == 0) {                continue;            }            stringBuilder.append(s.substring(start, i + 1));            // 当stringBuilder里的网段数量小于3时，才会加点；如果等于3，说明已经有3段了，最后一段不需要再加点            if (number &lt; 3) {                stringBuilder.append(\".\");            }            number++;            restoreIpAddressesHandler(s, i + 1, number);            number--;            // 删除当前stringBuilder最后一个网段，注意考虑点的数量的问题            stringBuilder.delete(start + number, i + number + 2);        }    }}\n\n子集需要考虑清除，子集问题与组合问题、分割问题的区别，子集是收集树形结构中所有节点的结果；而组合问题、分割问题是收集树形结构中叶子节点的结果。\n回溯class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();// 存放符合条件结果的集合    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 用来存放符合条件结果    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {        subsetsHelper(nums, 0);        return result;    }    private void subsetsHelper(int[] nums, int startIndex){        result.add(new ArrayList&lt;&gt;(path));//「遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合」。        if (startIndex &gt;= nums.length){ //终止条件可不加            return;        }        for (int i = startIndex; i &lt; nums.length; i++){            path.add(nums[i]);            subsetsHelper(nums, i + 1);            path.removeLast();        }    }}\n\n子集II需要理解好，树层去重和树枝去重，解决该题给定集合中含有重复元素的问题，则使用树层去重来解决。\n使用used数组class Solution {   List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();// 存放符合条件结果的集合   LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 用来存放符合条件结果   boolean[] used;    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) {        if (nums.length == 0){            result.add(path);            return result;        }        Arrays.sort(nums);        used = new boolean[nums.length];        subsetsWithDupHelper(nums, 0);        return result;    }        private void subsetsWithDupHelper(int[] nums, int startIndex){        result.add(new ArrayList&lt;&gt;(path));        if (startIndex &gt;= nums.length){            return;        }        for (int i = startIndex; i &lt; nums.length; i++){            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]){                continue;            }            path.add(nums[i]);            used[i] = true;            subsetsWithDupHelper(nums, i + 1);            path.removeLast();            used[i] = false;        }    }}\n\n不使用used数组class Solution {  List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();  LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup( int[] nums ) {    Arrays.sort( nums );    subsetsWithDupHelper( nums, 0 );    return res;  }  private void subsetsWithDupHelper( int[] nums, int start ) {    res.add( new ArrayList&lt;&gt;( path ) );    for ( int i = start; i &lt; nums.length; i++ ) {        // 跳过当前树层使用过的、相同的元素      if ( i &gt; start &amp;&amp; nums[i - 1] == nums[i] ) {        continue;      }      path.add( nums[i] );      subsetsWithDupHelper( nums, i + 1 );      path.removeLast();    }  }}\n\n非递减子序列关键在于：使用哈希来进行树层去重，而不是要将原数组排序的树层去重，该题不能改变原数组的元素顺序。\n回溯+哈希Setclass Solution {    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {        backTracking(nums, 0);        return result;    }    private void backTracking(int[] nums, int startIndex){        if(path.size() &gt;= 2)                result.add(new ArrayList&lt;&gt;(path));                    HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();        for(int i = startIndex; i &lt; nums.length; i++){            if(!path.isEmpty() &amp;&amp; path.get(path.size() -1 ) &gt; nums[i] || hs.contains(nums[i]))                continue;            hs.add(nums[i]);            path.add(nums[i]);            backTracking(nums, i + 1);            path.remove(path.size() - 1);        }    }}\n回溯+哈希数组class Solution {    private List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    private List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {        backtracking(nums,0);        return res;    }    private void backtracking (int[] nums, int start) {        if (path.size() &gt; 1) {            res.add(new ArrayList&lt;&gt;(path));        }        int[] used = new int[201];        for (int i = start; i &lt; nums.length; i++) {            if (!path.isEmpty() &amp;&amp; nums[i] &lt; path.get(path.size() - 1) ||                    (used[nums[i] + 100] == 1)) continue;            used[nums[i] + 100] = 1;            path.add(nums[i]);            backtracking(nums, i + 1);            path.remove(path.size() - 1);        }    }}\n回溯+哈希Mapclass Solution {    //结果集合    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();    //路径集合    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; findSubsequences(int[] nums) {        getSubsequences(nums,0);        return res;    }    private void getSubsequences( int[] nums, int start ) {        if(path.size()&gt;1 ){            res.add( new ArrayList&lt;&gt;(path) );            // 注意这里不要加return，要取树上的节点        }        HashMap&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();        for(int i=start ;i &lt; nums.length ;i++){            if(!path.isEmpty() &amp;&amp; nums[i]&lt; path.getLast()){                continue;            }            // 使用过了当前数字            if ( map.getOrDefault( nums[i],0 ) &gt;=1 ){                continue;            }            map.put(nums[i],map.getOrDefault( nums[i],0 )+1);            path.add( nums[i] );            getSubsequences( nums,i+1 );            path.removeLast();        }    }}\n\n全排列排列问题具有以下特点：\n\n每层从0开始搜索而不是startIndex\n需要used数组记录path中存放的元素\n\n使用used数组class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();// 存放符合条件结果的集合    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();// 用来存放符合条件结果    boolean[] used;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        if (nums.length == 0){            return result;        }        used = new boolean[nums.length];        permuteHelper(nums);        return result;    }    private void permuteHelper(int[] nums){        if (path.size() == nums.length){            result.add(new ArrayList&lt;&gt;(path));            return;        }        for (int i = 0; i &lt; nums.length; i++){            if (used[i]){                continue;            }            used[i] = true;            path.add(nums[i]);            permuteHelper(nums);            path.removeLast();            used[i] = false;        }    }}\n\n使用path代替used数组判断// 解法2：通过判断path中是否存在数字，排除已经选择的数字class Solution {    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {        if (nums.length == 0) return result;        backtrack(nums, path);        return result;    }    public void backtrack(int[] nums, LinkedList&lt;Integer&gt; path) {        if (path.size() == nums.length) {            result.add(new ArrayList&lt;&gt;(path));        }        for (int i =0; i &lt; nums.length; i++) {            // 如果path中已有，则跳过            if (path.contains(nums[i])) {                continue;            }             path.add(nums[i]);            backtrack(nums, path);            path.removeLast();        }    }}\n\n全排列 II需要加上树层去重\n回溯+树层去重class Solution {    //存放结果    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    //暂存结果    List&lt;Integer&gt; path = new ArrayList&lt;&gt;();    public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) {        boolean[] used = new boolean[nums.length];        Arrays.fill(used, false);        Arrays.sort(nums);        backTrack(nums, used);        return result;    }    private void backTrack(int[] nums, boolean[] used) {        if (path.size() == nums.length) {            result.add(new ArrayList&lt;&gt;(path));            return;        }        for (int i = 0; i &lt; nums.length; i++) {            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false) {                continue;            }            //如果同⼀树⽀nums[i]没使⽤过开始处理            if (used[i] == false) {                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用                path.add(nums[i]);                backTrack(nums, used);                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复                used[i] = false;//回溯            }        }    }}\n\n重新安排行程回溯class Solution {    private Deque&lt;String&gt; res;    private Map&lt;String, Map&lt;String, Integer&gt;&gt; map;    private boolean backTracking(int ticketNum){        if(res.size() == ticketNum + 1){            return true;        }        String last = res.getLast();        if(map.containsKey(last)){//防止出现null            for(Map.Entry&lt;String, Integer&gt; target : map.get(last).entrySet()){                int count = target.getValue();                if(count &gt; 0){                    res.add(target.getKey());                    target.setValue(count - 1);                    if(backTracking(ticketNum)) return true;                    res.removeLast();                    target.setValue(count);                }            }        }        return false;    }    public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) {        map = new HashMap&lt;String, Map&lt;String, Integer&gt;&gt;();        res = new LinkedList&lt;&gt;();        for(List&lt;String&gt; t : tickets){            Map&lt;String, Integer&gt; temp;            if(map.containsKey(t.get(0))){                temp = map.get(t.get(0));                temp.put(t.get(1), temp.getOrDefault(t.get(1), 0) + 1);            }else{                temp = new TreeMap&lt;&gt;();//升序Map                temp.put(t.get(1), 1);            }            map.put(t.get(0), temp);        }        res.add(\"JFK\");        backTracking(tickets.size());        return new ArrayList&lt;&gt;(res);    }}\n\nN 皇后回溯class Solution {    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {        char[][] chessboard = new char[n][n];        for (char[] c : chessboard) {            Arrays.fill(c, '.');        }        backTrack(n, 0, chessboard);        return res;    }    public void backTrack(int n, int row, char[][] chessboard) {        if (row == n) {            res.add(Array2List(chessboard));            return;        }        for (int col = 0;col &lt; n; ++col) {            if (isValid (row, col, n, chessboard)) {                chessboard[row][col] = 'Q';                backTrack(n, row+1, chessboard);                chessboard[row][col] = '.';            }        }    }    public List Array2List(char[][] chessboard) {        List&lt;String&gt; list = new ArrayList&lt;&gt;();        for (char[] c : chessboard) {            list.add(String.copyValueOf(c));        }        return list;    }    public boolean isValid(int row, int col, int n, char[][] chessboard) {        // 检查列        for (int i=0; i&lt;row; ++i) { // 相当于剪枝            if (chessboard[i][col] == 'Q') {                return false;            }        }        // 检查45度对角线        for (int i=row-1, j=col-1; i&gt;=0 &amp;&amp; j&gt;=0; i--, j--) {            if (chessboard[i][j] == 'Q') {                return false;            }        }        // 检查135度对角线        for (int i=row-1, j=col+1; i&gt;=0 &amp;&amp; j&lt;=n-1; i--, j++) {            if (chessboard[i][j] == 'Q') {                return false;            }        }        return true;    }}\n\n回溯+boolean数组标记// 方法2：使用boolean数组表示已经占用的直(斜)线class Solution {    List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();    boolean[] usedCol, usedDiag45, usedDiag135;    // boolean数组中的每个元素代表一条直(斜)线    public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) {        usedCol = new boolean[n];                  // 列方向的直线条数为 n        usedDiag45 = new boolean[2 * n - 1];       // 45°方向的斜线条数为 2 * n - 1        usedDiag135 = new boolean[2 * n - 1];      // 135°方向的斜线条数为 2 * n - 1        //用于收集结果, 元素的index表示棋盘的row，元素的value代表棋盘的column        int[] board = new int[n];        backTracking(board, n, 0);        return res;    }    private void backTracking(int[] board, int n, int row) {        if (row == n) {            //收集结果            List&lt;String&gt; temp = new ArrayList&lt;&gt;();            for (int i : board) {                char[] str = new char[n];                Arrays.fill(str, '.');                str[i] = 'Q';                temp.add(new String(str));            }            res.add(temp);            return;        }        for (int col = 0; col &lt; n; col++) {            if (usedCol[col] | usedDiag45[row + col] | usedDiag135[row - col + n - 1]) {                continue;            }            board[row] = col;            // 标记该列出现过            usedCol[col] = true;            // 同一45°斜线上元素的row + col为定值, 且各不相同            usedDiag45[row + col] = true;            // 同一135°斜线上元素row - col为定值, 且各不相同            // row - col 值有正有负, 加 n - 1 是为了对齐零点            usedDiag135[row - col + n - 1] = true;            // 递归            backTracking(board, n, row + 1);            usedCol[col] = false;            usedDiag45[row + col] = false;            usedDiag135[row - col + n - 1] = false;        }    }}\n\n解数独解决该题，主要是使用二重回溯，即在回溯函数中，使用二重循环遍历集合\n回溯class Solution {    public void solveSudoku(char[][] board) {        solveSudokuHelper(board);    }    private boolean solveSudokuHelper(char[][] board){        //「一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，        // 一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！」        for (int i = 0; i &lt; 9; i++){ // 遍历行            for (int j = 0; j &lt; 9; j++){ // 遍历列                if (board[i][j] != '.'){ // 跳过原始数字                    continue;                }                for (char k = '1'; k &lt;= '9'; k++){ // (i, j) 这个位置放k是否合适                    if (isValidSudoku(i, j, k, board)){                        board[i][j] = k;                        if (solveSudokuHelper(board)){ // 如果找到合适一组立刻返回                            return true;                        }                        board[i][j] = '.';                    }                }                // 9个数都试完了，都不行，那么就返回false                return false;                // 因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！                // 那么会直接返回， 「这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！」            }        }        // 遍历完没有返回false，说明找到了合适棋盘位置了        return true;    }    /**     * 判断棋盘是否合法有如下三个维度:     *     同行是否重复     *     同列是否重复     *     9宫格里是否重复     */    private boolean isValidSudoku(int row, int col, char val, char[][] board){        // 同行是否重复        for (int i = 0; i &lt; 9; i++){            if (board[row][i] == val){                return false;            }        }        // 同列是否重复        for (int j = 0; j &lt; 9; j++){            if (board[j][col] == val){                return false;            }        }        // 9宫格里是否重复        int startRow = (row / 3) * 3;        int startCol = (col / 3) * 3;        for (int i = startRow; i &lt; startRow + 3; i++){            for (int j = startCol; j &lt; startCol + 3; j++){                if (board[i][j] == val){                    return false;                }            }        }        return true;    }}\n\n总结回溯是递归的副产品，只要有递归就会有回溯。\n回溯法就是暴力搜索，并不是高效算法，最多配合剪枝，提高搜索效率。\n回溯算法主要解决如下问题：\n\n组合问题：N个数里面按一定规则找出k个数的集合\n排列问题：N个数按一定规则全排列，有几种排列方式\n切割问题：一个字符串按一定规则有几种切割方式\n子集问题：一个N个数的集合里有多少符合条件的子集\n棋盘问题：N皇后，解数独等等\n\n\n参考文章代码随想录\n","categories":["代码随想录","回溯算法"],"tags":["回溯","算法"]},{"title":"在排序数组中查找元素的第一个和最后一个位置_34","url":"/2023/11/26/%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-34/","content":"在排序数组中查找元素的第一个和最后一个位置原题链接\n给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。\n如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n示例 1：\n输入：nums = [5,7,7,8,8,10], target = 8输出：[3,4]\n\n示例 2：\n输入：nums = [5,7,7,8,8,10], target = 6输出：[-1,-1]\n\n示例 3：\n输入：nums = [], target = 0输出：[-1,-1]\n\n提示：\n\n0 &lt;= nums.length &lt;= 105\n-109 &lt;= nums[i] &lt;= 109\nnums 是一个非递减数组\n-109 &lt;= target &lt;= 109\n\n解题解法一解题思路：\n\n根据题目 “nums是一个非递减数组”，即nums是升序排列的数组，需要查找元素位置，可以考虑使用二分来进行查找\n\n对于寻找target再数组中的位置，主要有3种情况：\n\ntarget在数组范围的右边或左边，例如{3, 4, 5}, target=2，或者数组{3, 4, 5},target=6，应该返回{-1, -1}。\ntarget在数组范围中，且数组中不存在target，应该返回{-1, -1}。\ntarget在数组范围中，且数组中存在target，此时应该返回{第一个位置,最后一个位置}\n\n\n我们使用第一种二分来寻找边界\n\n\n实现代码如下：\nclass Solution {    public int[] searchRange(int[] nums, int target) {        // 获取 target 的右边界且不包含target        int rightBorder = getRightBorder(nums, target);        // 获取 target 的左边界且不包含target        int leftBorder = getLeftBorder(nums, target);        if (rightBorder == -2 || leftBorder == -2) {            // 说明target在数组范围的左边或右边            return new int[]{-1, -1};        }        rightBorder -= 1;        leftBorder += 1;        if (nums[rightBorder] != target || nums[leftBorder] != target) {            // 说明target在数组范围内 但不在数组中            return new int[]{-1, -1};        }        return new int[]{leftBorder, rightBorder};    }    // 二分法寻找target的左边界 且不包含target    // 使用第一种二分 左闭右闭 [left, right]    // 若leftBorder没有被赋值 说明target在数组范围的右边    private int getLeftBorder(int[] nums, int target) {        int leftBorder = -2;\t// 记录左边界的值 且检验是否被赋值        int left = 0;        int right = nums.length -1;        while (left &lt;= right) {        // left == right 有意义            int mid = ((right - left) &gt;&gt; 1) + left;\t\t// 防止溢出            if (nums[mid] &lt; target) {                left = mid + 1;            } else {                right = mid - 1;                leftBorder = right;            }        }        return leftBorder;    }    // 二分查找寻找target的右边界 且不包含target    // 使用第一种二分 左闭右闭[left, right]    // 若rightBorder没有被赋值 说明target在数组范围的左边    private int getRightBorder(int[] nums, int target) {        int rightBorder = -2;\t\t// 记录rightBorder是否被赋值 即是否有搜索到右边界        int left = 0;        int right = nums.length - 1;        while (left &lt;= right) {\t\t// 左闭右闭 left==right 有意义            int mid = ((right - left) &gt;&gt; 1) + left;\t\t// 防止溢出            if (nums[mid] &gt; target) {                // nums[mid] &gt; target 说明目标值在 左区间[left, mid-1]                right = mid - 1;            } else {                // nums[mid] &lt;= target 说明右边界在右区间                // 当 nums[mid] == target 时 对右边界进行更新 得到不包含target的右边界                left = mid + 1;                rightBorder = left;            }        }        return rightBorder;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.7 MB,击败了8.19% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(log n)\n空间复杂度：O(1)\n\n总结：\n首先想清楚target情况，然后根据情况来进行分块解决，同时对于二分查找里区间的变化以及所获得的区间的意义要有清楚的认识。\n解法二思路分析：\n\n对于target是否存在数组中的情况，我们可以先用二分查找确认数组是否在数组中\n若数组不在数组中，直接返回{-1, -1}即可\n若数组在数组中，可以通过指针循环来查找对应位置\n\n实现代码如下：\nclass Solution {    public int[] searchRange(int[] nums, int target) {       // 解法二       // 二分查找 数组中是否存在目标值       int flag = searchBinary(nums, target);       if (flag == -1) {          return new int[]{-1, -1};       }       // 如果存在 则滑动指针来寻找       int right = flag;     // 根据查找到的位置来寻找右边界       while (right + 1 &lt; nums.length &amp;&amp; nums[right + 1] == target)          ++ right;       int left = flag;      // 根据查找到的位置来寻找左边界       while (left - 1 &gt;= 0 &amp;&amp; nums[left - 1] == target)          -- left;       return new int[]{left, right};    }    // 二分查找    private int searchBinary(int[] nums, int target) {       int left = 0;       int right = nums.length - 1;       while (left &lt;= right) {          int mid = ((right - left) &gt;&gt; 1) + left;          if (nums[mid] &gt; target) {             right = mid - 1;          } else if (nums[mid] &lt; target) {             left = mid + 1;          } else {             return mid;          }       }       return -1;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.5 MB,击败了28.63% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(log n + n) ，二分查找时间复杂度为O(log n)，最后通过滑动指针来寻找边界的时间复杂度为O(n)\n空间复杂度：O(1)\n\n","categories":["leetcode"],"tags":["刷题","数组","二分查找"]},{"title":"基础篇.1数据库概述与MySQL安装","url":"/2024/01/03/%E5%9F%BA%E7%A1%80%E7%AF%87-1%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0%E4%B8%8EMySQL%E5%AE%89%E8%A3%85/","content":"数据库概述为什么要使用数据库\n持久化(persistence)：把数据保存到可掉电式存储设备中以供之后使用，数据持久化意味着将内存中的数据保存到硬盘上加以“固化”\n\n持久化的主要作用是：将内存中的数据存储在关系型数据库中，也可以存储在磁盘文件、XML数据文件中。\n\n\n例子如下：\n\n数据库与数据库管理系统数据库的相关概念\n\n\nDB\n数据库（Database）\n\n\n\n\n即存储数据的“仓库”，其本质是一个文件系统；保存了一系列有组织的数据\n\n\nDBMS\n数据库管理系统（DataBase Management System）\n\n\n\n一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，对数据库进行统一管理和控制；用户通过数据库管理系统访问数据库中表内的数据\n\n\nSQL\n结构化查询语言（Structured Query Language）\n\n\n\n用来与数据库通信的语言\n\n\n数据库与数据库管理系统的关系数据库管理系统(DBMS)可以管理多个数据库，一般针对一个应用创建一个数据库，为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体用户的数据。\n数据库管理系统、数据库和表的关系如下图所示：\n\n常见的DBMS排名目前互联网上常见的数据库管理软件有Oracle、MySQL、MS SQL Server、DB2、PostgreSQL、Access、Sybase、Informix这几种。\nDB-Engines Ranking：对各数据库受欢迎程度进行调查统计。\n常见的DBMS介绍Oracle1979 年，Oracle 2 诞生，它是第一个商用的 RDBMS（关系型数据库管理系统）。随着 Oracle 软件的名气越来越大，公司也改名叫 Oracle 公司。2007年，总计85亿美金收购BEA Systems。2009年，总计74亿美金收购SUN。此前的2008年，SUN以10亿美金收购MySQL。意味着Oracle 同时拥有了MySQL 的管理权，至此 Oracle 在数据库领域中成为绝对的领导者。2013年，甲骨文超越IBM，成为继Microsoft后全球第二大软件公司。如今 Oracle 的年收入达到了 400 亿美金，足以证明商用（收费）数据库软件的价值。\nSQL ServerSQL Server 是微软开发的大型商业数据库，诞生于 1989 年。C#、.net等语言常使用，与WinNT完全集成，也可以很好地与Microsoft BackOffice产品集成。\nDB2IBM公司的数据库产品,收费的。常应用在银行系统中。\nPostgreSQLPostgreSQL 的稳定性极强，最符合SQL标准，开放源码，具备商业级DBMS质量。PG对数据量大的文本以及SQL处理较快。\nSQLite嵌入式的小型数据库，应用在手机端。 零配置，SQlite3不用安装，不用配置，不用启动，关闭或者配置数据库实例。当系统崩溃后不用做任何恢复操作，再下次使用数据库的时候自动恢复。\ninformixIBM公司出品，取自Information 和Unix的结合，它是第一个被移植到Linux上的商业数据库产品。仅运行于unix/linux平台，命令行操作。 性能较高，支持集群，适应于安全性要求极高的系统，尤其是银行，证券系统的应用。\nMySQL介绍概述\nMySQL是一个开放源代码的关系型数据库管理系统，由瑞典MySQL AB（创始人Michael Widenius）公司1995年开发，迅速成为开源数据库的 No.1。\n\n2008被Sun 收购（10亿美金），2009年Sun被Oracle 收购。MariaDB 应运而生。（MySQL 的创造者担心 MySQL 有闭源的风险，因此创建了 MySQL 的分支项目 MariaDB）\n\nMySQL6.x 版本之后分为社区版和商业版。\n\nMySQL是一种关联数据库管理系统，将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\nMySQL是开源的，所以你不需要支付额外的费用。\n\nMySQL是可以定制的，采用了GPL（GNU General Public License） 协议，你可以修改源码来开发自己的MySQL系统。\n\nMySQL支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\n\nMySQL支持大型数据库，支持5000万条记录的数据仓库，32位系统表文件最大可支持4GB ，64位系统支持最大的表文件为8TB 。\n\nMySQL使用标准的SQL数据语言形式。\n\nMySQL可以允许运行于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java、Perl、PHP和Ruby等。\n\n\nMySQL发展史重大事件MySQL的历史就是整个互联网的发展史。互联网业务从社交领域、电商领域到金融领域的发展，推动着应用对数据库的需求提升，对传统的数据库服务能力提出了挑战。高并发、高性能、高可用、轻资源、易维护、易扩展的需求，促进了MySQL的长足发展。\n发展历程思维导图如下：\nhttps://github.com/YTAZWC/picx-images-hosting/raw/master/尚硅谷MySQL入门到高级_基础篇/image.4gio790nsye0.webp\n关于MySQL 8.0MySQL从5.7版本直接跳跃发布了8.0版本\nMySQL 8版本在功能上做了显著的改进与增强，开发者对MySQL的源代码进行了重构，最突出的一点是多MySQL Optimizer优化器进行了改进。不仅在速度上得到了改善，还为用户带来了更好的性能和更棒的体验。\n为什么很多厂商选择MySQL\n开放源代码，使用成本低。\n性能卓越，服务稳定。\n软件体积小，使用简单，并且易于维护。\n历史悠久，社区用户非常活跃，遇到问题可以寻求帮助。\n许多互联网公司在用，经过了时间的验证。\n\nOracle vs MySQLOracle 更适合大型跨国企业的使用，因为他们对费用不敏感，但是对性能要求以及安全性有更高的要求。\nMySQL 由于其体积小、速度快、总体拥有成本低，可处理上千万条记录的大型数据库，尤其是开放源码这一特点，使得很多互联网公司、中小型网站选择了MySQL作为网站数据库（Facebook，Twitter，YouTube，阿里巴巴/蚂蚁金服，去哪儿，美团外卖，腾讯）。\nRDBMS 与 非RDBMS从排名中我们能看出来，关系型数据库绝对是DBMS的主流，其中使用最多的DBMS分别是Oracle、MySQL和SQL Server，这些都是关系型数据库（RDBMS）\n关系型数据库(RDBMS)实质\n这种类型的数据库是最古老的数据库类型，关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。\n\n关系型数据库以行(row)和列(column)的形式存储数据，以便于用户理解。这一系列的行和列被称为表，一组组成了一个库(database)\n\n表与表之间的数据记录有关系(relationship)，现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。关系型数据库，建立在关系模型基础上的数据库。\n\nSQL就是关系型数据库的查询语言。\n\n\n优势\n复杂查询 可以用SQL语句方便在一个表以及多个表之间做非常复杂的数据查询。\n\n事务支持 是的对于安全性能很高的数据访问要求得以实现。\n\n\n非关系型数据库(非RDBMS)介绍非关系型数据，看成传统关系型数据库的功能阉割版本，基于键值对存储数据，不需要经过SQL层的解析，性能非常高。同时，减少不常用的功能，来进一步提高性能。\n有哪些 非RDBMS相比于 SQL，NoSQL 泛指非关系型数据库，包括了榜单上的键值型数据库、文档型数据库、搜索引擎和列存储等，除此以外还包括图形数据库。也只有用 NoSQL 一词才能将这些技术囊括进来。\n键值型数据库\n通过Key-Value键值方式来存储数据，其中key和Value可以是简单的对象，也可以是复杂的对象。\n\nKey 作为唯一的标识符，优点是查找速度快，明显优于关系型数据库，缺点是无法像关系型数据库一样使用条件过滤 (比如WHERE)\n\n容易出现不知道去哪里找数据，要遍历所有键，会消耗大量的计算问题。\n\n\n键值型数据库的典型使用场景：内存缓存。Redis是最流行的键值型数据库。\n文档型数据库此类数据库可存放并获取文档，可以是XML、JSON等格式。在数据库中文档作为处理信息的基本单位，一个文档就相当于一条记录。文档数据库所存放的文档，就相当于键值数据库所存放的“值”。\nMongoDB是最流行的文档型数据库。此外，还有CouchDB等。\n搜索引擎数据库虽然关系型数据库采用了索引提升检索效率，但是针对全文索引效率却较低。搜索引擎数据库是应用在搜索引擎领域的数据存储形式，由于搜索引擎会爬取大量的数据，并以特定的格式进行存储，这样在检索的时候才能保证性能最优。核心原理是 “倒排索引”。\n典型产品：Solr、Elasticsearch、Splunk 等\n列式数据库列式数据库是相对于行式存储的数据库，Oracle、MySQL、SQL Server 等数据库都是采用的行式存储（Row-based），而列式数据库是将数据按照列存储到数据库中，这样做的好处是可以大量降低系统的I/O，适合于分布式文件系统，不足在于功能相对有限。\n典型产品：HBase等。\n图形数据库图形数据库，利用了图这种数据结构存储了实体（对象）之间的关系。图形数据库最典型的例子就是社交网络中人与人的关系，数据模型主要是以节点和边（关系）来实现，特点在于能高效地解决复杂的关系问题。\n图形数据库顾名思义，就是一种存储图形关系的数据库。它利用了图这种数据结构存储了实体（对象）之间的关系。\n关系型数据用于存储明确关系的数据，但对于复杂关系的数据存储却有些力不从心。如社交网络中人物之间的关系，如果用关系型数据库则非常复杂，用图形数据库将非常简单。\n典型产品：Neo4J、InfoGrid等。\nNoSQL的演变NoSQL对SQL做出了很好的补充，比如实际开发中，有很多业务需求，其实并不需要完整的关系型数据库功能，非关系型数据库的功能就足够使用了。这种情况下，使用性能更高、成本更低的非关系型数据库当然是更明智的选择。\n比如：日志收集、排行榜、定时器等。\n关系型数据库设计规则\n关系型数据库的典型数据结构就是 数据表，这些数据表的组成都是结构化的(Structured)\n\n将数据放到表中，表再放到库中。\n\n一个数据库中有多个表，每个表都有一个名字，用来标识自己。表名具有唯一性。\n\n表具有一些特性，这些特性定义了数据在表中如何存储，类似Java和Python中 “类”的设计。\n\n\n表、记录、字段\nE-R（entity-relationship, 实体-联系）模型中三个主要概念：实体集、属性、联系集\n\n一个实体集（class）对应于数据库中的一个表（table）\n\n一个实体（instance）则对应于数据库表中的一行（row），也称为一条记录（record）。\n\n一个属性（attribute）对应于数据库表中的一列（column），也称为一个字段（field）\n\n\nORM思想：\n\n数据库中一个表 &lt;===&gt; Java或Python中的一个类\n\n表中一条数据 &lt;===&gt; 类的实体\n\n表中的一个列 &lt;===&gt; 类中的一个字段、属性(field)\n\n\n表的关系关系\n表语表之间的数据记录有关系，现实世界中的各种实体以及实体之间的各种联系均用关系模型来表示。\n\n一对一关联(one-to-one)\n实际开发应用不多，因为一对一可以创建成一张表\n\n举例：设计学生表：学号、姓名、手机号码、班级、系别、身份证号码、家庭住址、籍贯、紧急联系人、…\n\n拆为两个表：两个表的记录是一一对应关系。\n\n基础信息表（常用信息）：学号、姓名、手机号码、班级、系别\n\n档案信息表（不常用信息）：学号、身份证号码、家庭住址、籍贯、紧急联系人、…\n\n\n\n两种建表原则：\n\n外键唯一：主表的主键和从表的外键（唯一），形成主外键关系，外键唯一。\n\n外键是主键：主表的主键和从表的主键，形成主外键关系。\n\n\n\n\n具体例子如下图：\n\n一对多关系(one-to-many)\n常见实例场景： 客户表和订单表， 分类表和商品表， 部门表和员工表。\n\n举例：\n\n员工表：编号、姓名、…、所属部门\n\n部门表：(部门)编号、名称、简介\n\n\n\n一对多建表原则：在从表(多方)创建一个字段，字段作为外键指向主表(一方)的主键\n\n\n\n多对多(many-to-many)要表示多对多关系，必须创建第三个表，该表通常称为联接表，它将多对多关系划分为两个一对多关系。将这两个表的主键都插入到第三个表中。\n\n举例：学生-课程\n\n学生信息表：一行代表一个学生的信息（学号、姓名、手机号码、班级、系别…）\n\n课程信息表：一行代表一个课程的信息（课程编号、授课老师、简介…）\n\n选课信息表：一个学生可以选多门课，一门课可以被多个学生选择\n\n\n\n\n自我引用(Self reference)如下图所示：\n\nMySQL环境搭建停止MySQL服务先停止MySQL8.0的服务。按键盘上的“Ctrl + Alt + Delete”组合键，打开“任务管理器”对话框，可以在“服务”列表找到“MySQL8.0”的服务，如果现在“正在运行”状态，可以右键单击服务，选择“停止”选项停止MySQL8.0的服务，如图所示\n","categories":["尚硅谷MySQL入门到高级","基础篇"],"tags":["MySQL"]},{"title":"基础篇.2SQL之SELECT使用篇","url":"/2024/01/03/%E5%9F%BA%E7%A1%80%E7%AF%87-2SQL%E4%B9%8BSELECT%E4%BD%BF%E7%94%A8%E7%AF%87/","content":"基本的SELECT语句SQL概述SQL 是用于访问和处理数据库的标准的计算机语言\nSQL分类在语言功能上分为如下3大类：\n\n**DDL(Data Definition Languages 数据定义语言)**：这些语句定义了不同的数据库、表、视图、索引等数据库对象，还可以用来创建、删除、修改数据库和数据表的结构。\n主要语句关键字包括 create、DROP、ALTER等\n\n\n**DML(Data Manipulation Language 数据操作语言)**：用于添加、删除、更新和查询数据库记录，并检查数据完整性。\n主要的语句关键字包括INSERT 、 DELETE 、 UPDATE 、 SELECT 等。\nSELECT是SQL语言的基础，最为重要。\n\n\nDCL(Data Control Language、数据控制语言)： 用于定义数据库、表、字段、用户的访问权限和安全级别。\n主要的语句关键字包括 GRANT 、 REVOKE 、 COMMIT 、 ROLLBACK 、 SAVEPOINT 等。\n\n\n\n\n因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类：DQL（数据查询语言）。还有单独将 COMMIT 、 ROLLBACK 取出来称为TCL （Transaction Control Language，事务控制语言）。\n\nSQL语言的规则和规范基本规则\nSQL可以写在一行或多行；为了提高可读性。各子句分行写，必要时使用缩进\n\n每条语句以;或\\g或\\G结束\n\n关键字不能被缩写也不能分行\n\n关于标点符号\n\n必须保证所有的()、单引号、双引号是成对结束的\n\n必须使用英文状态下的半角输入方式\n\n字符串型和日期时间类型的数据可以使用单引号(‘’)表示\n\n列的别名，尽量使用双引号(“”)，而不建议省略as\n\n\n\n\nSQL大小写规范(建议遵守)\nMySQL在Windows下大小写不敏感\n\nMySQL在Linux环境下是大小写敏感\n\n数据库名、表名、表的别名、变量名是严格区分大小时写的\n\n关键字、函数名、列名(或字段名)、列的别名(字段的别名)是忽略大小写的\n\n\n\n推荐采用统一的书写规范\n\n数据库名、表名、表别名、字段名、字段别名等都小写\n\nSQL关键字、函数名、绑定变量等都大写\n\n\n\n\n注释按照如下格式的注释结构\n单行注释：#注释文字单行注释：-- 注释文字(--后必须有一个空格)多行注释：/* 注释文字 */\n\n命名规则（暂时了解）\n数据库、表名不得超过30个字符，变量名限制为29个\n\n必须只能包含 A–Z, a–z, 0–9, _共63个字符\n\n数据库名、表名、字段名等对象名中间不要包含空格\n\n同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段\n\n不能重名\n\n必须保证你的字段没有和保留字、数据库系统或常用方法冲突。如果坚持使用，请在\n\nSQL语句中使用`（着重号）引起来保持字段名和类型的一致性，在命名字段并为其指定数据类型的时候一定要保证一致性。假如数据类型在一个表里是整数，那在另一个表里可就别变成字符型了\n\n\n数据导入指令方式1(命令行中)source 文件的全路径名，示例如下：\nsource F:\\atguigudb.sql\n\n方式2借助图形界面工具 执行sql脚本\n基本的SELECT语句SELECT…SELECT 1+1, 3+2;\n\nSELECT…FROM…SELECT      标识选择哪些列\nFROM        标识从哪个表中选择\nSELECT 1+1, 3+2FROM DUAL;        # dual 伪表SELECT employee_id, last_name, salary    # 选择特定的列FROM employees;SELECT *        # 选择所有列FROM employees;\n\n列的别名\n重命名一个列，便于计算\n\n建议别名简短，见名知意\n\n别名紧跟列名，可以在列名和别名之间加入关键字AS(可省略)\n\n别名可以用双引号标识，以便在别名中包含格或特殊的字符并区分大小写\n\n\n示例如下：\nSELECT employee_id emp_id, last_name AS lname, department_id \"部门id\"FROM employees;\n\n去除重复行关键字：DISTINCT\nSELECT DISTINCT department_id        # DISTINCT 查询去重FROM employees;# 不会报错 查询出没实际意义SELECT DISTINCT department_id, salary   # (department_id, salary)整体不重复FROM employees;\n\n空值参与运算空值：null\n所有运算符或列值遇到null值，运算结果都为null。\n解决运算的空值，IFNULL(a, b)函数，如果a为null则使用b参与运算。\nSELECT employee_id, salary \"月工资\", salary * (1+IFNULL(commission_pct, 0)) * 12 \"年工资\"FROM employees;\n\n着重号用于避免表名或字段与关键字相等的情况，即：表名，示例如下\nSELECT * FROM `order`;\n\n查询常数即对查询结果，增加一列自定义的固定的常数，示例如下：\nSELECT '尚硅谷', 123, employee_id, last_nameFROM employees;\n\n显示表结构显示表中字段的详细信息，示例如下：\nDESCRIBE employees;或DESC departments;\n\n查询结果如下：\n\n\nField：表示字段名称。\n\nType：表示字段类型，这里 barcode、goodsname 是文本型的，price 是整数类型的。\n\nNull：表示该列是否可以存储NULL值。\n\nKey：表示该列是否已编制索引。PRI表示该列是表主键的一部分；UNI表示该列是UNIQUE索引的一部分；MUL表示在列中某个给定值允许出现多次。\n\nDefault：表示该列是否有默认值，如果有，那么值是多少。\n\nExtra：表示可以获取的与给定列有关的附加信息，例如AUTO_INCREMENT等\n\n\n过滤数据使用where过滤，示例如下：\nSELECT *FROM employeesWHERE department_id = 90;        # 过滤条件\n\n运算符算术运算符算术运算符主要用于数学运算，其可以连接运算符前后的两个数值或表达式，对数值或表达式进行运算。\n\n\n\n运算符\n名称\n作用\n示例\n\n\n\n+\n加法运算符\n计算两个值或表达式的和\nSELECT A + B\n\n\n-\n减法运算符\n计算两个值或表达式的差\nSELECT A - B\n\n\n*\n乘法运算符\n计算两个值或表达式乘积\nSELECT A * B\n\n\n/ 或 DIV\n除法运算符\n计算两个值或表达式的商\nSELECT A / B或SELECT A DIV B\n\n\n% 或 MOD\n求模运算符\n计算两个值或表达式的余数\nSELECT A % B或SELECT A MOD B\n\n\n示例如下：\nSELECT 100, 100 + 0, 100 - 0, 100 + 50, 100 + 50 * 30, 100 + 35.5, 100 - 35.5FROM DUAL;SELECT 100 + '1'       # 会将字符串隐式转换为数值FROM DUAL;SELECT 100 + 'a'    # 将'a'看做0FROM DUAL;\n\n比较运算符比较运算符用来对表达式左边的操作数和右边的操作数进行比较，结果为真返回1，为假返回0，其他情况返回NULL。\n比较运算符经常被用来作为SELECT查询语句的条件来使用，返回符合条件的结果记录。\n\n\n\n运算符\n名称\n作用\n示例\n\n\n\n=\n等于运算符\n判断两个值、字符串或表达式是否相等\nSELECT C FROM TABLE WHERE A = B\n\n\n&lt;=&gt;\n安全等于运算符\n安全地判断两个值、字符串或表达式是否相等；可以用来比较 NULL\nSELECT C FROM TABLE WHERE A &lt;=&gt; B\n\n\n&lt;&gt;(!=)\n不等于运算符\n判断两个值、字符串或表达式是否不相等\nSELECT C FROM TABLE WHERE A &lt;&gt; B 或 SELECT C FROM TABLE WHERE A != B\n\n\n&lt;\n小于运算符\n判断前面的值、字符串或表达式是否小于后面的值、字符串或表达式\nSELECT C FROM TABLE WHERE A &lt; B\n\n\n&lt;=\n小于等于运算符\n判断前面的值、字符串或表达式是否小于等于后面的值、字符串或表达式\nSELECT C FROM TABLE WHERE A &lt;= B\n\n\n&gt;\n大于运算符\n判断前面的值、字符串或表达式是否大于后面的值、字符串或表达式\nSELECT C FROM TABLE WHERE A &gt; B\n\n\n&gt;=\n大于等于运算符\n判断前面的值、字符串或表达式是否大于等于后面的值、字符串或表达式\nSELECT C FROM TABLE WHERE A &gt;= B\n\n\n示例如下：\n# 比较运算符SELECT 1 = 2, 1 != 2, 1 = '1', 1 = 'a', 0 = 'a'   # 字符串存在隐式转换 转换不成功视为0FROM DUAL;SELECT 'a' = 'a', 'ab' = 'ab', 'a' = 'b'    # 字符串之间比较 不会隐式转换FROM DUAL;SELECT 1 = NULL, NULL = NULL        # 只要有NULL参与判断 结果就为 NULLFROM DUAL;SELECT last_name, salaryFROM employees# WHERE salary = 6000;WHERE commission_pct = NULL;    # 此时执行 不会有任何的结果SELECT 1 &lt;=&gt; 2, 1 &lt;=&gt; '1', 1 &lt;=&gt; 'a', 0 &lt;=&gt; 'a'FROM DUAL;SELECT 1 &lt;=&gt; NULL, NULL &lt;=&gt; NULL        # &lt;=&gt; 可以比较nullFROM DUAL;SELECT last_name, salaryFROM employeesWHERE commission_pct &lt;=&gt; NULL;        # 查询表中 commission_pct为null的数据SELECT 3 &lt;&gt; 2, '4' &lt;&gt; NULL, '' &lt;&gt; NULL, NULL != NULLFROM DUAL;\n\n除了符号表示的比较运算符，还有非符号类型的运算符：\n\n\n\n运算符\n名称\n作用\n示例\n\n\n\nIS NULL\n为空运算符\n判断值、字符串或表达式是否为空\nSELECT B FROM TABLE WHERE A IS NULL\n\n\nIS NOT NULL\n不为空运算符\n判断值、字符串或表达式是否不为空\nSELECT B FROM TABLE WHERE A IS NOT NULL\n\n\nLEAST\n最小值运算符\n在多个值中返回最小值\nSELECT D FROM TABLE WHERE C LEAST(A, B)\n\n\nGREATEST\n最大值运算符\n在多个值中返回最大值\nSELECT D FROM TABLE WHERE C GREATEST(A, B)\n\n\nBETWEEN AND\n两值之间的运算符\n判断一个值是否在两个值之间\nSELECT D FROM TABLE WHERE C BETWEEN A AND B\n\n\nISNULL\n为空运算符\n判断一个值、字符串或表达式是否为空\nSELECT B FROM TABLE WHERE A ISNULL\n\n\nIN\n属于运算符\n判断一个值是否为列表中的任意一个值\nSELECT D FROM TABLE WHERE C IN (A, B)\n\n\nNOT IN\n不属于运算符\n判断一个值是否不是一个列表中的任意一个值\nSELECT D FROM TABLE WHERE C NOT IN (A, B)\n\n\nLIKE\n模糊匹配运算符\n判断一个值是否符合模糊匹配规则\nSELECT C FROM TABLE WHERE A LIKE B\n\n\nREGEXP\n正则表达式运算符\n判断一个值是否符合正则表达式的规则\nSELECT C FROM TABLE WHERE A REGEXP B\n\n\nRLIKE\n正则表达式运算符\n判断一个值是否符合正则表达式的规则\nSELECT C FROM TABLE A RLIKE B\n\n\n示例如下：\nSELECT last_name, salary, commission_pctFROM employeesWHERE commission_pct IS NULL;SELECT LEAST('g', 'b', 't', 'm'), GREATEST('g', 'b', 't', 'm')FROM DUAL;SELECT employee_id, last_name, salaryFROM employeesWHERE salary BETWEEN 6000 AND 8000;SELECT last_name, salary, department_idFROM employeesWHERE department_id IN (10, 20, 30);SELECT last_nameFROM employeesWHERE last_name LIKE '%a%';        # % 代表不确定个数的字符SELECT last_nameFROM employeesWHERE last_name LIKE '%a%e%' OR last_name LIKE '%e%a%';SELECT last_nameFROM employeesWHERE last_name LIKE '_a%';        # _ 代表一个不确定的字符SELECT last_nameFROM employeesWHERE last_name LIKE '_\\_a%';    # \\ 转义字符 \\_ 等同于字符'_'SELECT 'shkstart' REGEXP '^s', 'shkstart' REGEXP 't$', 'shkstart' REGEXP 'hk';\n\n逻辑运算符逻辑运算符主要用来判断表达式的真假，MySQL支持四种逻辑运算符如下：\n\n\n\n运算符\n作用\n示例\n\n\n\nNOT 或 !\n逻辑非\nSELECT NOT A\n\n\nAND 或 &amp;&amp;\n逻辑与\nSEKECT A AND B\n\n\nOR 或 |\n\n逻辑或\n\n\nXOR\n逻辑异或\nＳＥＬＥＣＴ　Ａ　ＸＯＲ　Ｂ\n\n\n示例如下:\nSELECT last_name, salary, department_idFROM employeesWHERE department_id = 10 OR department_id = 20;SELECT last_name, salary, department_idFROM employeesWHERE department_id = 50 XOR salary &gt; 6000;\n\n位运算符位运算符是在二进制数上进行计算的运算符,位运算符会先将操作数变成二进制数,然后进行位运算,最后将二进制变回十进制数.\nMySQL支持的位运算符如下:\n\n\n\n运算符\n作用\n示例\n\n\n\n&amp;\n按位与(位AND)\nSELECT A &amp; B\n\n\n\n\n按位或(位OR)\n\n\n^\n按位异或(位XOR)\nSELECT A ^ B\n\n\n~\n按位取反\nSELECT ~A\n\n\n&gt;&gt;\n按位右移\nSELECT A &gt;&gt; 2\n\n\n&lt;&lt;\n按位左移\nSELECT A &lt;&lt; 2\n\n\n示例如下:\nSELECT 12 &amp; 5, 12 | 5, 12 ^ 5FROM DUAL;SELECT 10 &amp; ~1FROM DUAL;SELECT 4 &lt;&lt; 1, 8 &gt;&gt; 1FROM DUAL;\n\n运算符的优先级正则表达式常用通配符如下:\n\n（1）‘^’匹配以该字符后面的字符开头的字符串。（2）‘$’匹配以该字符前面的字符结尾的字符串。（3）‘.’匹配任何一个单字符。（4）“[…]”匹配在方括号内的任何字符。例如，“[abc]”匹配“a”或“b”或“c”。为了命名字符的范围，使用一个‘-’。“[a-z]”匹配任何字母，而“[0-9]”匹配任何数字。（5）‘’匹配零个或多个在它前面的字符。例如，“x”匹配任何数量的‘x’字符，“[0-9]”匹配任何数量的数字，而“”匹配任何数量的任何字符。\n\n排序与分页如果没有使用排序操作,默认情况下查询返回的数据是按照添加数据的顺序显示的.\n排序数据排序规则\n使用 ORDER BY 子句排序\n\nASC:  升序\n\nDESC:  降序\n\n\n\nORDER BY 子句在SELECT语句的结尾.\n\n\n单列排序示例如下:\n# 降序SELECT employee_id, last_name, salaryFROM employeesORDER BY salary DESC;# 升序   默认按升序排列SELECT employee_id, last_name, salaryFROM employeesORDER BY salary ASC;# 使用列的别名 进行排序SELECT employee_id, salary, salary * 12 AS \"annual_sal\"FROM employeesORDER BY annual_sal;        # 列的别名只能在ORDER BY 中使用 不能在 WHERE 中使用SELECT employee_id, salaryFROM employeesWHERE department_id IN (50, 60, 70)        # WHERE在FORM之后  ORDER BY之前\n\n多列排序示例如下:\nSELECT employee_id, salary, department_idFROM employeesORDER BY department_id DESC, salary ASC;\n\n分页即将数据库中的结果集, 一段一段显示出来需要的条件.\nMySQL中使用LIMIT实现分页.且格式如下:\nLIMIT [位置偏移量], 行数\n\n示例如下:\nSELECT last_name,salaryFROM employeesWHERE salary NOT BETWEEN 8000 AND 17000ORDER BY salary DESCLIMIT 20,20;\n\n多表查询多表查询，也称为关联查询，指两个或更多个表一起完成查询操作。\n前提：这些一起查询的表之间是有关系的(一对一、一对多)；他们之间一定有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。\n比如：员工表和部门表，这两个表依靠“部门编号”进行关联。\n笛卡尔积(交叉连接)笛卡尔乘积是一个数学运算。假设我有两个集合 X 和 Y，那么 X 和 Y 的笛卡尔积就是 X 和 Y 的所有可能组合，也就是第一个对象来自于 X，第二个对象来自于 Y 的所有可能。组合的个数即为两个集合中元素个数的乘积数。\nSQL92中，笛卡尔积也称为 交叉连接 ，英文是 CROSS JOIN 。在 SQL99 中也是使用 CROSS JOIN表示交叉连接。它的作用就是可以把任意表进行连接，即使这两张表不相关。\n\n笛卡尔积的错误会在下面条件下产生：\n\n省略多个表的连接条件（或关联条件）\n\n连接条件（或关联条件）无效\n\n所有表中的所有行互相连接\n\n\n\n为了避免笛卡尔积， 可以在 WHERE 加入有效的连接条件\n\n\n加入条件后，查询语法如下：\nSELECT table1.column, table2.columnFROM table1, table2WHERE table1.column1 = table2.column2; #连接条件\n\n在表中有相同列时，在列名之前加上表名前缀。\n示例如下：\n# 查询语句中出现多个表中都存在的字段，必须指明此字段所在的表SELECT employee_id, department_name, employees.department_idFROM employees, departmentsWHERE employees.department_id = departments.department_id;\n\n建议：从SQL优化角度，建议多表查询时，每个字段前都指明其所在的表。\n为了缩小SELECT语句的长度，提高可读性，可以给表取别名，示例如下：\nSELECT emp.employee_id, dept.department_name, emp.department_idFROM employees emp, departments deptWHERE emp.department_id = dept.department_id;\n\n且给表取了别名后，则必须使用表的别名，不能再使用原来的表名。\n","categories":["尚硅谷MySQL入门到高级","基础篇"],"tags":["MySQL"]},{"title":"字母异位词分组_49","url":"/2023/12/10/%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84-49/","content":"字母异位词分组49. 字母异位词分组 - 力扣（LeetCode）\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1:\n输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"]输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]\n示例 2:\n输入: strs = [\"\"]输出: [[“”]]\n示例 3:\n输入: strs = [\"a\"]输出: [[“a”]]\n提示：\n\n\n\nstrs[i] 仅包含小写字母\n\n解法一(HashMap+排序)思路分析：\n\n对于 满足 字符串中的字符 按字母顺序排序后的 字符串相同的 字符串为一组，因此我们可以使用哈希表来进行保存\n\n若对于一个字符串str，将其按照字母顺序重新排序后的字符串string，其在哈希表中出现过，则将str保存到哈希表中对应的列表中\n\n若没有出现过，则需要创建新的字符串列表，并进行保存\n\n遍历完字符串数组strs时，则完成了分组\n\n\n实现代码如下：\nclass Solution {    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {        // 哈希表 统计字母异位词 出现的 字符串        HashMap&lt;String, List&lt;String&gt;&gt; hashString = new HashMap&lt;&gt;();        for (String str : strs) {    // 遍历数组strs            char[] charArray = str.toCharArray();    // 将字符串转化为字符数组            Arrays.sort(charArray);        // 对字符数组进行排序            String string = Arrays.toString(charArray);    // 将排序好的字符数组转化为字符串            List&lt;String&gt; stringList;    // 保存 相互为字母异位词的 字符串            if (hashString.containsKey(string)) {    // 若哈希表中已存在该种字母异位词                stringList = hashString.get(string);    // 则将保存列表返回            } else {                stringList = new ArrayList&lt;&gt;();        // 否则创建新列表            }            stringList.add(str);    // 将该字符串保存到对应的 字母异位词列表中            hashString.put(string, stringList); // 并保存到哈希表        }        return new ArrayList&lt;&gt;(hashString.values());    // 将哈希表中的结果返回    }}\n\n提交结果如下：\n解答成功:    执行耗时:9 ms,击败了30.66% 的Java用户    内存消耗:46.4 MB,击败了8.04% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，其中，m为每个字符串的长度，排序花费，将其转化为字符数组和重新转化为字符串花费，n指的是字符串数组strs的长度\n\n空间复杂度：\n\n\n解法二(HashMap+计数)思路分析：\n\n对于属于同一组字符异位词，除了按照规定顺序排序之后，可作为标识之外，还可以对其含有的字符进行计数，然后将其包含的字符和数目合并为一个标识字符串\n\n如此，即可作为map的关键值\n\n\n实现代码如下：\nclass Solution {    public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) {        // 哈希表 统计字母异位词 出现的 字符串        HashMap&lt;String, List&lt;String&gt;&gt; hashString = new HashMap&lt;&gt;();        for (String str : strs) {    // 遍历数组strs            // 获取字符统计结果字符串            String recordsByString = getRecordsByString(str);            List&lt;String&gt; strsList = hashString.getOrDefault(recordsByString, new ArrayList&lt;&gt;());            strsList.add(str);    // 将其添加到哈希表的值中            hashString.put(recordsByString, strsList);        }        return new ArrayList&lt;&gt;(hashString.values());    // 将哈希表中的结果返回    }    // 对字符串出现的字符及数量进行统计    // 将统计的字符 及其数目 拼接成字符串返回    public String getRecordsByString(String str) {        int[] records = new int[26];        int len = str.length();        for (int i = 0; i &lt; len; ++i) {            records[ str.charAt(i) - 'a' ] ++;        }        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 26; ++i) {            if (records[i] != 0) {                sb.append(i+'a');                sb.append(records[i]);            }        }        return sb.toString();    }}\n\n提交结果如下：\n解答成功:    执行耗时:9 ms,击败了30.66% 的Java用户    内存消耗:46 MB,击败了19.57% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n为数组strs的长度，k是strs中字符的最大长度，，遍历每个字符串时，还需要遍历一遍统计数组，其长度为26\n\n空间复杂度：，需要用哈希表来存储，n为数组strs长度，k则是字符串的长度，此外还有生成的哈希表的键\n\n\n","categories":["leetcode"],"tags":["刷题","数组","排序","哈希表","字符串"]},{"title":"字符串","url":"/2023/12/16/%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"字符串例题反转字符串反转字符串_344\n反转字符串 II反转字符串II_541\n    对于如何计数2k个字符，只需每次将指针i移动2k步即可，同时在剩余字符大于k时，将每次移动i所找到的新的字符串的前k个字符进行反转，剩余字符小于k，则反转剩余字符。\n    因此当需要固定规律一段一段去处理字符串的时候，想想在for循环的表达式上做文章。\n代码如下：\n//解法一class Solution {    public String reverseStr(String s, int k) {        StringBuffer res = new StringBuffer();        int length = s.length();        int start = 0;        while (start &lt; length) {            // 找到k处和2k处            StringBuffer temp = new StringBuffer();            // 与length进行判断，如果大于length了，那就将其置为length            int firstK = (start + k &gt; length) ? length : start + k;            int secondK = (start + (2 * k) &gt; length) ? length : start + (2 * k);            //无论start所处位置，至少会反转一次            temp.append(s.substring(start, firstK));            res.append(temp.reverse());            // 如果firstK到secondK之间有元素，这些元素直接放入res里即可。            if (firstK &lt; secondK) { //此时剩余长度一定大于k。                res.append(s.substring(firstK, secondK));            }            start += (2 * k);        }        return res.toString();    }}//解法二（似乎更容易理解点）//题目的意思其实概括为 每隔2k个反转前k个，尾数不够k个时候全部反转class Solution {    public String reverseStr(String s, int k) {        char[] ch = s.toCharArray();        for(int i = 0; i &lt; ch.length; i += 2 * k){            int start = i;            //这里是判断尾数够不够k个来取决end指针的位置            int end = Math.min(ch.length - 1, start + k - 1);            //用异或运算反转             while(start &lt; end){                ch[start] ^= ch[end];                ch[end] ^= ch[start];                ch[start] ^= ch[end];                start++;                end--;            }        }        return new String(ch);    }}// 解法二还可以用temp来交换数值，会的人更多些class Solution {    public String reverseStr(String s, int k) {        char[] ch = s.toCharArray();        for(int i = 0;i &lt; ch.length;i += 2 * k){            int start = i;            // 判断尾数够不够k个来取决end指针的位置            int end = Math.min(ch.length - 1,start + k - 1);            while(start &lt; end){                char temp = ch[start];                ch[start] = ch[end];                ch[end] = temp;                start++;                end--;            }        }        return new String(ch);    }}\n\n替换数字KamaCoder_54_替换数字\n反转字符串里的单词反转字符串的单词_151\n    不适用内置函数，且不使用辅助空间(Java等不能改变字符串的语言除外)，那么就只能在原有的字符串进行修改。\n即解题思路为：\n\n移除多余空格\n\n将整个字符串反转\n\n将每个单词反转\n\n\n代码如下：\n/* * 解法四：时间复杂度 O(n) * 参考卡哥 c++ 代码的三步骤：先移除多余空格，再将整个字符串反转，最后把单词逐个反转 * 有别于解法一 ：没有用 StringBuilder  实现，而是对 String 的 char[] 数组操作来实现以上三个步骤 */class Solution {    //用 char[] 来实现 String 的 removeExtraSpaces，reverse 操作    public String reverseWords(String s) {        char[] chars = s.toCharArray();        //1.去除首尾以及中间多余空格        chars = removeExtraSpaces(chars);        //2.整个字符串反转        reverse(chars, 0, chars.length - 1);        //3.单词反转        reverseEachWord(chars);        return new String(chars);    }    //1.用 快慢指针 去除首尾以及中间多余空格，可参考数组元素移除的题解    public char[] removeExtraSpaces(char[] chars) {        int slow = 0;        for (int fast = 0; fast &lt; chars.length; fast++) {            //先用 fast 移除所有空格            if (chars[fast] != ' ') {                //在用 slow 加空格。 除第一个单词外，单词末尾要加空格                if (slow != 0)                    chars[slow++] = ' ';                //fast 遇到空格或遍历到字符串末尾，就证明遍历完一个单词了                while (fast &lt; chars.length &amp;&amp; chars[fast] != ' ')                    chars[slow++] = chars[fast++];            }        }        //相当于 c++ 里的 resize()        char[] newChars = new char[slow];        System.arraycopy(chars, 0, newChars, 0, slow);         return newChars;    }    //双指针实现指定范围内字符串反转，可参考字符串反转题解    public void reverse(char[] chars, int left, int right) {        if (right &gt;= chars.length) {            System.out.println(\"set a wrong right\");            return;        }        while (left &lt; right) {            chars[left] ^= chars[right];            chars[right] ^= chars[left];            chars[left] ^= chars[right];            left++;            right--;        }    }    //3.单词反转    public void reverseEachWord(char[] chars) {        int start = 0;        //end &lt;= s.length() 这里的 = ，是为了让 end 永远指向单词末尾后一个位置，这样 reverse 的实参更好设置        for (int end = 0; end &lt;= chars.length; end++) {            // end 每次到单词末尾后的空格或串尾,开始反转单词            if (end == chars.length || chars[end] == ' ') {                reverse(chars, start, end - 1);                start = end + 1;            }        }    }}\n\n右旋字符串  KamaCoder_55_右旋字符串\n找出字符串中第一个匹配项的下标找出字符串中第一个匹配项的下标_28\nKMP算法经典思想：当出现字符串不匹配时，记录一部分之前已经匹配的文本内容，利用这些信息避免从头再来去做匹配。\n重点在于如何记录已经匹配的文本内容，即next数组。\nnext数组next数组是一个前缀表(prefix table)，主要用来回退，记录模式串与主串不匹配时，模式串应该从哪里开始重新匹配。\n即前缀表：记录下标i之前包括i的字符串中，最大长度的相同前缀后缀\n最长相等的前后缀\n前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。\n\n后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串\n\n\n为什么一定要用前缀表假如是匹配字符串如下：\n\n在模式串下标为5，指向f的时候不匹配，下标回退为2；\n即下标为5之前的字符串(aabaa)的最长相等的前缀和后缀子字符串aa，以及匹配，即后续在下标为5处出现匹配失败，即失败位置为后缀子串的后面，那么只需要跳到与 后缀子串 相同的前缀的后一个位置 重新开始匹配即可。\n即前缀表是有 在当前匹配位置失败时，可以跳回之前已经匹配过的位置的能力\n如何计算前缀表首先可以需要确认的是，模式串与前缀表对应位置的数字表示的是：下标i之前包括i的字符串中，有多大长度的相同前缀后缀。\n找到不批撇的位置，需要看它的前一个字符的前缀表的数值是多少。\n前缀表与next数组具体实现时，next数组与前缀表可以是多种关系；\n\n可以就是前缀表\n\n也可以是前缀表整体右移\n\n或者前缀表统一 减一或加一\n\n\n在使用next数组时，需要注意前缀表与next数组的关系，保持对应关系进行回退\n构造next数组采用next数组对应 前缀表右移一步 的关系\n构造next数组就是计算模式串s，前缀表的过程，主要有如下三步：\n\n初始化\n\n处理前后缀不相同的情况\n\n处理前后缀相同的情况\n\n\n1.初始化：\n定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。然后进行初始化赋值；即\nj = -1;next[0] = j;\n\n不难得出当子串长度为1时，此时前缀表对应的值应该为0，但是next数组此时对应前缀表右移一步，所以此时next[0] = -1，即此时next数组中next[i]表示的是不包含i对应字符的i之前的子串的 最长相同前后缀的值\n2.处理前后缀不相同的情况\ni指向后缀末尾位置，不包含第一个字符，所以i从1开始，与s[j+1]进行比较；\n且如果s[i]与s[j+1]不相同，即需要找j+1前一个元素在next数组里的值\nfor (int i = 1; i &gt; s.length; ++ i) {    while (j &gt;= 0 &amp;&amp; s[i] != s[j+1]) {        j = next[j]    }}\n\n3.处理后缀相同的情况\n如果相同，则说明找到相同前缀，同时向后移动i和j，且j表示前缀的长度，需要赋值给next[i]，因为next[i]需要记录相同前后缀的长度\nif (s[i] == s[j+1]) {    // 找到相同的前后缀    j ++ ;    }next[i] = j;\n\n最后构造next数组的函数代码如下：\npublic void getNext(int[] next, String s){    int j = -1;    next[0] = j;    for (int i = 1; i &lt; s.length; ++i) {        while (j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j+1)) {            j = next[j];        }        if (s.charAt(i) == s.charAt(j+1)) {            ++ j;        }        next[i] = j;    }}\n\nKMP具体代码实现在文本串s中 寻找是否出现过模式串t\n\n则定义两个下标 j指向模式串起始位置，i指向文本串起始位置，且j应该初始值为-1，因为前面求出的next数组记录的起始位置也是-1 保证循环不变量\n\ni从0开始遍历文本串，接下来则比较s[i]和t[j+1]，如果不相同，则j需要到next数组中寻找下一个匹配的位置，如果相同则i和j同时向后移动\n\n当j指向模式串末尾时，则说明文本串s出现了模式串t，即此时的下标i减去模式串t的长度即可得到文本串中出现模式串的第一个位置。\n\n\n代码如下：\nint j = -1;for (int i = 0; i &lt; s.length; ++i) {    while (j &gt;= 0 &amp;&amp; s.charAt(i) != t.charAt(j+1)) {        j = next[j];    }    if (s.charAt(i) == t.charAt(j+1))         ++j;    if (j == t.length-1)         return i-t.length+1;}\n\n前缀表不右移class Solution {    public int strStr(String haystack, String needle) {        int hLen = haystack.length();    // 字符串haystack的长度        int nLen = needle.length();        // 字符串needle的长度        int[] next = new int[nLen];        // 前缀表对应的数组 即就是前缀表        // 初始化next数组        getNext(next, needle);        // 进行判断 needle是否为haystack的子串        int j = 0;    // 与初始化next数组时的j对应        for (it i = 0; i &lt; hLen; ++i) {            while (j &gt; 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j)) {                j = next[j-1];            }            if (haystack.charAt(i) == needle.charAt(j))    // 匹配移动指针j                ++ j;            if (j == nLen) {    // 说明needle是haystack的子串                return i - nLen + 1;            }        }        return -1;    }    private void getNext(int[] next, String t) {        int j = 0;    // 从0开始        next[0] = j;        int n = t.length();        for (int i = 1; i &lt; n; ++ i) {            while (j &gt; 0 &amp;&amp; t.charAt(i) != t.charAt(j)) {                j = next[j-1];            }            if (t.charAt(i) == t.charAt(j))                ++ j;            next[i] = j;        }    }}\n\n前缀表右移class Solution {    public int strStr(String haystack, String needle) {        int hLen = haystack.length();    // 字符串haystack的长度        int nLen = needle.length();        // 字符串needle的长度        int[] next = new int[nLen];        // 前缀表对应的数组 即为 前缀表右移        // 初始化next数组        getNext(next, needle);        // 进行判断 needle是否为haystack的子串        int j = -1;    // 与初始化next数组时的j对应        for (int i = 0; i &lt; hLen; ++i) {            while (j &gt;= 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j+1)) {                j = next[j];            }            if (haystack.charAt(i) == needle.charAt(j+1))    // 匹配移动指针j                ++ j;            if (j == nLen-1) {    // 说明needle是haystack的子串                return i - nLen + 1;            }        }        return -1;    }    private void getNext(int[] next, String t) {        int j = -1;    // 从-1开始        next[0] = j;        int n = t.length();        for (int i = 1; i &lt; n; ++ i) {            while (j &gt;= 0 &amp;&amp; t.charAt(i) != t.charAt(j+1)) {                j = next[j];            }            if (t.charAt(i) == t.charAt(j+1))                ++ j;            next[i] = j;        }    }}\n\n重复的子字符串重复的子字符串_459\n数组长度减去最长相同前后缀的长度相当于是第一个周期的长度，也就是一个周期的长度，如果这个周期可以被整除，就说明整个数组就是这个周期的循环。\n实现代码如下：\nclass Solution {    public boolean repeatedSubstringPattern(String s) {        int n = s.length();    // 字符串s的长度        int[] next = new int[n];    // next数组对应s的前缀表 右移        int j = -1;        next[0] = j;        for (int i = 1; i &lt; n; ++i) {            while (j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j+1)) {                j = next[j];            }            if (s.charAt(i) == s.charAt(j+1)) {                ++ j;            }            next[i] = j;        }        // 因为next数组对应s的前缀表右移一位        // 所以next[n-1]表示的是s具有长度为next[n-1]的相同前后缀的值-1        // 所以计算时字符串s相同前后缀的长度为 next[n-1]+1        // 所以判断 n 与 n-next[n-1]-1        // 且需要注意next[n-1]+1 应该大于等于0 保证字符串s具有相同的前后缀        return next[n-1] &gt;= 0 &amp;&amp; n % (n - next[n - 1] - 1) == 0;    }}\n\n总结\n学习文章代码随想录 (programmercarl.com)\n","categories":["代码随想录","字符串"],"tags":["字符串","算法"]},{"title":"快乐数_202","url":"/2023/12/12/%E5%BF%AB%E4%B9%90%E6%95%B0-202/","content":"快乐数编写一个算法来判断一个数 n 是不是快乐数。\n「快乐数」 定义为：\n\n对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。\n然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。\n如果这个过程 结果为 1，那么这个数就是快乐数。\n\n如果 n 是 快乐数 就返回 true ；不是，则返回 false 。\n示例 1：\n输入： n = 19输出： true解释：\n示例 2：\n输入： n = 2输出： false\n提示：\n\n\n\n解法一(Set哈希+模拟)思路分析：\n\n对于一个正整数n，判断其是否为快乐数，我们可以模拟对于快乐数的定义，通过定义来判断一个数是否为快乐数\n\n同时假设一个数组116，在反复通过平方和计算下一个数字时，会得到58，然后经过一段运算后，58还会再次出现，由于回到了一个已经计算过的数字，因此可以发现这个过程存在一个循环，永远也不会回到1，即返回false\n\n所以可以猜测有以下三种可能\n\n最终会得到1\n\n进入循环\n\n值越来越大，最后接近无穷\n\n\n\n第三种情况可以推导不会发生(例举每一位数的最大数字的下一位数)\n\n因此对于算法主要分为两部分：\n\n对于一个数字，计算它的下一个数字\n\n根据算出来的一系列数字判断是否进入了循环\n\n\n\n对于第一部分，按照定义模拟即可，至于第二部分，使用哈希集合(HashSet)来完成，每生成一个数字，检查它是否在已知的哈希集合中\n\n如果在哈希集合中，则说明处于一个循环，返回false\n\n如果不在哈希集合中，可以继续推导，并将该数字加入到集合中\n\n\n\n\n实现代码如下：\nclass Solution {    public boolean isHappy(int n) {        HashSet&lt;Integer&gt; hashSet = new HashSet&lt;&gt;();        // 哈希集合 记录计算得到的数字判断是否进入循环        int x = n;        while (x != 1) {            if (hashSet.contains(x)) {    // 如若集合中存在该数 则进入循环 返回false                return false;            } else {                hashSet.add(x);        // 集合中不含有该元素 则保存该元素到集合中                // 计算下一位                int t = 0;                while (x != 0) {                    int y = x % 10;                    t += y * y;                    x /= 10;                }                x = t;    // 更新下一位判断的数值            }        }        return true;    }}\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法二(快慢双指针)思路分析：\n\n对于推导正整数n是否为快乐数得一系列过程中，所产生得一系列数可以构成一个隐式链表，并且将快乐数的最后结果1放在链表末尾。\n\n那么对于不快乐数的反复运算，会反复出现的系列数字 便构成了隐式链表中的环\n\n因此可以将快乐数问题转换为 判断隐式链表是否有环的问题\n\n那么如何判断链表是否有环，可以使用弗洛伊德查找算法，即快慢双指针法\n\n快指针每次走两步，慢指针每次走一步\n\n若存在环 则快指针一定能追上慢指针 即两个指针一定会相遇\n\n\n\n当两个指针相遇时，退出循环，若值为1则说明是快乐数，若值不为1则说明不是快乐数\n\n\n实现代码如下：\nclass Solution {    public boolean isHappy(int n) {        int fast = n;    // 快指针        int slow = n;    // 慢指针        do {            // 快指针移动            fast = bitSquareSum(fast);            fast = bitSquareSum(fast);            // 慢指针移动            slow = bitSquareSum(slow);        } while(fast != slow);        return slow == 1;    // 判断相遇时 是否为1    }    // 获取一个数的各个位上的 数的平方和    public int bitSquareSum(int x) {        int sum = 0;        while (x != 0) {            int t = x % 10;            sum += t * t;            x /= 10;        }        return sum;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:38.9 MB,击败了14.59% 的Java用户\n\n复杂度分析：\n\n时间复杂度：\n\n空间复杂度：\n\n\n解法三(面试不推荐)(数学+模拟)思路分析：\n\n因为HashMap的查询、插入等操作需要耗费不少时间，因此考虑尝试直接暴力模拟进行求解\n百度搜索快乐数得，若该数不为快乐数，则在反复计算中会陷入一个循环4→16→37→58→89→145→42→20→44，因此只要计算过程中出现数字4，那么直接返回false即可\n\n实现代码如下：\nclass Solution {    public boolean isHappy(int n) {        if (n == 1) {            return true;        }        int num = n;        while(num != 1) {            // 计算各个位 数的平方和            int sum = 0;            while (num != 0) {                int x = num % 10;                sum += x * x;                num /= 10;            }            num = sum;            if (num == 4) {                return false;            }        }        return true;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:38.7 MB,击败了27.83% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n指可能需要重复定义运算的次数，m则是每次循环得到的数的位数\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","哈希表","双指针","数学"]},{"title":"找出字符串中第一个匹配项的下标_28","url":"/2023/12/19/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87-28/","content":"找出字符串中第一个匹配项的下标 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。\n示例 1：\n输入： haystack = “sadbutsad”, needle = “sad”输出： 0解释：“sad” 在下标 0 和 6 处匹配。第一个匹配项的下标是 0 ，所以返回 0 。\n示例 2：\n输入： haystack = “leetcode”, needle = “leeto”输出：-1解释：“leeto” 没有在 “leetcode” 中出现，所以返回 -1 。\n提示：\n\n\nhaystack 和 needle 仅由小写英文字符组成\n\nRelated Topics\n\n双指针\n字符串\n字符串匹配\n\n解法一(KMP+前缀表不右移)思路分析：\n\n前缀表不右移，采用j初始化为0的kmp算法\n\n首先求出next数组，然后再根据next数组去判断haystack 是否有子串needle\n\n\n实现代码如下：\nclass Solution {    public int strStr(String haystack, String needle) {        int hLen = haystack.length();    // 字符串haystack的长度        int nLen = needle.length();        // 字符串needle的长度        int[] next = new int[nLen];        // 前缀表对应的数组 即就是前缀表        // 初始化next数组        getNext(next, needle);        // 进行判断 needle是否为haystack的子串        int j = 0;    // 与初始化next数组时的j对应        for (int i = 0; i &lt; hLen; ++i) {            while (j &gt; 0 &amp;&amp; haystack.charAt(i) != needle.charAt(j)) {                j = next[j-1];            }            if (haystack.charAt(i) == needle.charAt(j))    // 匹配移动指针j                ++ j;            if (j == nLen) {    // 说明needle是haystack的子串                return i - nLen + 1;            }        }        return -1;    }    private void getNext(int[] next, String t) {        int j = 0;    // 从0开始        next[0] = j;        int n = t.length();        for (int i = 1; i &lt; n; ++ i) {            while (j &gt; 0 &amp;&amp; t.charAt(i) != t.charAt(j)) {                j = next[j-1];            }            if (t.charAt(i) == t.charAt(j))                ++ j;            next[i] = j;        }    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.5 MB,击败了5.07% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，判断needle是haystack子串花费时间复杂度为，初始化next数组花费时间复杂度\n\n空间复杂度：，使用数组next花费空间复杂度\n\n\n","categories":["leetcode"],"tags":["刷题","字符串","双指针","字符串匹配"]},{"title":"找到字符串中所有字母异位词_438","url":"/2023/12/11/%E6%89%BE%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%89%80%E6%9C%89%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-438/","content":"找到字符串中所有字母异位词438. 找到字符串中所有字母异位词 - 力扣（LeetCode）\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。\n示例 1:\n输入: s = “cbaebabacd”, p = “abc”输出: [0,6]解释:起始索引等于 0 的子串是 “cba”, 它是 “abc” 的异位词。起始索引等于 6 的子串是 “bac”, 它是 “abc” 的异位词。\n示例 2:\n输入: s = “abab”, p = “ab”输出: [0,1,2]解释:起始索引等于 0 的子串是 “ab”, 它是 “ab” 的异位词。起始索引等于 1 的子串是 “ba”, 它是 “ab” 的异位词。起始索引等于 2 的子串是 “ab”, 它是 “ab” 的异位词。\n提示:\n\n\ns 和 p 仅包含小写字母\n\n解法一(计数标识)思路分析：\n\n首先考虑特殊情况，当s.length &lt; p.length时，s不存在异位词子串，返回null\n\n然后对字符串p中的字符进行计数，并拼接成一个字符串，即 异位词的 标识字符串。\n\n再对字符串s，进行遍历，寻找符合条件的子串\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; findAnagrams(String s, String p) {        int lenP = p.length();    // 字符串p的长度        int lenS = s.length();    // 字符串s的长度        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();    // 存储返回结果        // 存储标识        String flag = getFlagStr(p, 0, lenP);        // 遍历字符串s 寻找符合条件的异位词        for (int i = 0; i+lenP &lt;= lenS; ++i) {   // 遍历            String flagStr = getFlagStr(s, i, i+lenP);            if (flagStr.equals(flag)) {                ans.add(i);            }        }        return ans;    }    // 根据字符串中的字符及数量拼接成字符串 并返回    public String getFlagStr(String str, int start, int end) {        int[] count = new int[26];        for (int i = start; i &lt; end; ++i) {            count[ str.charAt(i) - 'a' ] ++;        }        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 26; ++i) {            if (count[i] &gt; 0) {                sb.append(i + 'a').append(count[i]);            }        }        return new String(sb);    }}\n\n提交结果如下：\n解答成功:    执行耗时:483 ms,击败了19.50% 的Java用户    内存消耗:43.3 MB,击败了41.64% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，其中n指字符串s的长度，m指字符串p的长度，不考虑equals()方法的时间复杂度，且，因为需要对26个字母进行计数\n\n空间复杂度：，其中返回结果最多存储n-m，此外还有计数数组，对于调用函数的开销不计算在内。\n\n\n解法二(滑动窗口+计数)思路分析：\n\n建立两个数组，并分别用来实时统计字符串s和p的字符，然后通过滑动窗口来改变统计字符串s的字符数量，如此减少了对一些字符的重复统计\n\n确认窗口长度为 p 字符串长度，然后sCount数组则为窗口内字符的统计\n\n每次将窗口向前移动一步，并动态改变窗口内的字符统计数组sCount\n\n移动窗口后，与异位词的pCount统计数组进行比较，为异位词则将窗口起始位置保存\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; findAnagrams(String s, String p) {        int lenP = p.length();    // 字符串p的长度        int lenS = s.length();    // 字符串s的长度        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();    // 存储返回结果        if (lenS &lt; lenP)     // 若字符串s的长度小于字符串p 则直接返回空列表            return ans;        int[] sCount = new int[26];        // 统计s中字符的计数数组        int[] pCount = new int[26];        // 统计p中字符的计数数组        // 统计p字符串的字符        for (int i = 0; i &lt; lenP; ++i) {            ++ pCount[p.charAt(i) - 'a'];            ++ sCount[s.charAt(i) - 'a'];    // 先统计s中起始索引为0长度为lenP的子串        }        if (Arrays.equals(sCount, pCount)) {            ans.add(0);        // 若子串符合要求 则存储其起始索引        }        for (int i = 0; i+lenP &lt; lenS; ++i) {            -- sCount[s.charAt(i) - 'a'];    // 排除左窗口起始位置的字符            ++ sCount[s.charAt(i+lenP) - 'a'];    // 新增右窗口处的字符            if (Arrays.equals(sCount, pCount)) {                ans.add(i+1);    // 窗口内子串 为异位词 则将起始位置保存            }        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:7 ms,击败了90.96% 的Java用户    内存消耗:42.5 MB,击败了91.01% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，m为字符串p的长度，n为字符串s的长度，∣Σ∣为统计数组的长度，每次判断s的字串是否与p为异位词，需要花费\n\n空间复杂度：，不包括返回结果的存储，使用了两个统计字符的数组来存储字符数目\n\n\n解法三(滑动窗口优化)思路分析：\n\n当两个字符串包含的字符及数目相同时，即符合异位词，因此对于s中的子串与字符串p的字符差异个数，可以使用一个变量distance来标记\n\n当distance为0时，则说明此时符合异位词，并将窗口的起始索引保存到返回值中。\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; findAnagrams(String s, String p) {        int lenP = p.length();    // 字符串p的长度        int lenS = s.length();    // 字符串s的长度        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();    // 存储返回结果        if (lenS &lt; lenP)     // 若字符串s的长度小于字符串p 则直接返回空列表            return ans;        int[] count = new int[26];    // 用于统计字符数        int distance = 0;    // 用于计数 s子串与字符串p的字符差异个数        for (int i = 0; i &lt; lenP; ++i) {            -- count[p.charAt(i) - 'a'];    // p 字符数减少            ++ count[s.charAt(i) - 'a'];    // s 字符数增加        }        for (int number : count) {    // 判断s中[0, lenP)的字串是否为 异位词            if (number != 0) {                ++ distance;            }        }        if (distance == 0) {    // 说明s中[0,lenP)的子串为异位词 将其起始索引保存            ans.add(0);        }        for (int i = 0; i+lenP &lt; lenS; ++i) {            // 排除左边界字符            int chL = s.charAt(i) - 'a';            -- count[chL];            if (count[chL] == -1) {    // 说明子串中该字符数目 由符合变不符合                ++ distance;    // 即不符合条件的字符数+1            } else if (count[chL] == 0) {    // 说明子串中该字符数 由不符合变符合                -- distance;    // 即符合条件的字符数-1            }            // 添加右边界字符            int chR = s.charAt(i+lenP) - 'a';            ++ count[chR];            if (count[chR] == 1) {    // 说明子串中该字符数目 由符合变不符合                ++ distance;    // 即不符合条件的字符数+1            } else if (count[chR] == 0) {    // 说明子串中该字符数 由不符合变符合                -- distance;    // 即不符合条件的字符数-1            }            // 判断新的子串是否 符合异位词            if (distance == 0) {                ans.add(i+1);            }        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:6 ms,击败了93.93% 的Java用户    内存消耗:42.7 MB,击败了66.14% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n为字符串s的长度，m为字符串p的长度，为初始化distance的时间复杂度\n\n空间复杂度：。用于存储滑动窗口和字符串 p 中每种字母数量的差。\n\n\n","categories":["leetcode"],"tags":["刷题","哈希表","字符串","滑动窗口"]},{"title":"搜索插入位置_35","url":"/2023/11/25/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-35/","content":"搜索插入位置原题链接\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n请必须使用时间复杂度为 O(log n) 的算法。\n示例 1:\n输入: nums = [1,3,5,6], target = 5输出: 2\n\n示例 2:\n输入: nums = [1,3,5,6], target = 2输出: 1\n\n示例 3:\n输入: nums = [1,3,5,6], target = 7输出: 4\n\n提示:\n\n1 &lt;= nums.length &lt;= 104\n-104 &lt;= nums[i] &lt;= 104\nnums 为 无重复元素 的 升序 排列数组\n-104 &lt;= target &lt;= 104\n\n解题思路分析：\n\n首先对题目进行分析，“nums为 无重复元素 的升序 排列数组 ”，那么根据题目可以考虑使用二分查找，在数组中查找目标值\n如果目标值target在数组中，那么直接返回目标值的索引。\n如果目标值target不在数组中，那么返回其按顺序插入的位置。\n在最后一次和left有关的查找中 mid指针指在刚好小于目标值的索引处\n因此left = mid+1 刚好将left指针指在target按顺序插入的位置处\n返回left的值即可\n\n\n\n实现代码如下：\nclass Solution {    public int searchInsert(int[] nums, int target) {        // 使用第一种二分法写法，区间左闭右闭        int left = 0;        int right = nums.length-1;        while (left &lt;= right) {            int mid = left + (right - left) / 2;            if (nums[mid] &gt; target) {                right = mid - 1;            } else if (nums[mid] &lt; target) {                left = mid + 1;            } else {                // 查找到对应位置 直接返回                return mid;            }        }        // 未找到对应位置，返回目标值按顺序插入的位置        // 在最后一次和left有关的查找中 mid指针指在刚好小于目标值的索引处        // 因此left = mid+1 刚好将left指针指在target按顺序插入的位置处        return left;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:42.6 MB,击败了5.01% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(log n)\n空间复杂度：O(1)\n\n","categories":["leetcode"],"tags":["刷题","数组","二分查找"]},{"title":"数组理论基础","url":"/2023/11/23/%E6%95%B0%E7%BB%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","content":"数组理论基础数组介绍数组是存放在连续空间上的相同类型数据的集合；且数组可以通过下标索引的方式获取到下标下对应的数据。如下图所示：\n\n注意：\n\n数组下标都是从0开始的。\n数组内存空间的地址是连续的。\n\n因为 数组的内存空间的地址是连续的，所以对数组增加元素或删除的时候，就需要移动其他元素的地址。 如下图所示：\n\n数组元素是不能删的，只能覆盖来改变数组。\nJava中的二维数组我们通过以下代码查看在Java中二维数组中每个元素的地址情况：\npublic class Main {    public static void main(String[] args) {        int[][] arr = {                { 1, 2, 3 },                { 3, 4, 5 },                { 6, 7, 8 },                { 9, 9, 9 }        };        System.out.println(arr[0]);        System.out.println(arr[1]);        System.out.println(arr[2]);        System.out.println(arr[3]);    }}\n\n输出结果如下：\n\n以上返回结果并不是真正的地址，而是处理过后的数值，但是也可以看出，二维数组的每一行头节点的地址是没有规则的，显然不是连续的。\n因为Java没有指针，同时也不对程序员暴露元素的地址，寻址操作完全交给虚拟机，所以看不到每个元素的地址情况，所以Java中二维数组在地址空间上不一定是连续的，也可能如下所示：\n\n例题二分查找例题链接\n总结使用二分查找的前提：\n\n数组为有序数组\n\n使用二分法的关键是：想清楚区间的定义，区间的定义就是不变量，要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。\n二分法第一种写法定义target在一个左闭右币的区间里，即 [left, right] \n区间定义决定二分法的写法，target在区间，所以有以下两点：\n\nwhile(left &lt;= right) 使用 &lt;=，因为 left == right是有意义的\nif (nums[middle] &gt; target) ,right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1\nleft同理\n\n\n实现代码如下：\nclass Solution {    public int search(int[] nums, int target) {        // 避免当 target 小于nums[0]， 或 大于nums[nums.length - 1]时多次循环运算        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) {            return -1;        }        int left = 0, right = nums.length - 1;        while (left &lt;= right) {            int mid = left + ((right - left) &gt;&gt; 1);        // 使用位运算，并避免了溢出            if (nums[mid] == target)                return mid;            else if (nums[mid] &lt; target)                left = mid + 1;            else if (nums[mid] &gt; target)                right = mid - 1;        }        return -1;    }}\n\n二分法第二种写法target定义在左闭右开的区间里，即[left, right)，则对于二分法的边界处理方式截然不同，有以下两点：\n\nwhile (left &lt; right)，这里使用 &lt; ,因为left == right在区间[left, right)是没有意义的\nif (nums[middle] &gt; target)，right更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]。\n\n\n实现代码如下：\nclass Solution {    public int search(int[] nums, int target) {        // 避免当 target 小于nums[0] 或 大于nums[nums.length - 1]时多次循环运算        if (target &lt; nums[0] || target &gt; nums[nums.length - 1]) {            return -1;        }        int left = 0, right = nums.length;        while (left &lt; right) {            int mid = left + ((right - left) &gt;&gt; 1);            if (nums[mid] == target)                return mid;            else if (nums[mid] &lt; target)                left = mid + 1;            else if (nums[mid] &gt; target)                right = mid;        }        return -1;    }}\n\n相关题目搜索插入位置_35\n在排序数组中查找元素的第一个和最后一个位置_34\nx的平方根_69\n有效的完全平方数_367\n移除元素题目链接\n注意：数组的元素在内存地址中时连续的，不能单独删除数组中的某个元素，只能覆盖。\n双指针法(快慢指针法)通过一个快指针fast和一个慢指针slow在一个for循环下完成两个for循环的工作。\n首先需要定义快慢指针：\n\n快指针：寻找新数组的元素，新数组即不含有目标元素的数据。\n慢指针：指向，需要更新的新数组元素的下标位置。\n\n实现代码如下：\nclass Solution {    public int removeElement(int[] nums, int val) {        // 快慢指针    不会改变元素的相对位置        int slowIndex = 0;        for (int fastIndex = 0; fastIndex &lt; nums.length; fastIndex++) {            if (nums[fastIndex] != val) {                nums[slowIndex] = nums[fastIndex];                slowIndex++;            }        }        return slowIndex;    }}\n\n双指针法在数组和链表的操作中是很常见的，在相关类型题目时，可以考虑双指针法，且双指针法的快慢指针法，不会改变 被移除元素的数组的 元素的相对位置。\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n双指针法(双向指针法)即指针left从数组左端开始遍历数组，指针right从数组右端开始遍历数组，从而实现移除数组元素。但是在实现移除数组元素的同时，也会改变数组元素的相对位置\n实现代码如下：\n//相向双指针法    改变了元素的相对位置class Solution {    public int removeElement(int[] nums, int val) {        int left = 0;        int right = nums.length - 1;        while(right &gt;= 0 &amp;&amp; nums[right] == val) right--; //将right移到从右数第一个值不为val的位置        while(left &lt;= right) {            if(nums[left] == val) { //left位置的元素需要移除                //将right位置的元素移到left（覆盖），right位置移除                nums[left] = nums[right];                right--;            }            left++;            while(right &gt;= 0 &amp;&amp; nums[right] == val) right--;        }        return left;    }}\n\n\n时间复杂度：O(n)\n空间复杂度：O(1)\n\n相关题目删除有序数组中的重复项_26\n移动零_283\n比较含退格的字符串\n有序数组的平方_977)\n长度最小的子数组原题链接\n滑动窗口所谓滑动窗口，即不断的调节子序列的起始位置和终止位置，从而的出最终结果。有点像是双指针。\n一般思考三点：\n\n窗口内是什么？\n如何移动窗口的起始位置？\n如何移动窗口的结束位置？\n\n实现代码如下：\nclass Solution {    // 滑动窗口    public int minSubArrayLen(int s, int[] nums) {        int left = 0;        int sum = 0;        int result = Integer.MAX_VALUE;        for (int right = 0; right &lt; nums.length; right++) {            sum += nums[right];            while (sum &gt;= s) {                result = Math.min(result, right - left + 1);                sum -= nums[left++];            }        }        return result == Integer.MAX_VALUE ? 0 : result;    }}\n\n相关题目水果成篮_904\n最小覆盖子串_76\n螺旋矩阵II题目链接\n解决该题需要遵循 循环不变量原则，必须按照固定规则来遍历循环\n模拟模拟顺时针画矩阵有以下过程：\n\n填充上行 从左到右\n\n填充右列 从上到下\n\n填充下行 从右到左\n\n填充左列 从下到上\n在模拟循环遍历的过程中，一定要遵循固定规则，即循环不变量。\n\n\n左闭右开模拟此处采用左闭右开的原则来遍历。且需要考虑n是否为奇数，实现代码如下：\nclass Solution {    public int[][] generateMatrix(int n) {        if (n == 1) return new int[][]{{1}};    // n为1时直接返回        int[][] ans = new int[n][n];        int loop = n/2;        // 需要旋转的圈数        int startX = 0;            // 定义每次循环起始位置x坐标        int startY = 0;            // 定义每次循环起始位置y坐标        int offset = 1;            // 控制每次遍历的长度        int mid = n/2;        // n为奇数时 需要给矩阵中点重新赋值        int i, j;        int count = 1;        // 采用左闭右开        while (loop &gt; 0) {            i = startX;            j = startY;            // 模拟上侧从左往右            for (j = startY; j &lt; n-offset; ++ j) {                ans[i][j] = count++;            }            // 模拟右侧从上往下            for (i = startX; i &lt; n-offset; ++i) {                ans[i][j] = count++;            }            // 模拟下侧从右往左            for (; j &gt; startY; --j) {                ans[i][j] = count++;            }            // 模拟左侧从下网上            for (; i &gt; startX; --i) {                ans[i][j] = count++;            }            startY++;    // 起始位置变化            startX++;            offset += 1;  // 遍历长度需要改变            loop--;        }        if (n % 2 == 1) ans[mid][mid] = count;        return ans;    }}\n\n左闭右闭+无需判断是否为奇数class Solution {    public int[][] generateMatrix(int n) {        if (n == 1) return new int[][]{{1}};    // n为1时直接返回        int[][] ans = new int[n][n];        int k = 1;        int t = 0;        // 上边 填入位置        int b = n-1;    // 下边 填入位置        int l = 0;        // 左边 填入位置        int r = n-1;    // 右边 填入位置        while (k &lt;= n*n) {            for (int i = l; i &lt;= r; ++i, ++k) {                // 向左    从左到右依次填入                ans[t][i] = k;            }            ++ t;    // 填完上边 则下次从下一行开始向左            for (int i = t; i &lt;= b; ++i, ++k) {                // 向下    从上到下依次填入                ans[i][r] = k;            }            -- r;    // 填完右边 则下次从左一列开始向下            for (int i = r; i &gt;= l; --i, ++k) {                // 向右    从右向左一依次填入                ans[b][i] = k;            }            -- b;    // 填完下边 则下次从上一行开始向右            for (int i = b; i &gt;= t; --i, ++k) {                // 向上    从下向上依次填入                ans[i][l] = k;            }            ++ l;    // 填完左边 则下次从右一列开始向上        }        return ans;    }}\n\n相关题目螺旋矩阵_54\nLCR_146_螺旋遍历二维数组\n总结\n学习文章代码随想录 (programmercarl.com)\n","categories":["代码随想录","数组"],"tags":["数组","算法"]},{"title":"最小覆盖子串_76","url":"/2023/12/02/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2-76/","content":"最小覆盖子串76. 最小覆盖子串 - 力扣（LeetCode）\n给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。\n注意：\n\n对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。\n如果 s 中存在这样的子串，我们保证它是唯一的答案。\n\n示例 1：\n输入：s = \"ADOBECODEBANC\", t = \"ABC\"输出：\"BANC\"解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。\n\n示例 2：\n输入：s = \"a\", t = \"a\"输出：\"a\"解释：整个字符串 s 是最小覆盖子串。\n\n示例 3:\n输入: s = \"a\", t = \"aa\"输出: \"\"解释: t 中两个字符 'a' 均应包含在 s 的子串中，因此没有符合条件的子字符串，返回空字符串。\n\n提示：\n\nm == s.length\nn == t.length\n1 &lt;= m, n &lt;= 10^5\ns 和 t 由英文字母组成\n\n进阶：你能设计一个在 o(m+n) 时间内解决此问题的算法吗？\n解题解法一(滑动窗口)思路分析：\n\n考虑暴力解法会超时，可以使用滑动窗口来解决，通过移动窗口右边界，寻找包含字符串t的s子串，当找到覆盖t的子串时，再移动左边界，将子串长度减小，直到为覆盖字符串t的最小长度。\n\n对于窗口区间确认为[left, right)，即子串长度为right-left，同时重点需要考虑的是：**如何确认s的子串是否已经覆盖了字符串t**，先将字符串t包含的字符及其数量进行统计，使用数组tNum进行统计，然后在寻找字串的过程中逐步统计子串中包含的字符及其数量，使用数组sWin进行统计。\n\n若直接使用统计的子串字符及数量和t的统计进行对比，也需要进行遍历对比，对时间消耗很大，因此使用一个变量distance来确认子串是否已经包含了t中的字符：\n\n在移动右边界，当子串增加了一个在t中的字符时，则令distance++，直到在子串中该字符的数目已经等于或大于在t中的字符数目时，该字符不再令dishtance增加。\n因此当distance == t.length()时，则说明子串已经覆盖了字符串t\n此时移动左边界，当左边界排除了一个在t中的字符时，若排除该字符前，子串中该字符数目等于t中该字符数目时，即sWin[s.charAt(left)] == tNum[s.charAt(left)]，该字符被排除，说明子串不再完全包含字符串t中字符，令distance--\n\n\n使用minLen来记录最小子串长度，使用begin来记录最小子串的起始索引，若minLen等于初始值，则说明不存在子串满足条件，返回空字符串，否则则将满足条件的子串返回。\n\n\n实现代码如下：\nclass Solution {    public String minWindow(String s, String t) {       int sLen = s.length();    // 获取字符串s的长度       int tLen = t.length();    // 获取字符串t的长度       int[] sWin = new int[128];    // 记录字符串s的字符频数       int[] tNum = new int[128];    // 记录字符串t的字符频数       // 将字符串转化为字符数组       char[] sCharArray = s.toCharArray();       // 对 t 中的字符数目 进行统计       for (int i = 0; i &lt; tLen; ++i) {          tNum[t.charAt(i)] ++;       }       // 定义窗口左右端点       int left = 0;       int right = 0;       // 记录s最小子串的长度       int minLen = Integer.MAX_VALUE;       // 记录s最小子串的起始索引       int begin = 0;       int distance = 0;     // 用于统计s的子串包含多少字符串t中的字符       // 定义区间为 [left, right)       while (right &lt; sLen) {          char chR = sCharArray[right];          if (tNum[chR] == 0) {  // 当右边界字符不在字符串t中时 直接继续添加下一位字符             // 该判断可省略             // 当移动左边界时 可将该字符排除             right++;             continue;          }          if (sWin[chR] &lt; tNum[chR]) {             // 当子串中包含该字符数少于字符串t时             // 即子串保存t中字符数加一             distance++;          }          sWin[chR]++; // 统计该字符          right ++;   // 移动右指针 保证窗口区间为 [left, right)          while (distance == tLen) { // 当s的子串包含字符串t的所有字符时 左边界开始移动             // 此时窗口区间为[left, right) 则窗口长度为 right-left             if (right -left &lt; minLen) {                minLen = right - left;                begin = left;             }             char chL = sCharArray[left];             if (tNum[chL] == 0) {                // 字符串t不包含该字符 直接移动                // 该判断可省略 与右边界移动循环判断处对应                left ++;                continue;             }             if (sWin[chL] == tNum[chL]) {                distance --;   // 左边界移动导致子串不再完全包含字符串t中的字符             }             sWin[chL] --;  // 排除该字符             left ++;   // 移动左边界          }       }       if (minLen == Integer.MAX_VALUE)          return \"\";    // 若minLen未发生改变 则没有符合条件的子串       return s.substring(begin, begin+minLen);    }}\n\n提交结果如下：\n解答成功:    执行耗时:2 ms,击败了99.00% 的Java用户    内存消耗:43 MB,击败了64.23% 的Java用户\n\n复杂度分析：\n\n时间复杂度分析：O(|S| + |T|)，首先需要遍历字符串t，统计其中字符及数量，然后窗口左右边界最极端情况下需要各自遍历一遍，同时将字符串s转换为字符串数组，函数内部需要遍历一次。\n\n空间复杂度分析：O(|S| + |T|)\n\n\n优化(+哈希表)优化思路：\n\n首先考虑字符频数数组，我们可以使用哈希表来统计字符频数，可以省略部分时间和空间，\n同时可以省略一些判断，让代码更加简洁，但是这会增加对于哈希表的操作(此处未省略)\n\n实现代码如下：\nclass Solution {    public String minWindow(String s, String t) {       int sLen = s.length();    // 字符串s的长度       int tLen = t.length();        // 字符串t的长度       HashMap&lt;Character, Integer&gt; tHash = new HashMap&lt;&gt;();   // 记录字符串t的字符频数       HashMap&lt;Character, Integer&gt; sHash = new HashMap&lt;&gt;();   // 记录字符串s的字符频数       // 先对字符t进行统计       for (int i = 0; i &lt; tLen; ++i) {          char ch = t.charAt(i);          tHash.put(ch, tHash.getOrDefault(ch, 0) + 1);       }       int left = 0;  // 定义窗口左边界       int minLen = Integer.MAX_VALUE;       // 用于记录更新最小子串长度       int begin = 0;    // 记录最小子串起始索引       int distance = 0;  // 记录子串包含字符串t字符的字符数       // 使用for循环代替while 更简洁 但是需要注意窗口区间 变化       for (int right = 0; right &lt; sLen; ++right) {          char chR = s.charAt(right);          if (!tHash.containsKey(chR))             continue;  // 可以减少很多不必要的比较和操作          if (sHash.getOrDefault(chR, 0) &lt; tHash.get(chR)) {             ++ distance;          }          sHash.put(chR, sHash.getOrDefault(chR, 0) + 1);          while (distance == tLen) {             // 此时窗口区间为[left, right]             if (right-left+1 &lt; minLen) {                minLen = right - left + 1;                begin = left;             }             char chL = s.charAt(left);             if (!tHash.containsKey(chL)) { // 若字符不在t中 则跳过记录到哈希中的步骤                left ++;                continue;             }             if (sHash.getOrDefault(chL, 0).equals(tHash.get(chL))) {                // 注意此处判断不能使用 ==                // 因为Integer引用类型变量   ==比较的是引用而非内容                -- distance;             }             sHash.put(chL, sHash.getOrDefault(chL, 0) - 1);             left ++;          }       }       if (minLen == Integer.MAX_VALUE) return \"\";       return s.substring(begin, begin+minLen);    }}\n\n提交结果如下：\n解答成功:    执行耗时:13 ms,击败了70.19% 的Java用户    内存消耗:43.6 MB,击败了13.80% 的Java用户\n\n总结：\n对于一个字符串是否包含另外一个字符串，在不需要考虑字符之间顺序的情况下，可以使用一个变量distance来记录，每当子串中多一个属于t的字符，让distance+1，当distance == t.length()时，即说明此时已包含字符串t，当然对于distance的增加，也需要考虑每个字符对应的数量，相等时不用再让distance+1，但仍需记录下该字符的数目，即sWin[chR]++，便于将该字符排除时不会误判。\n","categories":["leetcode"],"tags":["刷题","哈希表","字符串","滑动窗口"]},{"title":"有序数组的平方_977","url":"/2023/11/29/%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-977/","content":"有序数组的平方977. 有序数组的平方 - 力扣（LeetCode）\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n示例 1：\n输入：nums = [-4,-1,0,3,10]输出：[0,1,9,16,100]解释：平方后，数组变为 [16,1,0,9,100]排序后，数组变为 [0,1,9,16,100]\n\n示例 2：\n输入：nums = [-7,-3,2,3,11]输出：[4,9,9,49,121]\n\n提示：\n\n1 &lt;= nums.length &lt;= 104\n-104 &lt;= nums[i] &lt;= 104\nnums 已按 非递减顺序 排序\n\n进阶：\n\n请你设计时间复杂度为 O(n) 的算法解决本问题\n\n解题解法一(双指针)思路分析：\n\n首先注意题目信息，“nums是非递减顺序的数组”，且包含负数，因为nums内的数组是有一定顺序的，所以可以先找到数组中 负数 和 非负数的分界点。\n\n找到分界点后将数组分成了两个数组，指针i由分界点往前遍历数组，指针j由分界点往后遍历数组，最终对于i和j指向的值进行比较。\n\n若nums[i]*nums[i] &gt; nums[j]*nums[j] 则先将指针j指向的值平方后添加到新数组中，并j++。\n若nums[i]*nums[i] &lt;= nums[j]*nums[j] 则先将指针i指向的值平方后添加到新数组中，并i--。\n\n\n在执行完比较后，可能会出现还有元素未添加到新数组的情况，对此进行检验。\n\n\n实现代码如下：\nclass Solution {    public int[] sortedSquares(int[] nums) {       int[] ans = new int[nums.length];  // 新数组 用于存储排好序后的元素       int index = 0; // 新数组索引       int i = 0;    // 从分界处往前遍历的指针       int j = 0;    // 从分界处往后遍历的指针       int k = 0;       // 寻找分界       while (k &lt; nums.length &amp;&amp; nums[k] &lt; 0)          k++;       i = k-1;       j = k;       // 对i和j指向的数组元素进行比较 并添加到数组中       while (i &gt;= 0 &amp;&amp; j &lt; nums.length) {          if (nums[i]*nums[i] &gt; nums[j]*nums[j]) {             ans[index++] = nums[j]*nums[j];             j++;          } else {             ans[index++] = nums[i]*nums[i];             i--;          }       }       // 将还未添加元素继续添加到新数组中       while (i &gt;= 0) {          ans[index++] = nums[i]*nums[i];          i --;       }       while (j &lt; nums.length) {          ans[index++] = nums[j]*nums[j];          j ++;       }       return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了100.00% 的Java用户    内存消耗:44 MB,击败了13.70% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)\n空间复杂度：O(n)，需要创建一个新数组\n\n解法二(相向双指针)思路分析：\n\n根据解法一，可以不寻找负数和非负数的分界点，直接令指针i从0开始遍历，令指针j从数组末端开始遍历，即从最大的数开始添加到新数组中，这样可以避免寻找分界点，也使代码变得更加简介。\n\n代码实现如下：\nclass Solution {    public int[] sortedSquares(int[] nums) {       int[] ans = new int[nums.length];  // 新数组 用于存储排好序后的元素       int index = nums.length-1; // 新数组索引       for (int i = 0, j = nums.length-1; i &lt;= j;) {     // i等于j 保证双向指针相向遍历时相遇的点可以添加到新数组中          if (nums[i]*nums[i] &gt; nums[j]*nums[j]) {   // 选择先添加最大的值             ans[index--] = nums[i]*nums[i];       // 逆序添加到新数组中             i ++;          } else {             ans[index--] = nums[j]*nums[j];             j --;          }       }       return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了100.00% 的Java用户    内存消耗:43.9 MB,击败了23.22% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，会比解法一少 寻找分界点的开销\n空间复杂度：O(n)\n\n总结：\n当对于数组问题或字符串问题，正序可以解决时，或比较难解决时，可以尝试从相反的方向去思考和推导，也许会使问题能够简化。\n","categories":["leetcode"],"tags":["刷题","数组","排序","双指针"]},{"title":"有效的字母异位词_242","url":"/2023/12/10/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D-242/","content":"有效的字母异位词242. 有效的字母异位词 - 力扣（LeetCode）\n给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。\n注意： 若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。\n示例 1:\n输入: s = “anagram”, t = “nagaram”输出: true\n示例 2:\n输入: s = “rat”, t = “car”输出: false\n提示:\n\n\ns 和 t 仅包含小写字母\n\n进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？\n解题解法一(哈希表)思路分析：\n\n根据题意，首先想到字符串s和t的长度必须相等，若不相等，则不是 互为字母异位词\n\n再建立一个哈希表hashS存储s中的字符，并记录该字符的数量\n\n再对字符串t进行遍历，若出现hashS.getOrDefault(t.charAt(i),0).equals(0) == true则说明字符串s中不包含该字符，直接返回false\n\n直到对字符串t遍历结束，说明两个字符串互为字母异位词，返回true\n\n\n实现代码如下：\nclass Solution {    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) {            return false;    // 长度不一致 不为字母异位词 返回false        }        HashMap&lt;Character, Integer&gt; hashS = new HashMap&lt;&gt;();    // 统计字符串s        int lenT = s.length();    // 字符串t的长度        int lenS = s.length();    // 字符串s的长度        for (int i = 0; i &lt; lenS; ++i) {    // 统计字符串s            char chS = s.charAt(i);            hashS.put(chS, hashS.getOrDefault(chS, 0) + 1);        }        // 判断t是否与字符串s互为字母异位词        for (int i = 0; i &lt; lenT; ++i) {            char chT = t.charAt(i);            int chCount = hashS.getOrDefault(chT, 0);            if (chCount == 0) {        // 说明字符串t出现不满足条件的字符                return false;            } else {                -- chCount;    // 出现一次满足条件的字符 则排除一个字符                hashS.put(chT, chCount);            }        }        return true;    }}\n\n提交结果如下：\n解答成功:    执行耗时:13 ms,击败了25.95% 的Java用户    内存消耗:42.1 MB,击败了47.67% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n+m)，n为字符串s的长度，m为字符串t的长度\n\n空间复杂度：O(n)，n为字符串s的长度，另外一些常量级变量可以忽略\n\n\n注意： 使用hashMap能够满足题目进阶要求，如果将hashMap换成数组，则不一定能满足。\n解法二(排序)思路分析：\n\n互为异位词则等价于 【两个字符串按字母顺序排序后 相等】，所以可以对字符串s和t进行排序处理\n\n首先将两个字符串转化为字符数组，然后使用Arrays.sort()方法进行排序\n\n排序后再用Arrays.equals()方法判断是否相等\n\n\n实现代码如下：\nclass Solution {    public boolean isAnagram(String s, String t) {        if (s.length() != t.length()) {            return false;    // 长度不一致 不为字母异位词 返回false        }        // 将字符串s转化为字符数组        char[] sCharArray = s.toCharArray();        // 将字符串t转化为字符数组        char[] tCharArray = t.toCharArray();        // 对两个字符数组进行排序        Arrays.sort(sCharArray);        Arrays.sort(tCharArray);        // 进行判断是否相等        return Arrays.equals(sCharArray, tCharArray);    }}\n\n提交结果如下：\n解答成功:    执行耗时:3 ms,击败了83.53% 的Java用户    内存消耗:42.9 MB,击败了5.12% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n是字符串s的长度；排序的时间复杂度为，比较两个字符串是否相等时间复杂度为，因此总体复杂度为.\n\n空间复杂度：，排序需要的空间复杂度\n\n\n","categories":["leetcode"],"tags":["刷题","排序","哈希表","字符串"]},{"title":"有效的完全平方数_367","url":"/2023/11/27/%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-367/","content":"有效的完全平方数原题链接\n给你一个正整数 num 。如果 num 是一个完全平方数，则返回 true ，否则返回 false 。\n完全平方数 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。\n不能使用任何内置的库函数，如 sqrt 。\n示例 1：\n输入：num = 16输出：true解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。\n\n示例 2：\n输入：num = 14输出：false解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。\n\n提示：\n\n1 &lt;= num &lt;= 23^1 - 1\n\n解题解法一思路分析：\n\n根据题目1&lt;=num&lt;=2^31-1，得使用暴力求解循环遍历会超时，所以考虑使用二分寻找num的平方根\n通过二分求出对应的平方根后，进行检验，如果满足x*x = num则返回true，否则返回false。\n\n实现代码如下：\nclass Solution {    public boolean isPerfectSquare(int num) {       if (num == 1)          return true;   // 因为 1 是一个完全平方数 直接返回true       int start = 1;       int end = num / 2;       int ans = 0;       while (start &lt;= end) {    // 使用左闭右闭的二分写法          int mid = ((end - start) &gt;&gt; 1) + start;          if ((long)mid*mid &lt;= num) {             // 当mid*mid == num 时 保存算术平方根             // 若num的算术平方根含有小数 则ans 记录算术平方根向下取整 的值             ans = mid;             start = mid + 1;          } else {             // 算术平方根在左区间 则将右端点缩小             end = mid - 1;          }       }       return ans*ans == num;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:38.5 MB,击败了5.02% 的Java用户\n\n复杂度分析：\n\n时间复杂度： O(log num)\n空间复杂度：O(1)\n\n","categories":["leetcode"],"tags":["刷题","二分查找","数学"]},{"title":"有效的括号_20","url":"/2023/12/21/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-20/","content":"有效的括号给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。\n有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n每个右括号都有一个对应的相同类型的左括号。\n\n示例 1：\n输入： s = “()”输出： true\n示例 2：\n输入： s = “()[]{}”输出： true\n示例 3：\n输入： s = “(]”输出： false\n提示：\n\n\ns 仅由括号 '()[]{}' 组成\n\n解法一(栈+模拟)思路分析：\n\n使用栈来模拟括号配对，对字符串进行遍历；\n\n若字符为左括号，则进栈\n\n若字符为右括号，则出栈一个元素，并与此时遍历到的字符配对\n\n若配对，则继续遍历字符串\n\n若不配对，则返回false\n\n\n\n且需要出栈元素时，需要判断栈是否为空\n\n\n实现代码如下：\nclass Solution {    public boolean isValid(String s) {        int n = s.length();        // 字符串s的长度        if (n == 1)     // 只有一个字符时            return false;        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();        for (int i = 0; i &lt; n; ++i) {            char ch1 = s.charAt(i);            if (ch1 == '(' || ch1 == '[' || ch1 == '{')    {                // 若为左括号 则入栈                stack.push(ch1);            } else {                // 为右括号 则出栈一个元素                if (stack.empty()) return false;    // 若栈为空 则返回false                char ch2 = stack.pop();    // 出栈                if (    // 匹配括号是否配对                    (ch1 == ')' &amp;&amp; ch2 != '(') ||                    (ch1 == ']' &amp;&amp; ch2 != '[') ||                    (ch1 == '}' &amp;&amp; ch2 != '{')                ) {                    return false;                }            }        }        return stack.empty();    // 若此时栈为空 则说明字符串里括号成功匹配结束    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了98.53% 的Java用户    内存消耗:40.6 MB,击败了5.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，需要遍历字符串\n\n空间复杂度：，使用栈来存储字符串中的字符\n\n\n","categories":["leetcode"],"tags":["刷题","字符串","栈"]},{"title":"栈与队列","url":"/2023/12/20/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","content":"栈和队列理论基础队列是先进先出，栈是先进后出。\n栈理论知识栈又名堆栈，是一种运算受限的线性表，栈限制仅允许在表的一端进行插入和删除运算，该端称作栈顶，另一端则称为栈底。\n\n压栈：向一个栈插入新元素又称作进栈、入栈或压栈，即将新元素放到栈顶元素上面，使之成为新的栈顶元素\n\n出栈：从一个栈删除元素又称为出栈或退栈，即把栈顶元素删除，使其下一个元素成为新的栈顶元素\n\n栈的工作原理：先进后出，后进先出\n\n\n主要操作如下：\n\n\n方法\n功能\n\n\n\nStack()\n构造以一个空的栈\n\n\nE push(E e)\n将e入栈，并返回e\n\n\nE pop()\n将栈顶元素出栈并返回\n\n\nE peek()\n获取栈顶元素\n\n\nint size()\n获取栈中有效元素个数\n\n\nboolean empty()\n检测栈是否为空\n\n\n队列理论知识队列是一种特殊的线性表，特殊之处在于它只允许在前端(front)进行删除操作，而在表的后端(rear)进行插入操作，同时队列也是一种受操作限制的线性表，进行插入操作的端称为队尾，进行删除操作的端称为队头。\n队列中的数据元素又称为队列元素；\n\n入队：在队列中插入一个队列元素\n\n出队：在队列中删除一个队列元素\n\n队列只允许在一端插入，在另一端删除，所以队列被称为先进先出线性表\n\n\n队列使用在Java中，Queue是一个接口，底层是通过链表实现的。\n\n\n\n方法\n功能\n\n\n\nboolean offer(E e)\n入队列\n\n\nE poll()\n出队列\n\n\nE peek()\n获取对头元素\n\n\nint size()\n获取队列中有效元素个数\n\n\nboolean isEmpty()\n检测队列是否为空\n\n\n队列分类队列中常见的空间类型有两种：顺序结构和链式结构\n顺序队列队列的一种，队列的存在形式是队列中的元素是连续的，像数组一样。\n容易出现假溢出问题，即指看似内存中再存储不了元素了，但是此内存在理论上是可以使用的，内存被一些不合法的元素使用完了，从而造成一种溢出现象，但是此溢出是假溢出\n循环队列即首尾相连接的顺序存储队列；\n可以解决顺序队列中的假溢出问题，使得内存得到有效的利用。\n链式队列与顺序队列的存储方式不一样，采用链表进行存储\n双端队列又名double ended queue，双端队列没有队列和栈的限制，允许两端进行入队和出队操作，即元素可以从队头出队入队，也可以从队尾出队入队\n例题用栈实现队列确定两个栈，一个输入栈、一个输出栈。\n在push数据时，将数据放进输入栈即可，但在pop的时候，输出栈如果为空，则把进栈数据全部导入 输出栈，然后再从输出栈弹出数据，如果输出栈不为空，则直接从输出栈弹出数据。\n当输入栈和输出栈都为空时，确定队列为空\n实现代码如下：\nclass MyQueue {    Stack&lt;Integer&gt; stackIn;    Stack&lt;Integer&gt; stackOut;    /** Initialize your data structure here. */    public MyQueue() {        stackIn = new Stack&lt;&gt;(); // 负责进栈        stackOut = new Stack&lt;&gt;(); // 负责出栈    }    /** Push element x to the back of queue. */    public void push(int x) {        stackIn.push(x);    }    /** Removes the element from in front of queue and returns that element. */    public int pop() {            dumpstackIn();        return stackOut.pop();    }    /** Get the front element. */    public int peek() {        dumpstackIn();        return stackOut.peek();    }    /** Returns whether the queue is empty. */    public boolean empty() {        return stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();    }    // 如果stackOut为空，那么将stackIn中的元素全部放到stackOut中    private void dumpstackIn(){        if (!stackOut.isEmpty()) return;         while (!stackIn.isEmpty()){                stackOut.push(stackIn.pop());        }    }}\n\n总结对于一些功能相近的代码函数要抽象出来，不要进行大量的复制粘贴，很容易出问题；养成这样的好习惯。\n用队列实现栈两个(单向)队列一个队用作主要输入和输出的队列，另一个队列用于辅助，在将元素加入栈时，先将主队列元素保存到辅助队列中，然后将元素加入主队列，再将辅助队列元素重新输入主队列中，保证主队列元素顺序为 先进后出顺序。\n实现代码如下：\nclass MyStack {    Queue&lt;Integer&gt; queue1; // 和栈中保持一样元素的队列    Queue&lt;Integer&gt; queue2; // 辅助队列    /** Initialize your data structure here. */    public MyStack() {        queue1 = new LinkedList&lt;&gt;();        queue2 = new LinkedList&lt;&gt;();    }    /** Push element x onto stack. */    public void push(int x) {        queue2.offer(x); // 先放在辅助队列中        while (!queue1.isEmpty()){            queue2.offer(queue1.poll());        }        Queue&lt;Integer&gt; queueTemp;        queueTemp = queue1;        queue1 = queue2;        queue2 = queueTemp; // 最后交换queue1和queue2，将元素都放到queue1中    }    /** Removes the element on top of the stack and returns that element. */    public int pop() {        return queue1.poll(); // 因为queue1中的元素和栈中的保持一致，所以这个和下面两个的操作只看queue1即可    }    /** Get the top element. */    public int top() {        return queue1.peek();    }    /** Returns whether the stack is empty. */    public boolean empty() {        return queue1.isEmpty();    }}\n\n一个(单向)队列一个队列，在将元素入栈时，先将元素入队到队列末尾，再将该元素前的元素重新入队，保证队列中的顺序 为 先进后出顺序。\n实现代码如下：\nclass MyStack {    Queue&lt;Integer&gt; queue;    public MyStack() {        queue = new LinkedList&lt;&gt;();    }    //每 offer 一个数（A）进来，都重新排列，把这个数（A）放到队列的队首    public void push(int x) {        queue.offer(x);        int size = queue.size();        //移动除了 A 的其它数        while (size-- &gt; 1)            queue.offer(queue.poll());    }    public int pop() {        return queue.poll();    }    public int top() {        return queue.peek();    }    public boolean empty() {        return queue.isEmpty();    }}\n\n有效的括号栈在计算机领域中的应用非常广泛，比如说在Linux进入一个目录，系统时如何确认进入了某个目录的，就是栈的应用。\n由于栈结构的特殊性，非常适合做对称匹配类的题目；且在做题时，一定要分清楚匹配的情况，保证思路清晰\n对于该题，主要有三种不匹配的情况：\n\n字符串左方向的括号多余\n\n括号不多余，但是括号类型不匹配\n\n字符串里右方向的括号多余\n\n\n实现代码如下：\nclass Solution {    public boolean isValid(String s) {        Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;();        char ch;        for (int i = 0; i &lt; s.length(); i++) {            ch = s.charAt(i);            //碰到左括号，就把相应的右括号入栈            if (ch == '(') {                deque.push(')');            }else if (ch == '{') {                deque.push('}');            }else if (ch == '[') {                deque.push(']');            } else if (deque.isEmpty() || deque.peek() != ch) {                return false;            }else {//如果是右括号判断是否和栈顶元素匹配                deque.pop();            }        }        //最后判断栈中元素是否匹配        return deque.isEmpty();    }}\n\n删除字符串中的所有相邻重复项在删除相邻重复项的时候，我们需要知道当前遍历的元素，在前一位是不是也遍历过一样数值的元素；\n即用栈来存放遍历过的元素，当遍历当前的元素时，到栈中查看是不是遍历过相同数值的相邻元素，然后做对应删除操作。\n实现代码如下：\n使用Deque作为堆栈class Solution {    public String removeDuplicates(String S) {        //ArrayDeque会比LinkedList在除了删除元素这一点外会快一点        //参考：https://stackoverflow.com/questions/6163166/why-is-arraydeque-better-than-linkedlist        ArrayDeque&lt;Character&gt; deque = new ArrayDeque&lt;&gt;();        char ch;        for (int i = 0; i &lt; S.length(); i++) {            ch = S.charAt(i);            if (deque.isEmpty() || deque.peek() != ch) {                deque.push(ch);            } else {                deque.pop();            }        }        String str = \"\";        //剩余的元素即为不重复的元素        while (!deque.isEmpty()) {            str = deque.pop() + str;        }        return str;    }}\n\n直接字符串作为栈，省去栈转化为字符串的操作class Solution {    public String removeDuplicates(String s) {        // 将 res 当做栈        // 也可以用 StringBuilder 来修改字符串，速度更快        // StringBuilder res = new StringBuilder();        StringBuffer res = new StringBuffer();        // top为 res 的长度        int top = -1;        for (int i = 0; i &lt; s.length(); i++) {            char c = s.charAt(i);            // 当 top &gt; 0,即栈中有字符时，当前字符如果和栈中字符相等，弹出栈顶字符，同时 top--            if (top &gt;= 0 &amp;&amp; res.charAt(top) == c) {                res.deleteCharAt(top);                top--;            // 否则，将该字符 入栈，同时top++            } else {                res.append(c);                top++;            }        }        return res.toString();    }}\n\n双指针class Solution {    public String removeDuplicates(String s) {        char[] ch = s.toCharArray();        int fast = 0;        int slow = 0;        while(fast &lt; s.length()){            // 直接用fast指针覆盖slow指针的值            ch[slow] = ch[fast];            // 遇到前后相同值的，就跳过，即slow指针后退一步，下次循环就可以直接被覆盖掉了            if(slow &gt; 0 &amp;&amp; ch[slow] == ch[slow - 1]){                slow--;            }else{                slow++;            }            fast++;        }        return new String(ch,0,slow);    }}\n\n总结实现函数调用其实就需要用到递归，即递归的实现就是：每次递归调用都是把函数的局部变量、参数值和返回地址压入栈中，然后递归返回时，从栈顶弹出上一次递归的各项参数，这也是递归为什么可以返回上一层位置的原因。\n同时如果出现了无限递归，会导致系统调用栈溢出，即系统可能会输出Segmentation fault\n在企业项目开发中，应该尽量减少递归的使用，在项目比较大的时候，由于参数多，全局变量等等，使用递归很容易判断不充分return的条件，非常容易无限递归（或者递归层级过深），造成栈溢出错误（这种问题还不好排查！）\n逆波兰表达式栈与递归之间在某种程度上可以相互转换；同时结合二叉树的后序遍历，会发现逆波兰表达式中，将运算符作为中间节点，可以画出一个运算的二叉树。但是对于本题不用使用逆序遍历来解决。\n可以发现该题与删除字符串中的所有相邻重复项相似，每次进行一次运算都需要消耗两个数字，因此使用栈来模拟即可。\n实现代码如下：\nclass Solution {    public int evalRPN(String[] tokens) {        Deque&lt;Integer&gt; stack = new LinkedList();        for (String s : tokens) {            if (\"+\".equals(s)) {        // leetcode 内置jdk的问题，不能使用==判断字符串是否相等                stack.push(stack.pop() + stack.pop());      // 注意 - 和/ 需要特殊处理            } else if (\"-\".equals(s)) {                stack.push(-stack.pop() + stack.pop());            } else if (\"*\".equals(s)) {                stack.push(stack.pop() * stack.pop());            } else if (\"/\".equals(s)) {                int temp1 = stack.pop();                int temp2 = stack.pop();                stack.push(temp2 / temp1);            } else {                stack.push(Integer.valueOf(s));            }        }        return stack.pop();    }}\n\n题外话后缀表达式对于计算机来说更加友好，因为可以通过栈来理解我们的运算；利用栈直接按照顺序处理，不需要考虑计算优先级，也不需要回退。\n滑动窗口最大值    首先想到优先队列，但是大顶堆每次只能弹出最大值，无法移除其他数值，这样大顶堆内维护的可能不是滑动窗口里的数值了；\n    对于判断大顶堆内维护的数值是否在滑动窗口内需要使用一个二元组，考虑能否使用更简单的方式。\n单调队列其实队列没必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素即可，同时保证队列里的元素数值是由大到小的。\n即用于维护元素单调递减的队列就叫做单调队列，即单调递增或单调递减。\n设计单调队列时，pop和push操作保持如下规则：\n\npop(value)：如果窗口移除元素等于单调队列的出口元素，则队列弹出元素，否则不操作\n\npush(value)：如果push的元素value大于入口元素的数值，则将队列入口即队尾的元素弹出，不断重复比较，直到队尾元素大于新元素value或队列为空\n\n\n保持上述规则时，只需获取队列的队首元素，即可获得窗口内的最大值\n实现代码如下：\n//解法一//自定义数组class MyQueue {    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();    //弹出元素时，比较当前要弹出的数值是否等于队列出口的数值，如果相等则弹出    //同时判断队列当前是否为空    void poll(int val) {        if (!deque.isEmpty() &amp;&amp; val == deque.peek()) {            deque.poll();        }    }    //添加元素时，如果要添加的元素大于入口处的元素，就将入口元素弹出    //保证队列元素单调递减    //比如此时队列元素3,1，2将要入队，比1大，所以1弹出，此时队列：3,2    void add(int val) {        while (!deque.isEmpty() &amp;&amp; val &gt; deque.getLast()) {            deque.removeLast();        }        deque.add(val);    }    //队列队顶元素始终为最大值    int peek() {        return deque.peek();    }}class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        if (nums.length == 1) {            return nums;        }        int len = nums.length - k + 1;        //存放结果元素的数组        int[] res = new int[len];        int num = 0;        //自定义队列        MyQueue myQueue = new MyQueue();        //先将前k的元素放入队列        for (int i = 0; i &lt; k; i++) {            myQueue.add(nums[i]);        }        res[num++] = myQueue.peek();        for (int i = k; i &lt; nums.length; i++) {            //滑动窗口移除最前面的元素，移除是判断该元素是否放入队列            myQueue.poll(nums[i - k]);            //滑动窗口加入最后面的元素            myQueue.add(nums[i]);            //记录对应的最大值            res[num++] = myQueue.peek();        }        return res;    }}//解法二//利用双端队列手动实现单调队列/** * 用一个单调队列来存储对应的下标，每当窗口滑动的时候，直接取队列的头部指针对应的值放入结果集即可 * 单调队列类似 （tail --&gt;） 3 --&gt; 2 --&gt; 1 --&gt; 0 (--&gt; head) (右边为头结点，元素存的是下标) */class Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        ArrayDeque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();        int n = nums.length;        int[] res = new int[n - k + 1];        int idx = 0;        for(int i = 0; i &lt; n; i++) {            // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出            while(!deque.isEmpty() &amp;&amp; deque.peek() &lt; i - k + 1){                deque.poll();            }            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出            while(!deque.isEmpty() &amp;&amp; nums[deque.peekLast()] &lt; nums[i]) {                deque.pollLast();            }            deque.offer(i);            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了            if(i &gt;= k - 1){                res[idx++] = nums[deque.peek()];            }        }        return res;    }}\n\n前k个高频元素主要设计如下三块内容：\n\n统计元素出现频率\n\n对频率排序\n\n找出前k个高频元素\n\n\n对于如何统计元素出现频率，可以使用map来进行统计，对频率进行排序则可以使用 (堆)优先级队列\n堆堆是一个完全二叉树，树中每个结点的值都不小于(或不大于)其左右孩子的值，如果父亲节点大于等于左右孩子就是大顶堆，小于等于左右孩子就是小顶堆。\nHashMap+优先队列代码如下：\n/*Comparator接口说明: * 返回负数，形参中第一个参数排在前面；返回正数，形参中第二个参数排在前面 * 对于队列：排在前面意味着往队头靠 * 对于堆（使用PriorityQueue实现）：从队头到队尾按从小到大排就是最小堆（小顶堆）， *                                从队头到队尾按从大到小排就是最大堆（大顶堆）---&gt;队头元素相当于堆的根节点 * */class Solution {    //解法1：基于大顶堆实现    public int[] topKFrequent1(int[] nums, int k) {        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//key为数组元素值,val为对应出现次数        for(int num:nums){            map.put(num,map.getOrDefault(num,0)+1);        }        //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数        //出现次数按从队头到队尾的顺序是从大到小排,出现次数最多的在队头(相当于大顶堆)        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1, pair2)-&gt;pair2[1]-pair1[1]);        for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){//大顶堆需要对所有元素进行排序            pq.add(new int[]{entry.getKey(),entry.getValue()});        }        int[] ans = new int[k];        for(int i=0;i&lt;k;i++){//依次从队头弹出k个,就是出现频率前k高的元素            ans[i] = pq.poll()[0];        }        return ans;    }    //解法2：基于小顶堆实现    public int[] topKFrequent2(int[] nums, int k) {        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();//key为数组元素值,val为对应出现次数        for(int num:nums){            map.put(num,map.getOrDefault(num,0)+1);        }        //在优先队列中存储二元组(num,cnt),cnt表示元素值num在数组中的出现次数        //出现次数按从队头到队尾的顺序是从小到大排,出现次数最低的在队头(相当于小顶堆)        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;((pair1,pair2)-&gt;pair1[1]-pair2[1]);        for(Map.Entry&lt;Integer,Integer&gt; entry:map.entrySet()){//小顶堆只需要维持k个元素有序            if(pq.size()&lt;k){//小顶堆元素个数小于k个时直接加                pq.add(new int[]{entry.getKey(),entry.getValue()});            }else{                if(entry.getValue()&gt;pq.peek()[1]){//当前元素出现次数大于小顶堆的根结点(这k个元素中出现次数最少的那个)                    pq.poll();//弹出队头(小顶堆的根结点),即把堆里出现次数最少的那个删除,留下的就是出现次数多的了                    pq.add(new int[]{entry.getKey(),entry.getValue()});                }            }        }        int[] ans = new int[k];        for(int i=k-1;i&gt;=0;i--){//依次弹出小顶堆,先弹出的是堆的根,出现次数少,后面弹出的出现次数多            ans[i] = pq.poll()[0];        }        return ans;    }}\n\n总结\n学习文章Java数据结构中的栈和队列（带图解）-CSDN博客\n代码随想录 (programmercarl.com)\n","categories":["代码随想录","栈与队列"],"tags":["算法"]},{"title":"水果成篮_904","url":"/2023/12/01/%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE-904/","content":"水果成篮904. 水果成篮 - 力扣（LeetCode）\n你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。\n你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：\n\n你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。\n你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。\n一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。\n\n给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。\n示例 1：\n输入：fruits = [1,2,1]输出：3解释：可以采摘全部 3 棵树。\n\n示例 2：\n输入：fruits = [0,1,2,2]输出：3解释：可以采摘 [1,2,2] 这三棵树。如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。\n\n示例 3：\n输入：fruits = [1,2,3,2,2]输出：4解释：可以采摘 [2,3,2,2] 这四棵树。如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。\n\n示例 4：\n输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]输出：5解释：可以采摘 [1,2,1,1,2] 这五棵树。\n\n提示：\n\n1 &lt;= fruits.length &lt;= 10^5\n0 &lt;= fruits[i] &lt; fruits.length\n\n解题解法一(滑动窗口+哈希表)思路分析：\n\n根据数据范围，考虑暴力求解可能会超时，使用滑动窗口来尝试解决，用一个循环代替\n首先需要考虑窗口的定义，窗口即指；能采摘的果树的范围\n然后考虑如何移动窗口的起始位置，即当我们采摘果树的类型超出范围时，我们移动窗口的起始位置：s++\n再考虑如何移动窗口的结束位置，使用for循环逐步添加果树\n最后对于如何确认某种类型的果树是否已经采摘过，可以使用哈希表进行存储和确认\n\n实现代码如下：\nclass Solution {    public int totalFruit(int[] fruits) {       HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();       int s = 0; // 记录装进篮子水果的起始位置       int maxNum = -1;   // 计算收集水果的最大数目       int sum = 0;      // 统计装进篮子的水果数目       for (int e = 0; e &lt; fruits.length; ++ e) {          // 摘下水果 并记录水果类型 保存水果数量          hashMap.put(fruits[e], hashMap.getOrDefault(fruits[e], 0) + 1);          sum ++;          while (hashMap.size() &gt;= 3) {             // 水果数量种类超过2 则将放弃左边的水果             hashMap.put(fruits[s], hashMap.get(fruits[s]) - 1);             if (hashMap.get(fruits[s]) == 0) {    // 不含有该水果类型时 将该水果类型弹出                hashMap.remove(fruits[s]);             }             sum --;             s ++;          }          // 更新收集的水果的最大数目            maxNum = Math.max(maxNum, sum);        }       return maxNum;    }}\n\n提交结果如下：\n解答成功:    执行耗时:47 ms,击败了61.65% 的Java用户    内存消耗:54 MB,击败了44.54% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，n是数组fruits的长度\n空间复杂度：O(1)，因为哈希表中对多存储3个键值对，可以看成常数级\n\n优化：对于其中统计装进篮子的果树数目可以通过窗口边界获得，所以使用e-s+1来获得水果的最大数目，实现代码如下：\nclass Solution {    public int totalFruit(int[] fruits) {       HashMap&lt;Integer, Integer&gt; hashMap = new HashMap&lt;&gt;();       int s = 0; // 记录装进篮子水果的起始位置       int maxNum = -1;   // 计算收集水果的最大数目       for (int e = 0; e &lt; fruits.length; ++ e) {          // 摘下水果 并记录水果类型 保存水果数量          hashMap.put(fruits[e], hashMap.getOrDefault(fruits[e], 0) + 1);          while (hashMap.size() &gt;= 3) {             // 水果数量种类超过2 则将放弃左边的水果             hashMap.put(fruits[s], hashMap.get(fruits[s]) - 1);             if (hashMap.get(fruits[s]) == 0) {    // 不含有该水果类型时 将该水果类型弹出                hashMap.remove(fruits[s]);             }             s ++;          }          // 更新收集的水果的最大数目          maxNum = Math.max(maxNum, e-s+1);        }       return maxNum;    }}\n","categories":["leetcode"],"tags":["刷题","数组","哈希表","滑动窗口"]},{"title":"滑动窗口最大值_239","url":"/2023/12/25/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-239/","content":"滑动窗口最大值给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。\n返回 滑动窗口中的最大值 。\n示例 1：\n输入： nums = [1,3,-1,-3,5,3,6,7], k = 3输出：[3,3,5,5,6,7]解释：\n\n滑动窗口的位置               最大值\n—————                       —–\n[1 3 -1] -3 5 3 6 7             3 \n1 [3 -1 -3] 5 3 6 7             3 \n1 3 [-1 -3 5] 3 6 7             5 \n1 3 -1 [-3 5 3] 6 7             5 \n1 3 -1 -3 [5 3 6] 7             6 \n1 3 -1 -3 5 [3 6 7]             7\n\n示例 2：\n输入： nums = [1], k = 1输出：[1]\n提示：\n\n\n\n\n\n解法一(优先队列)思路分析：\n\n对于求滑动窗口的最大值，可以使用优先队列，其中的大根堆可以帮助我们实时维护一系列元素中的最大值\n\n首先将nums数组的前k个元素放入优先队列中，当向右移动窗口时，将新元素放入优先队列中，此时堆顶的元素是堆中所有元素的最大值，但是这个元素可能不在滑动窗口中\n\n当最大值不在滑动窗口中时，需要判断该值在数组nums的位置在滑动窗口左边界的左侧，所以在继续移动窗口时，若最大值不在滑动窗口中，则永久移除优先队列\n\n不断移除堆顶的元素，直到堆顶元素在滑动窗口中，此时堆顶元素为滑动窗口中的最大值\n\n为了方便判断堆顶元素是否在滑动窗口中，可以使用优先队列存储二元组(num, index)，index为元素num在数组中的下标\n\n\n实现代码如下：\nclass Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        int n = nums.length;\t// 数组nums长度        // 创建 优先队列 并设置堆中元素比较方式        PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(                (o1, o2) -&gt; o1[0] != o2[0]? o2[0]-o1[0] : o2[1] - o1[1]        );        // 先将第一组滑动窗口 添加到优先队列中        for (int i = 0; i &lt; k; ++ i) {            pq.offer(new int[]{nums[i], i});        }        int[] ans = new int[n-k+1];\t\t// 返回最大值结果数组 且一共有n-k+1个窗口        ans[0] = pq.peek()[0];        // 移动滑动窗口 进行遍历        for (int i = k; i &lt; n; ++ i) {            pq.offer(new int[]{nums[i], i});\t// 将右窗口元素加入到优先队列中            while (pq.peek()[1] &lt;= i-k) {\t// 将不在窗口内的最大值移除                pq.poll();            }            ans[i-k+1] = pq.peek()[0];\t// 记录窗口内的最大值        }        return ans;    }}\n\n提交结果：\n\n解答成功:    执行耗时:90 ms,击败了11.01% 的Java用户    内存消耗:56.2 MB,击败了96.20% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，维护优先队列中堆顶最大值时间复杂度为，同时需要遍历每个窗口的时间复杂度为，所以综合得时间复杂度为\n\n空间复杂度：，维护优先队列，保存数组中的元素\n\n\n解法二(单调队列)思路分析：\n\n根据解法一进行优化，可以使用一个队列来维护没有被移除的数组元素的下标，并且这些下标对应的元素是严格单调递减的\n\n当滑动窗口向右移动时，需要将一个新的元素放入队列中，此时需要新元素与队尾的元素比较，即如果队尾元素小于新元素，则永久移除，保证新的元素小于队尾的元素\n\n且此时队首元素就是滑动窗口中的最大值，但是与解法一中一样，需要判断最大值是否在滑动窗口中，若不在则弹出，并继续进行判断\n\n因为需要对队首和队尾的元素进行操作，所以使用双端队列来实现单调队列\n\n\n实现代码如下：\nclass Solution {    public int[] maxSlidingWindow(int[] nums, int k) {        int n = nums.length;\t// 数组nums长度        Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();\t// 双端队列 用作维护单调队列        int[] ans = new int[n-k+1];\t\t// 返回结果数组 且计算得滑动窗口数量为n-k+1        for (int i = 0; i &lt; k; ++i) {\t// 将第一组滑动窗口元素加入队列中            // 将小于新元素的队尾元素 移除队列            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()]) {                deque.pollLast();            }            deque.offerLast(i);\t// 将新元素添加到队尾        }        ans[0] = nums[deque.peekFirst()];        for (int i = k; i &lt; n; ++i) {            // 将队尾小于新元素的数组元素 移除            while (!deque.isEmpty() &amp;&amp; nums[i] &gt;= nums[deque.peekLast()])                deque.pollLast();            deque.offerLast(i);\t\t// 将新元素添加到队尾            // 将队首 不在滑动窗口内的最大值移除            while (!deque.isEmpty() &amp;&amp; deque.peekFirst() &lt;= i-k)                deque.pollFirst();            ans[i-k+1] = nums[deque.peekFirst()];        }        return ans;    }}\n\n提交结果如下：\n\n解答成功:    执行耗时:30 ms,击败了60.89% 的Java用户    内存消耗:63.2 MB,击败了5.02% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，对每个元素遍历一次，且每个元素进队和出队一次\n\n空间复杂度：，使用双端队列维护单调队列\n\n\n","categories":["leetcode"],"tags":["刷题","数组","堆(优先队列)","滑动窗口","队列","单调队列"]},{"title":"环形链表II_142","url":"/2023/12/09/%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-142/","content":"环形链表 II142. 环形链表 II - 力扣（LeetCode）\n给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。\n如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n不允许修改 链表。\n示例 1：\n\n输入： head = [3,2,0,-4], pos = 1输出： 返回索引为 1 的链表节点解释： 链表中有一个环，其尾部连接到第二个节点。\n示例 2：\n\n输入： head = [1,2], pos = 0输出： 返回索引为 0 的链表节点解释： 链表中有一个环，其尾部连接到第一个节点。\n示例 3：\n\n输入： head = [1], pos = -1输出： 返回 null解释： 链表中没有环。\n提示：\n\n链表中节点的数目范围在范围  内\n\npos 的值为 -1 或者链表中的一个有效索引\n\n进阶： 你是否可以使用 O(1) 空间解决此题？\n解法解法一(哈希表)思路分析：\n\n创建一个哈希表hashNode存储链表中的节点\n\n对链表进行遍历，让出现重复节点时，即为链表开始入环的第一个节点，将其返回即可\n\n\n实现代码如下：\nclass Solution {    public ListNode detectCycle(ListNode head) {        // 创建哈希表        HashMap&lt;ListNode, Integer&gt; hashNode = new HashMap&lt;&gt;();        ListNode cur = head;        while (cur != null) {            if (hashNode.containsKey(cur)) {  // 存在节点直接返回                return cur;            }            hashNode.put(cur, 1);            cur = cur.next;        }        return null;    }}\n\n提交结果如下：\n解答成功:    执行耗时:3 ms,击败了18.03% 的Java用户    内存消耗:42.9 MB,击败了14.97% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，遍历一遍链表\n\n空间复杂度：O(n)，需要存储链表的节点\n\n\n解法二(双指针)思路分析：\n\n使用两个指针fast和slow，起始都位于链表的头部，slow每次向后移动一个位置，fast每次向后移动两个位置，若链表中存在环，则fast指针最终会再次与slow指针在环中相遇\n\n因为fast每次比slow多走一步，有环，则fast一定会追上slow\n\n假设链表长度为a+b，即a指链表头部到链表环入口的长度，b为环的长度\n\n且fast指针走的步数是slow走的步数的两倍，\n\n当fast与slow相遇时，两个指针所走长度关系为，，nb指的是n圈环的长度\n\n则有，即两个指针fast和slow分别走了2n、n个环的周长\n\n\n\n且有链表环的入口点为，从链表头部走步到达，fast和slow相遇时时slow已走过nb步，即只需再走a步，slow指向链表环的入口点\n\n此时，让一个指针ptr从链表头部开始遍历，且与slow同时移动，当指针ptr走过a步时，指向链表环的入口点，恰好此时指针slow也指向链表环的入口点，即两个指针相遇时，刚好均指向链表环的路口点\n\n\n实现代码如下：\nclass Solution {    public ListNode detectCycle(ListNode head) {        ListNode fast = head;        ListNode slow = head;        // 若fast为空则说明不含有环 退出循环        while (fast != null &amp;&amp; fast.next != null) {            fast = fast.next.next;            slow = slow.next;            if (fast == slow) {        // 当fast与slow相遇                ListNode ptr = head;                while (ptr != slow) {    // 寻找环入口处节点                    slow = slow.next;                    ptr = ptr.next;                }                return ptr;            }        }        return null;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43 MB,击败了10.51% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，对链表进行遍历\n\n空间复杂度：O(1)，使用了常量级变量\n\n\n","categories":["leetcode"],"tags":["刷题","哈希表","链表","双指针"]},{"title":"用栈实现队列_232","url":"/2023/12/20/%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-232/","content":"用栈实现队列232. 用栈实现队列 - 力扣（LeetCode）\n请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：\n实现 MyQueue 类：\n\nvoid push(int x) 将元素 x 推到队列的末尾\nint pop() 从队列的开头移除并返回元素\nint peek() 返回队列开头的元素\nboolean empty() 如果队列为空，返回 true ；否则，返回 false\n\n说明：\n\n你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。\n你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。\n\n示例 1：\n输入：[“MyQueue”, “push”, “push”, “peek”, “pop”, “empty”][[], [1], [2], [], [], []]输出：[null, null, null, 1, 1, false]\n解释：MyQueue myQueue = new MyQueue();myQueue.push(1); // queue is: [1]myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)myQueue.peek(); // return 1myQueue.pop(); // return 1, queue is [2]myQueue.empty(); // return false\n提示：\n\n\n最多调用 100 次 push、pop、peek 和 empty\n假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）\n\n进阶：\n\n你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。\n\n解法一思路分析：\n\n考虑栈只能先进后出，如果只有一个栈，则无法实现队列的先进先出，所以在设置一个主栈外，再添加一个副栈\n\n在队列push操作时，先将主栈元素保存到副栈中，然后再添加，保证主栈的元素顺序，与元素进入队列顺序一致，即保证可以先进先出\n\n其余操作在栈中顺序与实际队列顺序一致的情况下，调用栈对应的API即可\n\n\nclass MyQueue {    Stack&lt;Integer&gt; stack;   // 主栈    Stack&lt;Integer&gt; temp;    // 副栈    public MyQueue() {        stack = new Stack&lt;&gt;();        temp = new Stack&lt;&gt;();    }    public void push(int x) {        // 先将之前的元素移到副栈中        while (!stack.empty()) {            temp.push(stack.pop());        }        stack.push(x);  // 再将新元素追加到队列末尾        // 将副栈的元素重新移回主栈        while (!temp.empty()) {            stack.push(temp.pop());        }    }    public int pop() {        // 弹出队列头元素        return stack.pop();    }    public int peek() {        // 获取队列头元素        return stack.peek();    }    public boolean empty() {        return stack.empty();    }}/** * Your MyQueue object will be instantiated and called as such: * MyQueue obj = new MyQueue(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.peek(); * boolean param_4 = obj.empty(); */\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.2 MB,击败了5.18% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，除了push操作外，其余操作时间复杂度均为，对于每个元素，至多入栈和出栈各两次，故均摊复杂度为 \n\n空间复杂度：，主栈与副栈总共存储元素个数为n\n\n\n","categories":["leetcode"],"tags":["刷题","栈","队列","设计"]},{"title":"用队列实现栈_225","url":"/2023/12/21/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88-225/","content":"用队列实现栈225. 用队列实现栈 - 力扣（LeetCode）\n请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。\n实现 MyStack 类：\n\nvoid push(int x) 将元素 x 压入栈顶。\nint pop() 移除并返回栈顶元素。\nint top() 返回栈顶元素。\nboolean empty() 如果栈是空的，返回 true ；否则，返回 false 。\n\n注意：\n\n你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。\n你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。\n\n示例：\n输入：[“MyStack”, “push”, “push”, “top”, “pop”, “empty”][[], [1], [2], [], [], []]输出：[null, null, null, 2, 2, false]\n解释：MyStack myStack = new MyStack();myStack.push(1);myStack.push(2);myStack.top(); // 返回 2myStack.pop(); // 返回 2myStack.empty(); // 返回 False\n提示：\n\n\n最多调用100 次 push、pop、top 和 empty\n每次调用 pop 和 top 都保证栈不为空\n\n进阶： 你能否仅用一个队列来实现栈。\n解法一(两个队列)思路分析：\n\n首先按照题目要求，使用两个队列来实现一个后入先出的栈，并支持栈的四种基本操作\n\n实现代码如下：\nclass MyStack {    Queue&lt;Integer&gt; queue;    Queue&lt;Integer&gt; temp;    public MyStack() {        queue = new ArrayDeque&lt;&gt;();        temp = new ArrayDeque&lt;&gt;();    }    public void push(int x) {        // 先将主队列元素移到副队列        while (!queue.isEmpty()) {            temp.offer(queue.poll());        }        // 再将当前元素加入到主队列中 作为后进先出 将第一个出栈        queue.offer(x);        // 再将副队列元素移到主队列中        while (!temp.isEmpty()) {            queue.offer(temp.poll());        }    }    public int pop() {        // 队列中已排好顺序 直接弹出        return queue.poll();    }    public int top() {        // 直接获取        return queue.peek();    }    public boolean empty() {        return queue.isEmpty();    }}/** * Your MyStack object will be instantiated and called as such: * MyStack obj = new MyStack(); * obj.push(x); * int param_2 = obj.pop(); * int param_3 = obj.top(); * boolean param_4 = obj.empty(); */\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.1 MB,击败了5.24% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，除了push其余操作为，n指每个操作的个数，k则是指执行push操作时，主队列中元素的个数\n\n空间复杂度：\n\n\n解法二(一个队列)思路分析：\n\n可以使用双端队列，即队列两端均可以入队出队\n\n实现代码如下：\nclass MyStack {    Deque&lt;Integer&gt; deque;    public MyStack() {        deque = new ArrayDeque&lt;&gt;();    }    public void push(int x) {        deque.offerLast(x);  // 从队列尾部入队    }    public int pop() {        return deque.pollLast();   // 从队列末尾出队    }    public int top() {        return deque.peekLast();    // 获取队列尾部元素    }    public boolean empty() {        return deque.isEmpty();    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40.1 MB,击败了5.24% 的Java用户\n\n复杂度分析：\n\n时间复杂度：调用的均为双端队列的API\n\n空间复杂度：\n\n\n","categories":["leetcode"],"tags":["刷题","栈","队列","设计"]},{"title":"移动零_283","url":"/2023/11/28/%E7%A7%BB%E5%8A%A8%E9%9B%B6-283/","content":"移动零283. 移动零 - 力扣（LeetCode）\n给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n输入: nums = [0,1,0,3,12]输出: [1,3,12,0,0]\n\n示例 2:\n输入: nums = [0]输出: [0]\n\n提示:\n\n1 &lt;= nums.length &lt;= 104\n-231 &lt;= nums[i] &lt;= 231 - 1\n\n进阶：你能尽量减少完成的操作次数吗？\n解题解法一思路分析：\n\n题目要求保持非零元素的相对顺序的情况下，将所有0都移动到数组末尾，那么我们考虑使用快慢双指针法，使用快指针遍历需要移动的元素，使用慢指针指向0所在位置。\n在完成题目要求时，我们还需要考虑如何使交换元素发生次数最少。\n\n实现代码如下：\nclass Solution {    public void moveZeroes(int[] nums) {       if (nums.length == 1)          return ;  // 数组长度为1时不需要移动       int fast;       int slow = 0;       // 记录数组元素不为0的数量 用于从数组后端重新将0赋值       // 避免反复覆盖nums[fast] 快指针指向的值       int count = 0;       // 循环寻找第一个不为0的索引 避免数组前端不为0的元素重复赋值       while (slow &lt; nums.length &amp;&amp; nums[slow] != 0) {          ++ slow;          ++ count;       }       // 说明数组中不含有为0的元素 不需要移动数组元素       if (slow == nums.length) {          return ;       }       // 慢指针指向的数组元素为0的索引处 快指针从下一个索引开始搜索不为0的数组元素       fast = slow+1;       while(fast &lt; nums.length) {          if (nums[fast] != 0) {             nums[slow++] = nums[fast];             count++;          }          ++ fast;       }       if (count == 0) {  // 说明数组元素全为0 不需要移动          return ;       }       count = nums.length-count;       // 将0赋值给数组末尾       for (int i = nums.length-1; i &gt;= 0 &amp;&amp; count &gt; 0; -- i, -- count) {          nums[i] = 0;       }    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了99.97% 的Java用户    内存消耗:43.8 MB,击败了82.25% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n+m)，n是数组长度，m是为数组中元素为0的个数\n空间复杂度：O(1)\n\n考虑程序执行过程，slow-1最后指向了数组移动后，最后一个不为0的数组元素位置，因此不需要再使用count来统计不为0的数组元素个数，slow本身已经实现了统计数组元素个数的过程；优化代码如下所示：\nclass Solution {    public void moveZeroes(int[] nums) {       if (nums.length == 1)          return ;  // 数组长度为1时不需要移动       int fast;       int slow = 0;  // 遍历保存非0数组元素 并统计非0元素个数       // 循环寻找第一个不为0的索引 避免数组前端不为0的元素重复赋值       while (slow &lt; nums.length &amp;&amp; nums[slow] != 0) {          ++ slow;       }       // 说明数组中不含有为0的元素 不需要移动数组元素 直接返回       if (slow == nums.length) {          return ;       }       // 慢指针指向数组元素为0的索引处       // 快指针从下一个索引开始搜索不为0的数组元素       fast = slow+1;       while(fast &lt; nums.length) {          if (nums[fast] != 0) {             nums[slow++] = nums[fast];          }          ++ fast;       }       // 进行移动后 若 slow==0 则说明数组元素均为0 不需要再进行重赋值为0       if (slow == 0) return ;       // 进行重赋值为0       while (slow &lt; nums.length)          nums[slow ++] = 0;    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了99.97% 的Java用户    内存消耗:44.4 MB,击败了5.03% 的Java用户\n\n","categories":["leetcode"],"tags":["刷题","数组","双指针"]},{"title":"移除元素_27","url":"/2023/11/27/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-27/","content":"移除元素27. 移除元素 - 力扣（LeetCode）\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n说明:\n为什么返回数值是整数，但输出的答案是数组呢?\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n你可以想象内部操作如下:\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝int len = removeElement(nums, val);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。for (int i = 0; i &lt; len; i++) {    print(nums[i]);}\n\n示例 1：\n输入：nums = [3,2,2,3], val = 3输出：2, nums = [2,2]解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。\n\n示例 2：\n输入：nums = [0,1,2,2,3,0,4,2], val = 2输出：5, nums = [0,1,3,0,4]解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n提示：\n\n0 &lt;= nums.length &lt;= 100\n0 &lt;= nums[i] &lt;= 50\n0 &lt;= val &lt;= 100\n\n解题解法一思路分析：\n\n根据题目要求和示例，对于移除数组中的元素，我们只需要将不等于val的数组元素提前，不用考虑提前的数组元素之间的顺序，然后返回对应的长度即可，同时对于等于val的数组元素，我们只需将其提取到数组元素后端即可。\n对此，可以考虑使用双指针，指针i遍历不等于val的数组元素，指针j遍历等于val的数组元素，然后指针i和指针j对应的数组元素值进行交换，从而实现移除值为val的数组元素\n\n实现代码如下：\nclass Solution {    public int removeElement(int[] nums, int val) {       int i = nums.length-1;       // 用于遍历值不为val的数组元素       int j = 0;       // 用于遍历值为val的数组元素       while (j &lt;= i) {          while (j &lt; nums.length &amp;&amp; nums[j] != val) {             j ++;          }          while (i &gt;= 0 &amp;&amp; nums[i] == val) {             i --;          }          if (j &gt; i) break;     // 防止最后一次交换 i&lt;j 导致等于val的值重新回到新数组中          // 进行数组元素交换          int t = nums[i];          nums[i] = nums[j];          nums[j] = t;       }       // 在循环最后一次j退出循环时 指针j指向了第一个等于val的数组元素的索引处 即为新数组长度       return j;      }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:40 MB,击败了30.00% 的Java用户\n\n复杂度分析：\n\n时间复杂度分析：O(n)，即指针i和指针j合计遍历一遍数组\n空间复杂度分析：O(1)\n\n总结：\n必须要对数组数组交换过程有一个清晰的了解，以及考虑数组只有一个元素时的特殊情况。\n","categories":["leetcode"],"tags":["刷题","数组","双指针"]},{"title":"移除链表元素_203","url":"/2023/12/05/%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-203/","content":"移除链表元素203. 移除链表元素 - 力扣（LeetCode）\n给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。\n示例 1：\n\n输入： head = [1,2,6,3,4,5,6], val = 6输出：[1,2,3,4,5]\n示例 2：\n输入： head = [], val = 1输出：[]\n示例 3：\n输入： head = [7,7,7,7], val = 7输出：[]\n提示：\n\n列表中的节点数目在范围 [0, 10^4] 内\n1 &lt;= Node.val &lt;= 50\n0 &lt;= val &lt;= 50\n\n解题解法一(使用虚拟头节点)思路分析：\n\n链表每次删除节点的操作，时间复杂度为O(1)，因此只需直接遍历链表元素，链表数据等于val的节点，直接删除即可。\n考虑使用虚拟头节点，可以方便在对头节点进行处理的时候，与非头节点操作一致，不需要特别判断。\n\n实现代码如下：\nclass Solution {    public ListNode removeElements(ListNode head, int val) {        if (head == null)     // 链表为空时 直接返回空            return null;        ListNode p = new ListNode();        p.next = head;        // 用新节点指向头节点 则在进行遍历检查时 可以检查到头节点        ListNode nHead = p;    // 保存p节点        while (p.next != null) {    // 保证p的下一个节点不为空            if (p.next.val == val) {    // 若p节点的下一个节点的值为val 则删除                p.next = p.next.next;    // 删除p节点的下一个节点            } else {    // 若p节点的下一个节点值不为val 则继续遍历                p = p.next;            }        }        return nHead.next;    // nHead保存的是p节点 则应该返回其指向的下一个节点 才是新头节点    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:43.8 MB,击败了95.65% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，n为遍历链表的长度\n\n空间复杂度：O(1)，只声明了常量级的链表节点\n\n\n总结：\n    在使用p.next时，要注意前提p节点不能为空，且需要注意遍历会改变p节点，需要先提前将p节点保存起来\n解法二(特殊处理头节点)链表理论基础 | 花木凋零成兰 (ytazwc.top)\n解法三(递归)链表理论基础 | 花木凋零成兰 (ytazwc.top)\n","categories":["leetcode"],"tags":["刷题","链表","递归"]},{"title":"螺旋矩阵_54","url":"/2023/12/04/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5-54/","content":"螺旋矩阵54. 螺旋矩阵 - 力扣（LeetCode）\n给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。\n示例 1：\n\n输入： matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5]\n示例 2：\n\n输入： matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7]\n提示：\n\nm == matrix.length\nn == matrix[i].length\n1 &lt;= m, n &lt;= 10\n-100 &lt;= matrix[i][j] &lt;= 100\n\n解题解法一(模拟)思路分析：\n\n首先根据数组matrix的长度，暴力模拟不会超时，那么考虑使用模拟，我们可以模拟顺时针螺旋顺序去遍历matrix中的元素，并将遍历到的元素保存到返回数组中。\n\n再循环遍历过程中，我们需要考虑循环不变量，即我们要保证遍历的边界一致，采用左闭右闭区间进行遍历。即包含边角\n\n\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        int t = 0;        // 上边边界        int b = matrix.length - 1;    // 下边边界        int l = 0;        // 左边边界        int r = matrix[0].length - 1;    // 右边边界        int s = (b+1)*(r+1);    // 矩阵元素总数        int k = 0;        while (k &lt; s) {            // 上边 从左往右             // 当矩阵长宽不等时，会导致多添加元素，用k&lt;s来避免            // k &lt; s 保证只添加一遍matrix中的元素到ans中            for (int j = l; j &lt;= r &amp;&amp; k &lt; s; ++j, ++k) {                ans.add(matrix[t][j]);            }            ++ t;            // 右边 从上往下            for (int i = t; i &lt;= b &amp;&amp; k &lt; s; ++i, ++k) {                ans.add(matrix[i][r]);            }            -- r;            // 下边 从右往左            for (int j = r; j &gt;= l &amp;&amp; k &lt; s; --j, ++k) {                ans.add(matrix[b][j]);            }            -- b;            // 左边 从下往上            for (int i = b; i &gt;= t &amp;&amp; k &lt; s; --i, ++k) {                ans.add(matrix[i][l]);            }            ++ l;        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.4 MB,击败了83.03% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(m*n)，即二维数组的长度\n\n空间复杂度：O(1)，除了返回值外，只使用了常量级的变量\n\n\n优化解法一(减少变量)思路：可以不用再使用变量k来标记遍历的位置，在while中添加判断，若遍历完则退出；也避免了矩阵长和宽不相等时，会出现重复遍历元素的情况。\n实现代码如下：\nclass Solution {    public List&lt;Integer&gt; spiralOrder(int[][] matrix) {        List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();        int t = 0;        // 上边边界        int b = matrix.length - 1;    // 下边边界        int l = 0;        // 左边边界        int r = matrix[0].length - 1;    // 右边边界        while (true) {            // 上边 从左往右            for (int j = l; j &lt;= r; ++j) {                ans.add(matrix[t][j]);            }            if (++ t &gt; b) break; // 已经遍历完则退出循环            // 右边 从上往下            for (int i = t; i &lt;= b; ++i) {                ans.add(matrix[i][r]);            }            if (-- r &lt; l) break;            // 下边 从右往左            for (int j = r; j &gt;= l; --j) {                ans.add(matrix[b][j]);            }            if (-- b &lt; t) break;            // 左边 从下往上            for (int i = b; i &gt;= t; --i) {                ans.add(matrix[i][l]);            }            if (++ l &gt; r) break;        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.9 MB,击败了5.08% 的Java用户\n","categories":["leetcode"],"tags":["刷题","数组","矩阵","模拟"]},{"title":"螺旋矩阵II_59","url":"/2023/12/04/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II-59/","content":"螺旋矩阵II59. 螺旋矩阵 II - 力扣（LeetCode）\n给你一个正整数 n ，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。\n示例 1：\n\n输入： n = 3输出： [[1,2,3],[8,9,4],[7,6,5]]\n示例 2：\n输入： n = 1输出： [[1]]\n提示：\n\n1 &lt;= n &lt;= 20\n\n解题解法一(模拟)思路分析：\n\n首先根据提示可知，1 &lt;= n &lt;= 20，则可以直接暴力模拟生成矩阵的过程，并不会出现超时\n\n实现代码如下：\nclass Solution {    public int[][] generateMatrix(int n) {        if (n == 1) return new int[][]{{1}};    // n为1时直接返回        int[][] ans = new int[n][n];        int k = 1;        int t = 0;        // 上边 填入位置        int b = n-1;    // 下边 填入位置        int l = 0;        // 左边 填入位置        int r = n-1;    // 右边 填入位置        while (k &lt;= n*n) {            for (int i = l; i &lt;= r; ++i, ++k) {                // 向左    从左到右依次填入                ans[t][i] = k;            }            ++ t;    // 填完上边 则下次从下一行开始向左            for (int i = t; i &lt;= b; ++i, ++k) {                // 向下    从上到下依次填入                ans[i][r] = k;            }            -- r;    // 填完右边 则下次从左一列开始向下            for (int i = r; i &gt;= l; --i, ++k) {                // 向右    从右向左一依次填入                ans[b][i] = k;            }            -- b;    // 填完下边 则下次从上一行开始向右            for (int i = b; i &gt;= t; --i, ++k) {                // 向上    从下向上依次填入                ans[i][l] = k;            }            ++ l;    // 填完左边 则下次从右一列开始向上        }        return ans;    }}\n\n提交结果如下：\n解答成功:    执行耗时:0 ms,击败了100.00% 的Java用户    内存消耗:39.2 MB,击败了83.55% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n*n)，需要依次填入1到n^2\n\n空间复杂度：O(1)，除了返回答案外，使用常量级变量\n\n\n","categories":["leetcode"],"tags":["刷题","数组","矩阵","模拟"]},{"title":"设计链表_707","url":"/2023/12/06/%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8-707/","content":"设计链表707. 设计链表 - 力扣（LeetCode）\n你可以选择使用单链表或者双链表，设计并实现自己的链表。\n单链表中的节点应该具备两个属性：val 和 next 。val 是当前节点的值，next 是指向下一个节点的指针/引用。\n如果是双向链表，则还需要属性 prev 以指示链表中的上一个节点。假设链表中的所有节点下标从 0 开始。\n实现 MyLinkedList 类：\n\nMyLinkedList() 初始化 MyLinkedList 对象。\nint get(int index) 获取链表中下标为 index 的节点的值。如果下标无效，则返回 -1 。\nvoid addAtHead(int val) 将一个值为 val 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。\nvoid addAtTail(int val) 将一个值为 val 的节点追加到链表中作为链表的最后一个元素。\nvoid addAtIndex(int index, int val) 将一个值为 val 的节点插入到链表中下标为 index 的节点之前。如果 index 等于链表的长度，那么该节点会被追加到链表的末尾。如果 index 比长度更大，该节点将 不会插入 到链表中。\nvoid deleteAtIndex(int index) 如果下标有效，则删除链表中下标为 index 的节点。\n\n示例：\n\n输入[“MyLinkedList”, “addAtHead”, “addAtTail”, “addAtIndex”, “get”, “deleteAtIndex”, “get”][[], [1], [3], [1, 2], [1], [1], [1]]输出[null, null, null, null, 2, null, 3]\n解释MyLinkedList myLinkedList = new MyLinkedList();myLinkedList.addAtHead(1);myLinkedList.addAtTail(3);myLinkedList.addAtIndex(1, 2);    // 链表变为 1-&gt;2-&gt;3myLinkedList.get(1);              // 返回 2myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1-&gt;3myLinkedList.get(1);              // 返回 3\n\n提示：\n\n0 &lt;= index, val &lt;= 1000\n请不要使用内置的 LinkedList 库。\n调用 get、addAtHead、addAtTail、addAtIndex 和 deleteAtIndex 的次数不超过 2000 。\n\n解题解法一(单链表)思路分析：\n\n使用单链表，定义节点为一个数据域加一个节点域，并完成对应函数操作\n在设计到索引index时，注意其值不可越界\n\n实现代码如下：\nclass MyLinkedList {    ListNode preNode;      // 链表头节点的前一个节点 即虚拟头节点    int size;    class ListNode {        int val;        ListNode next;        public ListNode() {        }        public ListNode(int val) {            this.val = val;            this.next = null;        }    }    public MyLinkedList() {        preNode = new ListNode(-1);   // 初始化链表的前一个节点        size = 0;       // 记录链表节点个数    }    public int get(int index) {        if (index &lt; 0 || index &gt;= size) {     // 索引越界 则返回-1            return -1;        }        // 索引不越界 则查询索引对应的 当前节点        ListNode cur = preNode;        for (int i = 0; i &lt;= index; ++i) {            cur = cur.next;        }        return cur.val;    }    // 将一个值为val的节点插入到链表的第一个元素之前    // 且该节点称为新的链表的第一个节点    public void addAtHead(int val) {        ListNode newNode = new ListNode(val);        ++ size;    // 链表节点个数加一        newNode.next = preNode.next;    // 新节点指向原有链表的头节点 成为新的头节点        preNode.next = newNode;         // 记录新的头节点    }    // 将一个值为val的节点追加到链表的末尾    public void addAtTail(int val) {        addAtIndex(size, val);    }    public void addAtIndex(int index, int val) {        if (index  &gt; size)            return ;   // 比链表长度大 则该节点不插入到链表中        ListNode cur = preNode;        for (int i = 0; i &lt; index; ++ i) {   // 获得待插入位置的前一个节点            cur = cur.next;        }        ListNode newNode = new ListNode(val);        newNode.next = cur.next;        cur.next = newNode;        ++  size;   // 链表个数加一    }    public void deleteAtIndex(int index) {        if (index &gt;= size)            return ;  // 链表不含有节点或索引越界 删除无效        ListNode cur = preNode;        for (int i = 0; i &lt; index; ++ i) {   // 寻找索引对应节点的前一个节点            cur = cur.next;        }        cur.next = cur.next.next;        -- size;        // 链表节点数减一    }}\n\n提交结果如下：\n解答成功:    执行耗时:9 ms,击败了87.61% 的Java用户    内存消耗:43.1 MB,击败了84.12% 的Java用户\n\n复杂度分析：\n\n时间复杂度：初始化消耗O(1)，get(index)消耗O(index)，addAtHead(val)消耗O(1)，addAtTail(val)消耗O(n)，n为当时链表长度，对各种函数调用次数再乘各自函数的复杂度之和。\n\n空间复杂度：函数单词调用空间复杂度均为O(1)，总体为O(n)\n\n\n优化(末尾节点标记)优化思路：\n\n在调用addAtTail(val)函数时，需要先遍历一遍链表，才能找到末尾追加元素的位置，同时查询末尾节点的值时，也需要遍历一次链表，\n\n这些开销可以通过一个标记来避免，即增加一个末尾节点记录下链表的末尾节点\n\n在需要涉及到链表末尾节点的操作时，均可以通过该标记来避免 遍历链表寻找末尾节点的操作 \n\n需要注意的是，在对链表做修改操作时，要时刻注意对末尾节点标记的更新。\n\n\n实现代码如下：\nclass MyLinkedList {    ListNode preNode;      // 链表头节点的前一个节点 即虚拟头节点    int size;    ListNode endNode;   // 用于记录最后一个节点    public MyLinkedList() {        preNode = new ListNode(-1);   // 初始化链表的前一个节点        size = 0;       // 记录链表节点个数        endNode = new ListNode(-1);    }    public int get(int index) {        if (index &lt; 0 || index &gt;= size) {     // 索引越界 则返回-1            return -1;        }        if (index == size-1) {            // 若索引指向最后一个链表节点 则直接返回            return endNode.val;        }        // 索引不越界 则查询索引对应的 当前节点        ListNode cur = preNode;        for (int i = 0; i &lt;= index; ++i) {            cur = cur.next;        }        return cur.val;    }    // 将一个值为val的节点插入到链表的第一个元素之前    // 且该节点称为新的链表的第一个节点    public void addAtHead(int val) {        ListNode newNode = new ListNode(val);        ++ size;    // 链表节点个数加一        if (size == 1) {            // 若此时增加的节点为第一个节点 则需要更新末端节点标记            endNode = newNode;        }        newNode.next = preNode.next;    // 新节点指向原有链表的头节点 成为新的头节点        preNode.next = newNode;         // 记录新的头节点    }    // 将一个值为val的节点追加到链表的末尾    public void addAtTail(int val) {        // addAtIndex(size, val);        // 追加到链表末尾 可直接通过表标记的末尾节点进行添加        if (size == 0) {            // 说明追加在链表末尾的节点为第一个节点            addAtHead(val);            return ;        }        ListNode newNode = new ListNode(val);        endNode.next = newNode;        endNode = newNode;        ++ size;    // 节点数增加    }    public void addAtIndex(int index, int val) {        if (index &gt; size)            return ;   // 比链表长度大 则该节点不插入到链表中        if (index == size) {            // 索引为链表长度 则将节点插入链表末尾            addAtTail(val);            return ;        }        ListNode cur = preNode;        for (int i = 0; i &lt; index; ++ i) {   // 获得待插入位置的前一个节点            cur = cur.next;        }        ListNode newNode = new ListNode(val);        newNode.next = cur.next;        cur.next = newNode;        ++  size;   // 链表个数加一    }    public void deleteAtIndex(int index) {        if (index &gt;= size)            return ;  // 链表不含有节点或索引越界 删除无效        ListNode cur = preNode;        for (int i = 0; i &lt; index; ++ i) {   // 寻找索引对应节点的前一个节点            cur = cur.next;        }        if (cur.next.next == null) {            // 说明此时删除节点为末尾节点 需要更新末尾节点            endNode = cur;        }        cur.next = cur.next.next;        -- size;        // 链表节点数减一    }    class ListNode {        int val;        ListNode next;        public ListNode() {        }        public ListNode(int val) {            this.val = val;            this.next = null;        }    }}\n\n提交结果如下：\n解答成功:    执行耗时:6 ms,击败了98.57% 的Java用户    内存消耗:43 MB,击败了88.34% 的Java用户\n\n解法二(双链表)思路分析：\n\n也可以使用双链表，定义一个数据域，和两个指针域\n\n同时双链表可以从两端遍历数组，因此在对链表进行遍历查询时，可以通过比较哪边距离更短，来提高查询的速度\n\n\n代码如下：\nclass MyLinkedList {    int size;   // 记录节点个数    ListNode preNode;   // 虚拟头节点    ListNode tailNode;  // 虚拟尾节点    public MyLinkedList() {     // 初始化双链表        this.size = 0;        preNode = new ListNode();        tailNode = new ListNode();        preNode.next = tailNode;        tailNode.prev = preNode;    }    public int get(int index) {        if (index &lt; 0 || index &gt;= size) {   // 判断索引是否越界            return -1;        }        ListNode cur;        // 根据索引的位置 判断两边遍历时间        if (index &lt; size/2) {   // 索引更靠近左边            cur = preNode;            for (int i = 0; i &lt;= index; ++ i) {     // 寻找索引对应的节点                cur = cur.next;            }        } else {     // 说明索引更靠近右边 使用虚拟尾节点查找更快            cur = tailNode;            for (int i = 0; i &lt; size-index; ++i) {                cur = cur.prev;            }        }        return cur.val;    }    public void addAtHead(int val) {        addAtIndex(0, val);    }    public void addAtTail(int val) {        addAtIndex(size, val);    }    public void addAtIndex(int index, int val) {        if (index &gt; size) {            return ;    // 索引越界 不添加到链表中        }        if (index &lt; 0) index = 0;        // 快速寻找索引对应节点        ListNode cur;        // 根据索引的位置 判断两边遍历时间        if (index &lt; size/2) {   // 索引更靠近左边            cur = preNode;            for (int i = 0; i &lt;= index; ++ i) {     // 寻找索引对应的节点                cur = cur.next;            }        } else {     // 说明索引更靠近右边 使用虚拟尾节点查找更快            cur = tailNode;            for (int i = 0; i &lt; size-index; ++i) {                cur = cur.prev;            }        }        // 在索引对应节点前添加节点        ListNode newNode = new ListNode(val);        newNode.prev = cur.prev;        cur.prev.next = newNode;        newNode.next = cur;        cur.prev = newNode;        // 链表节点个数增加        ++ size;    }    public void deleteAtIndex(int index) {        if (index &lt; 0 || index &gt;= size) {   // 数组越界            return;        }        // 快速寻找索引对应节点        ListNode cur;        // 根据索引的位置 判断两边遍历时间        if (index &lt; size/2) {   // 索引更靠近左边            cur = preNode;            for (int i = 0; i &lt;= index; ++ i) {     // 寻找索引对应的节点                cur = cur.next;            }        } else {     // 说明索引更靠近右边 使用虚拟尾节点查找更快            cur = tailNode;            for (int i = 0; i &lt; size-index; ++i) {                cur = cur.prev;            }        }        // 删除索引对应的节点        cur.prev.next = cur.next;        cur.next.prev = cur.prev;        -- size;    }}// 双链表节点class ListNode {    int val;    ListNode prev;    ListNode next;    public ListNode() {    }    public ListNode(int val) {        this.val = val;    }}\n\n提交结果如下：\n解答成功:    执行耗时:5 ms,击败了100.00% 的Java用户    内存消耗:43.6 MB,击败了5.21% 的Java用户\n\n复杂度分析：\n\n时间复杂度：其中除了删除节点和查询节点以及根据索引插入节点外，其余函数时间复杂度为O(1)，删除节点和查询节点及插入节点最多需要遍历链表一半，即O(n/2)\n\n空间复杂度：总的来看，使用O(n)的复杂度\n\n\n优化(提取相同代码块)思路：\n    快速查找索引对应的链表元素的代码，在几块地方均存在，可以提取成一个函数，从而简化代码。\n实现代码如下：\nclass MyLinkedList {    int size;   // 记录节点个数    ListNode preNode;   // 虚拟头节点    ListNode tailNode;  // 虚拟尾节点    public MyLinkedList() {     // 初始化双链表        this.size = 0;        preNode = new ListNode();        tailNode = new ListNode();        preNode.next = tailNode;        tailNode.prev = preNode;    }    // 获取索引对应位置的 链表节点    ListNode getByIndex(int index) {        // 根据索引的位置 判断两边遍历时间        ListNode cur;        if (index &lt; size/2) {   // 索引更靠近左边            cur = preNode;            for (int i = 0; i &lt;= index; ++ i) {     // 寻找索引对应的节点                cur = cur.next;            }        } else {     // 说明索引更靠近右边 使用虚拟尾节点查找更快            cur = tailNode;            for (int i = 0; i &lt; size-index; ++i) {                cur = cur.prev;            }        }        return cur;    }    public int get(int index) {        if (index &lt; 0 || index &gt;= size) {   // 判断索引是否越界            return -1;        }        ListNode cur = getByIndex(index);        return cur.val;    }    public void addAtHead(int val) {        addAtIndex(0, val);    }    public void addAtTail(int val) {        addAtIndex(size, val);    }    public void addAtIndex(int index, int val) {        if (index &gt; size) {            return ;    // 索引越界 不添加到链表中        }        if (index &lt; 0) index = 0;        // 快速寻找索引对应节点        ListNode cur = getByIndex(index);        // 在索引对应节点前添加节点        ListNode newNode = new ListNode(val);        newNode.prev = cur.prev;        cur.prev.next = newNode;        newNode.next = cur;        cur.prev = newNode;        // 链表节点个数增加        ++ size;    }    public void deleteAtIndex(int index) {        if (index &lt; 0 || index &gt;= size) {   // 数组越界            return;        }        // 快速寻找索引对应节点        ListNode cur = getByIndex(index);        // 删除索引对应的节点        cur.prev.next = cur.next;        cur.next.prev = cur.prev;        -- size;    }}// 双链表节点class ListNode {    int val;    ListNode prev;    ListNode next;    public ListNode() {    }    public ListNode(int val) {        this.val = val;    }}\n\n提交结果如下：\n解答成功:    执行耗时:5 ms,击败了100.00% 的Java用户    内存消耗:42.9 MB,击败了95.30% 的Java用户\n\n复杂度分析：\n\n时间复杂度：与优化前一致\n\n空间复杂度：与优化前一致\n\n\n","categories":["leetcode"],"tags":["刷题","链表","设计"]},{"title":"贪心算法","url":"/2024/03/12/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/","content":"贪心算法理论基础什么是贪心贪心的本质即选择每一阶段的局部最优，从而达到全局最优。\n一般数学证明贪心有如下两种方法：\n\n数学归纳法\n反证法\n\n贪心一般解题步骤贪心算法一般分为如下四步：\n\n将问题分解为若干个子问题\n找出适合的贪心策略\n求解每一个子问题的最优解\n将局部最优解堆叠成全局最优解\n\n分发饼干此题局部最优就是：\n大饼干喂给胃口大的，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。\n或者换成另外一个思路：小饼干先喂饱小胃口\n思路一class Solution {    // 思路1：优先考虑饼干，小饼干先喂饱小胃口    public int findContentChildren(int[] g, int[] s) {        Arrays.sort(g);        Arrays.sort(s);        int start = 0;        int count = 0;        for (int i = 0; i &lt; s.length &amp;&amp; start &lt; g.length; i++) {            if (s[i] &gt;= g[start]) {                start++;                count++;            }        }        return count;    }}\n\n思路二class Solution {    // 思路2：优先考虑胃口，先喂饱大胃口    public int findContentChildren(int[] g, int[] s) {        Arrays.sort(g);        Arrays.sort(s);        int count = 0;        int start = s.length - 1;        // 遍历胃口        for (int index = g.length - 1; index &gt;= 0; index--) {            if(start &gt;= 0 &amp;&amp; g[index] &lt;= s[start]) {                start--;                count++;            }        }        return count;    }}\n\n摇摆序列贪心将示例根据元素值，画出折线图\n局部最优：删除单调坡度上的节点，即可得到两个局部峰值；\n整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列\n需要考虑三种情况：\n\n上下坡中有平坡\n数组首位两端 特殊情况\n单调坡中有平坡\n\nclass Solution {    public int wiggleMaxLength(int[] nums) {        if (nums.length &lt;= 1) {            return nums.length;        }        //当前差值        int curDiff = 0;        //上一个差值        int preDiff = 0;        int count = 1;        for (int i = 1; i &lt; nums.length; i++) {            //得到当前差值            curDiff = nums[i] - nums[i - 1];            //如果当前差值和上一个差值为一正一负            //等于0的情况表示初始时的preDiff            if ((curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0) || (curDiff &lt; 0 &amp;&amp; preDiff &gt;= 0)) {                count++;                preDiff = curDiff;            }        }        return count;    }}\n\n\n动态规划// DPclass Solution {    public int wiggleMaxLength(int[] nums) {        // 0 i 作为波峰的最大长度        // 1 i 作为波谷的最大长度        int dp[][] = new int[nums.length][2];        dp[0][0] = dp[0][1] = 1;        for (int i = 1; i &lt; nums.length; i++){            //i 自己可以成为波峰或者波谷            dp[i][0] = dp[i][1] = 1;            for (int j = 0; j &lt; i; j++){                if (nums[j] &gt; nums[i]){                    // i 是波谷                    dp[i][1] = Math.max(dp[i][1], dp[j][0] + 1);                }                if (nums[j] &lt; nums[i]){                    // i 是波峰                    dp[i][0] = Math.max(dp[i][0], dp[j][1] + 1);                }            }        }        return Math.max(dp[nums.length - 1][0], dp[nums.length - 1][1]);    }}\n\n最大子数组和贪心class Solution {    public int maxSubArray(int[] nums) {        if (nums.length == 1){            return nums[0];        }        int sum = Integer.MIN_VALUE;        int count = 0;        for (int i = 0; i &lt; nums.length; i++){            count += nums[i];            sum = Math.max(sum, count); // 取区间累计的最大值（相当于不断确定最大子序终止位置）            if (count &lt;= 0){                count = 0; // 相当于重置最大子序起始位置，因为遇到负数一定是拉低总和            }        }       return sum;    }}\n\n动态规划// DP 方法class Solution {    public int maxSubArray(int[] nums) {        int ans = Integer.MIN_VALUE;        int[] dp = new int[nums.length];        dp[0] = nums[0];        ans = dp[0];        for (int i = 1; i &lt; nums.length; i++){            dp[i] = Math.max(dp[i-1] + nums[i], nums[i]);            ans = Math.max(dp[i], ans);        }        return ans;    }}\n\n买卖股票最佳时机II解决该题注意两点：\n\n只有一只股票\n当前只有买股票或卖股票的操作\n\n贪心将最终利润分解为每天利润，即可容易想到最优贪心策略\n// 贪心思路class Solution {    public int maxProfit(int[] prices) {        int result = 0;        for (int i = 1; i &lt; prices.length; i++) {            result += Math.max(prices[i] - prices[i - 1], 0);        }        return result;    }}\n\n动态规划class Solution { // 动态规划    public int maxProfit(int[] prices) {        // [天数][是否持有股票]        int[][] dp = new int[prices.length][2];        // base case        dp[0][0] = 0;        dp[0][1] = -prices[0];        for (int i = 1; i &lt; prices.length; i++) {            // dp公式            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);        }        return dp[prices.length - 1][0];    }}\n\n跳跃游戏重点在于：将问题转化为跳跃覆盖范围究竟可不可以覆盖到终点\n贪心贪心局部最优解：每次取跳跃最大覆盖范围\n整体最优解：计算整体覆盖范围能否到达终点\nclass Solution {    public boolean canJump(int[] nums) {        if (nums.length == 1) {            return true;        }        //覆盖范围, 初始覆盖范围应该是0，因为下面的迭代是从下标0开始的        int coverRange = 0;        //在覆盖范围内更新最大的覆盖范围        for (int i = 0; i &lt;= coverRange; i++) {            coverRange = Math.max(coverRange, i + nums[i]);            if (coverRange &gt;= nums.length - 1) {                return true;            }        }        return false;    }}\n\n跳跃游戏II贪心的思路，局部最优：当前可移动距离尽可能多走，如果还没到终点，步数再加一。整体最优：一步尽可能多走，从而达到最少步数。\n即，以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点.\n贪心(版本一)// 版本一class Solution {    public int jump(int[] nums) {        if (nums == null || nums.length == 0 || nums.length == 1) {            return 0;        }        //记录跳跃的次数        int count=0;        //当前的覆盖最大区域        int curDistance = 0;        //最大的覆盖区域        int maxDistance = 0;        for (int i = 0; i &lt; nums.length; i++) {            //在可覆盖区域内更新最大的覆盖区域            maxDistance = Math.max(maxDistance,i+nums[i]);            //说明当前一步，再跳一步就到达了末尾            if (maxDistance&gt;=nums.length-1){                count++;                break;            }            //走到当前覆盖的最大区域时，更新下一步可达的最大区域            if (i==curDistance){                curDistance = maxDistance;                count++;            }        }        return count;    }}\n\n\n贪心(版本二)// 版本二class Solution {    public int jump(int[] nums) {        int result = 0;        // 当前覆盖的最远距离下标        int end = 0;        // 下一步覆盖的最远距离下标        int temp = 0;        for (int i = 0; i &lt;= end &amp;&amp; end &lt; nums.length - 1; ++i) {            temp = Math.max(temp, i + nums[i]);            // 可达位置的改变次数就是跳跃次数            if (i == end) {                end = temp;                result++;            }        }        return result;    }}\n\nK次取反后最大化的数组和本题的解题步骤为：\n\n第一步：将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小\n第二步：从前向后遍历，遇到负数将其变为正数，同时K–\n第三步：如果K还大于0，那么反复转变数值最小的元素，将K用完\n第四步：求和\n\n贪心class Solution {    public int largestSumAfterKNegations(int[] nums, int K) {        // 将数组按照绝对值大小从大到小排序，注意要按照绝对值的大小    nums = IntStream.of(nums)             .boxed()             .sorted((o1, o2) -&gt; Math.abs(o2) - Math.abs(o1))             .mapToInt(Integer::intValue).toArray();    int len = nums.length;\t        for (int i = 0; i &lt; len; i++) {        //从前向后遍历，遇到负数将其变为正数，同时K--        if (nums[i] &lt; 0 &amp;&amp; K &gt; 0) {        \tnums[i] = -nums[i];        \tK--;        }    }    // 如果K还大于0，那么反复转变数值最小的元素，将K用完    if (K % 2 == 1) nums[len - 1] = -nums[len - 1];    return Arrays.stream(nums).sum();    }}\n\n总结需要注重贪心的思考方式(局部最优，贪心最优)。\n加油站方法一直接从全局进行贪心选择，情况如下：\n\n情况一：如果gas的总和小于cost总和，那么无论从哪里出发，一定是跑不了一圈的\n\n情况二：rest[i] = gas[i]-cost[i]为一天剩下的油，i从0开始计算累加到最后一站，如果累加没有出现负数，说明从0出发，油就没有断过，那么0就是起点。\n\n情况三：如果累加的最小值是负数，汽车就要从非0节点出发，从后向前，看哪个节点能把这个负数填平，能把这个负数填平的节点就是出发节点。\n\n\nclass Solution {    public int canCompleteCircuit(int[] gas, int[] cost) {        int sum = 0;        int min = 0;        for (int i = 0; i &lt; gas.length; i++) {            sum += (gas[i] - cost[i]);            min = Math.min(sum, min);        }        if (sum &lt; 0) return -1;        if (min &gt;= 0) return 0;        for (int i = gas.length - 1; i &gt; 0; i--) {            min += (gas[i] - cost[i]);            if (min &gt;= 0) return i;        }        return -1;    }}\n\n方法二(贪心)首先如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明 各个站点的加油站 剩油量rest[i]相加一定是大于等于零的。\n每个加油站的剩余量rest[i]为gas[i] - cost[i]。\ni从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0, i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。\n即局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。\n// 解法2class Solution {    public int canCompleteCircuit(int[] gas, int[] cost) {        int curSum = 0;        int totalSum = 0;        int index = 0;        for (int i = 0; i &lt; gas.length; i++) {            curSum += gas[i] - cost[i];            totalSum += gas[i] - cost[i];            if (curSum &lt; 0) {                index = (i + 1) % gas.length ;                 curSum = 0;            }        }        if (totalSum &lt; 0) return -1;        return index;    }}\n\n分发糖果在考虑吧局部贪心策略时，如果兼顾两边，则容易顾此失彼。\n所以可以采用两次贪心的策略：\n\n即从左到右遍历，只比较右边孩子评分比左边大的情况\n从右到左遍历，只比较左边孩子评分比右边大的情况\n\n以此从局部最优推出全局最优，即相邻孩子中，评分高的孩子获得更多的糖果。\n贪心class Solution {    /**         分两个阶段         1、起点下标1 从左往右，只要 右边 比 左边 大，右边的糖果=左边 + 1         2、起点下标 ratings.length - 2 从右往左， 只要左边 比 右边 大，此时 左边的糖果应该 取本身的糖果数（符合比它左边大） 和 右边糖果数 + 1 二者的最大值，这样才符合 它比它左边的大，也比它右边大    */    public int candy(int[] ratings) {        int len = ratings.length;        int[] candyVec = new int[len];        candyVec[0] = 1;        for (int i = 1; i &lt; len; i++) {            candyVec[i] = (ratings[i] &gt; ratings[i - 1]) ? candyVec[i - 1] + 1 : 1;        }        for (int i = len - 2; i &gt;= 0; i--) {            if (ratings[i] &gt; ratings[i + 1]) {                candyVec[i] = Math.max(candyVec[i], candyVec[i + 1] + 1);            }        }        int ans = 0;        for (int num : candyVec) {            ans += num;        }        return ans;    }}\n\n柠檬水找零贪心局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。\nclass Solution {    public boolean lemonadeChange(int[] bills) {        int five = 0;        int ten = 0;        for (int i = 0; i &lt; bills.length; i++) {            if (bills[i] == 5) {                five++;            } else if (bills[i] == 10) {                five--;                ten++;            } else if (bills[i] == 20) {                if (ten &gt; 0) {                    ten--;                    five--;                } else {                    five -= 3;                }            }            if (five &lt; 0 || ten &lt; 0) return false;        }                return true;    }}\n\n根据身高重建队列当遇到两个维度的问题时，一定要思考如何确定一个维度，然后再按照另一个维度对问题进行求解。\n贪心：即对于该题，先按身高降序排序，身高相等则按k[i]升序排；\n\n局部最优：优先按身高高的people的k来插入。插入操作过后的people满足队列属性\n\n全局最优：最后都做完插入操作，整个队列满足题目队列属性\n\n\nclass Solution {    public int[][] reconstructQueue(int[][] people) {        // 身高从大到小排（身高相同k小的站前面）        Arrays.sort(people, (a, b) -&gt; {            if (a[0] == b[0]) return a[1] - b[1];   // a - b 是升序排列，故在a[0] == b[0]的狀況下，會根據k值升序排列            return b[0] - a[0];   //b - a 是降序排列，在a[0] != b[0]，的狀況會根據h值降序排列        });        LinkedList&lt;int[]&gt; que = new LinkedList&lt;&gt;();        for (int[] p : people) {            que.add(p[1],p);   //Linkedlist.add(index, value)，會將value插入到指定index裡。        }        return que.toArray(new int[people.length][]);    }}\n\n总结关于出现两个维度一起考虑的情况，一般技巧都是确定一边然后再贪心另外一边，避免两边一起考虑，顾此失彼。\n用最少的数量的箭引爆气球局部最优：当气球出现重叠，一起射，所用弓箭最少。全局最优：把所有气球射爆所用弓箭最少\n排序+贪心为了尽可能使气球重叠，则对数据进行排序，排序后，重叠气球，则只需要一支箭即可。\n/** * 时间复杂度 : O(NlogN)  排序需要 O(NlogN) 的复杂度 * 空间复杂度 : O(logN) java所使用的内置函数用的是快速排序需要 logN 的空间 */class Solution {    public int findMinArrowShots(int[][] points) {        // 根据气球直径的开始坐标从小到大排序        // 使用Integer内置比较方法，不会溢出        Arrays.sort(points, (a, b) -&gt; Integer.compare(a[0], b[0]));        int count = 1;  // points 不为空至少需要一支箭        for (int i = 1; i &lt; points.length; i++) {            if (points[i][0] &gt; points[i - 1][1]) {  // 气球i和气球i-1不挨着，注意这里不是&gt;=                count++; // 需要一支箭            } else {  // 气球i和气球i-1挨着                points[i][1] = Math.min(points[i][1], points[i - 1][1]); // 更新重叠气球最小右边界            }        }        return count;    }}\n\n无重叠区间一般思路：\n按照右边界排序，从左向右记录非交叉区间的个数。最后用区间总数减去非交叉区间的个数就是需要移除的区间个数。\n排序+贪心class Solution {    public int eraseOverlapIntervals(int[][] intervals) {        Arrays.sort(intervals, (a,b)-&gt; {            return Integer.compare(a[0],b[0]);        });        int count = 1;        for(int i = 1;i &lt; intervals.length;i++){            if(intervals[i][0] &lt; intervals[i-1][1]){                intervals[i][1] = Math.min(intervals[i - 1][1], intervals[i][1]);                continue;            }else{                count++;            }            }        return intervals.length - count;    }}\n\n另一种写法按左边排序，不管右边顺序。相交的时候取最小的右边。\nclass Solution {    public int eraseOverlapIntervals(int[][] intervals) {        Arrays.sort(intervals, (a,b)-&gt; {            return Integer.compare(a[0],b[0]);        });        int remove = 0;        int pre = intervals[0][1];        for(int i = 1; i &lt; intervals.length; i++) {            if(pre &gt; intervals[i][0]) {                remove++;                pre = Math.min(pre, intervals[i][1]);            }            else pre = intervals[i][1];        }        return remove;    }}\n\n划分字母区间在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。\n可以分为如下两步：\n\n统计每一个字符最后出现的位置\n从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点\n\n贪心+哈希class Solution {    public List&lt;Integer&gt; partitionLabels(String S) {        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();        int[] edge = new int[26];        char[] chars = S.toCharArray();        for (int i = 0; i &lt; chars.length; i++) {            edge[chars[i] - 'a'] = i;        }        int idx = 0;        int last = -1;        for (int i = 0; i &lt; chars.length; i++) {            idx = Math.max(idx,edge[chars[i] - 'a']);            if (i == idx) {                list.add(i - last);                last = i;            }        }        return list;    }}\n\n另一种思路(参照重叠区间)统计字符串中所有字符的起始和结束位置，记录这些区间，将区间按左边界从小到大排序，找到边界将区间划分成组，互不重叠。找到的边界就是答案。\nclass Solution{        public  int[][] findPartitions(String s) {        List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();        int[][] hash = new int[26][2];//26个字母2列 表示该字母对应的区间        for (int i = 0; i &lt; s.length(); i++) {            //更新字符c对应的位置i            char c = s.charAt(i);            if (hash[c - 'a'][0] == 0) hash[c - 'a'][0] = i;            hash[c - 'a'][1] = i;            //第一个元素区别对待一下            hash[s.charAt(0) - 'a'][0] = 0;        }        List&lt;List&lt;Integer&gt;&gt; h = new LinkedList&lt;&gt;();        //组装区间        for (int i = 0; i &lt; 26; i++) {            //if (hash[i][0] != hash[i][1]) {            temp.clear();            temp.add(hash[i][0]);            temp.add(hash[i][1]);            //System.out.println(temp);            h.add(new ArrayList&lt;&gt;(temp));            // }        }        // System.out.println(h);        // System.out.println(h.size());        int[][] res = new int[h.size()][2];        for (int i = 0; i &lt; h.size(); i++) {            List&lt;Integer&gt; list = h.get(i);            res[i][0] =  list.get(0);            res[i][1] =  list.get(1);        }        return res;    }    public  List&lt;Integer&gt; partitionLabels(String s) {        int[][] partitions = findPartitions(s);        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();        Arrays.sort(partitions, (o1, o2) -&gt; Integer.compare(o1[0], o2[0]));        int right = partitions[0][1];        int left = 0;        for (int i = 0; i &lt; partitions.length; i++) {            if (partitions[i][0] &gt; right) {                //左边界大于右边界即可纪委一次分割                res.add(right - left + 1);                left = partitions[i][0];            }            right = Math.max(right, partitions[i][1]);        }        //最右端        res.add(right - left + 1);        return res;    }}\n\n","categories":["代码随想录","回溯算法"],"tags":["贪心","算法"]},{"title":"赎金信_383","url":"/2023/12/10/%E8%B5%8E%E9%87%91%E4%BF%A1-383/","content":"赎金信383. 赎金信 - 力扣（LeetCode）\n给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。\n如果可以，返回 true ；否则返回 false 。\nmagazine 中的每个字符只能在 ransomNote 中使用一次。\n示例 1：\n输入： ransomNote = “a”, magazine = “b”输出： false\n示例 2：\n输入： ransomNote = “aa”, magazine = “ab”输出： false\n示例 3：\n输入： ransomNote = “aa”, magazine = “aab”输出： true\n提示：\n\n\nransomNote 和 magazine 由小写英文字母组成\n\n解题解法一(数组哈希)思路分析：\n\n根据题意得，若ransomNote能由magazine里得字符构成，则说明ransomNote中得字符，magazine中均有，且数目不少于ransomNote中得字符数目\n\n因为小写字母只有26个，所以可以使用数组hash来统计对应字符得数量\n\n首先遍历字符串ransomNote，并统计字符及数目，然后在再遍历magazine，若出现ransomNote中得字符，则hash[ch]--\n\n遍历结束后，再遍历数组hash，若出现数组元素大于0，则说明ransomNote 不能由 magazine 里面的字符构成，返回false\n\n\n实现代码如下：\nclass Solution {    public boolean canConstruct(String ransomNote, String magazine) {        if (ransomNote.length() &gt; magazine.length()) {            return false;    // 若ransomNote得长度大于magazine的长度 则不满足条件        }        int lenR = ransomNote.length();        // 字符串 ransomNote 的长度        int lenM = magazine.length();        // 字符串 magazine 的长度        int[] hash = new int[26];        // 遍历字符串 ransomNote        for (int i = 0; i &lt; lenR; ++i) {            hash[ ransomNote.charAt(i) - 'a' ] ++;        }        // 再遍历字符串 magazine        for (int i = 0; i &lt; lenM; ++i) {            hash[ magazine.charAt(i) - 'a' ] --;        }        // 遍历哈希数组hash 判断是否满足条件        for (int i = 0; i &lt; 26; ++i) {            if (hash[i] &gt; 0)    // 有字符数目大于0 则说明无法构成ransomNote                return false;        }        return true;    // 满足条件    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了99.86% 的Java用户    内存消耗:42.7 MB,击败了47.60% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，n指字符串ransomNote的长度，m指字符串magazine的长度\n\n空间复杂度：O(1)，声明使用的变量空间为 常量级\n\n\n","categories":["leetcode"],"tags":["刷题","哈希表","字符串","计数"]},{"title":"软件项目管理","url":"/2024/03/06/%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","content":"基本概念基本概念项目是为了创造一个唯一的产品或提供一个唯一的服务而进行的临时性的努力。\n项目特征：\n\n有明确的目标。\n项目活动之间具有相关性。\n限定的周期。\n独特性。\n资源成本的约束性。\n项目的不确定性。\n\n项目集()是由一些项目(Project)组成的集合。\n学习课程软件项目管理——北京邮电大学\n","categories":["软件项目管理"],"tags":["软件","项目","管理"]},{"title":"逆波兰表达式_150","url":"/2023/12/22/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F-150/","content":"逆波兰表达式给你一个字符串数组 tokens ，表示一个根据 逆波兰表示法 表示的算术表达式。\n请你计算该表达式。返回一个表示表达式值的整数。\n注意：\n\n有效的算符为 '+'、'-'、'*' 和 '/' 。\n每个操作数（运算对象）都可以是一个整数或者另一个表达式。\n两个整数之间的除法总是 向零截断 。\n表达式中不含除零运算。\n输入是一个根据逆波兰表示法表示的算术表达式。\n答案及所有中间计算结果可以用 32 位 整数表示。\n\n示例 1：\n输入： tokens = [“2”,”1”,”+”,”3”,”*”]输出： 9解释： 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9\n示例 2：\n输入： tokens = [“4”,”13”,”5”,”/“,”+”]输出： 6解释： 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6\n示例 3：\n输入： tokens = [“10”,”6”,”9”,”3”,”+”,”-11”,”“,”/“,”“,”17”,”+”,”5”,”+”]输出： 22解释： 该算式转化为常见的中缀算术表达式为：  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5= ((10 * (6 / (12 * -11))) + 17) + 5= ((10 * (6 / -132)) + 17) + 5= ((10 * 0) + 17) + 5= (0 + 17) + 5= 17 + 5= 22\n提示：\n\n\ntokens[i] 是一个算符（\"+\"、\"-\"、\"*\" 或 \"/\"），或是在范围 [-200, 200] 内的一个整数\n\n逆波兰表达式：\n逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。\n\n平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。\n该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。\n\n逆波兰表达式主要有以下两个优点：\n\n去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。\n适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中\n\n解法一(栈deque+模拟)思路分析：\n\n根据题目提示以及逆波兰表达式的定义，我们使用栈来存储字符串数组，即遍历字符串数组，并模拟逆波兰表达式的计算方式\n\n在遍历字符串的过程中，如果遇到数字字符，则压入栈中\n\n如果遇到运算字符，则从栈中弹出两个元素，进行运算字符对应的运算，然后再把最后结果压入栈中\n\n遍历结束后，栈中唯一的元素即为逆波兰表达式的运算结果\n\n同时根据题目意思，输入的字符串数组刚好为一个完整的逆波兰表达式，因此不需要考虑边界条件\n\n\n实现代码如下：\nclass Solution {    public int evalRPN(String[] tokens) {        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();    // 辅助计算栈        for (String str: tokens) {    //遍历字符串数组            if (str.equals(\"+\") || str.equals(\"-\") || str.equals(\"*\") || str.equals(\"/\")) {                // 当字符串是运算符号时 从栈中取出两个元素 执行计算                int num1 = deque.pop();                int num2 = deque.pop();                // 需要注意 在执行二元运算时 二元的顺序 应该nums2在前nums1在后                switch (str) {                    case \"+\" :                         deque.push(num2+num1);                        break;                    case \"-\" :                        deque.push(num2-num1);                        break;                    case \"*\":                        deque.push(num2*num1);                        break;                    case \"/\":                        deque.push(num2/num1);                    default:                }            } else { // 字符串为数字字符 则压入栈中                deque.push(Integer.parseInt(str));            }        }        return deque.pop();        // 栈中最后一个元素 即为表达式计算结果    }}\n\n提交结果如下：\n解答成功:    执行耗时:6 ms,击败了57.69% 的Java用户    内存消耗:43.6 MB,击败了5.01% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，即遍历一遍字符串数组\n\n空间复杂度：，需要使用栈来存储运算时的数字\n\n\n","categories":["leetcode"],"tags":["刷题","数组","栈","数学"]},{"title":"重复的子字符串_459","url":"/2023/12/19/%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-459/","content":"重复的子字符串459. 重复的子字符串 - 力扣（LeetCode）\n给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。\n示例 1:\n输入: s = “abab”输出: true解释: 可由子串 “ab” 重复两次构成。\n示例 2:\n输入: s = “aba”输出: false\n示例 3:\n输入: s = “abcabcabcabc”输出: true解释: 可由子串 “abc” 重复四次构成。 (或子串 “abcabc” 重复两次构成。)\n提示：\n\n\ns 由小写英文字母组成\n\n解法一(枚举)思路分析：\n\n长度为n的字符串可以由长度为m的子串t重复多次构成，则存在以下关系：\n\nn 一定是m的倍数\n\n子串t一定是s的前缀\n\n对于任意，有s[i] = s[i-m]\n\n\n\n即字符串s中长度为m的前缀就是t，且在这之后的每一个位置上的字符s[i]，都需要与该位置之前的m个字符s[i-m]相等\n\n且因为字符串s由某个字串构成，即子串至少需要重复一次，即m不会大于n的一半，所以只需要在范围内遍历即可\n\n\n实现代码如下：\nclass Solution {    public boolean repeatedSubstringPattern(String s) {        int n = s.length();        for (int i = 1; i &lt;= n/2; ++i) {    // i指子串长度            if (n % i == 0) {                boolean flag = true;                for (int j = i; j &lt; n; ++ j) {    // 遍历判断字符串s是否由长度为i的子串构成                    if (s.charAt(j) != s.charAt(j-i)) {                        flag = false;                        break;                    }                }                if (flag) return true;    // 出现一个满足条件的子串 则返回true            }        }        return false;    }}\n\n提交结果如下：\n解答成功:    执行耗时:9 ms,击败了78.70% 的Java用户    内存消耗:43.5 MB,击败了5.02% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历寻找符合条件的子串长度需要时间复杂度为，判断子串是否符合需要时间复杂度为\n\n空间复杂度：，使用了常量空间\n\n\n解法二(字符串匹配+Java API)459. 重复的子字符串 - 力扣（LeetCode）\n思路分析：\n\n若字符串s可以写成形式，即由若干个重复子串构成，即将第一个子串，移动到字符串的末尾重新组成一个字符串，且有新组成的字符串依然还是等于字符串s\n\n同理，把两个字符串s联合组到一起，并移除第一个元素和最后一个元素，那么得到的字符串一定包含s，即s是联合组成的新字符串的一个子串\n\n即s由重复子串构成，则s有第二点提到的性质，这证明了充分性，而解题需要证明必要性，即s有第二点的性质，则s由重复子串构成\n\n如何证明必要性；即有字符串t = s+s，且s在t中的起始位置不为0或n，那么s就满足题目要求\n\n详细证明如：详细证明\n\n\n实现代码如下：\nclass Solution {    public boolean repeatedSubstringPattern(String s) {        return (s+s).indexOf(s, 1) != s.length();    }}\n\n提交结果如下：\n解答成功:    执行耗时:82 ms,击败了38.79% 的Java用户    内存消耗:43.8 MB,击败了5.04% 的Java用户\n\n复杂度分析：\n\n语言自带字符串查找函数，不具体分析\n\n解法三(字符串匹配+KMP算法)思路分析：\n\n对于解法二中，查询字符串函数可以使用KMP算法来实现\n\n且next数组对应于 字符串s的前缀表右移一步\n\n\n实现代码如下：\nclass Solution {    public boolean repeatedSubstringPattern(String s) {        return kmp(s+s, s);    }    private boolean kmp(String s, String t) {        int sLen = s.length();    // 字符串s的长度        int tLen = t.length();    // 字符串t的长度        int[] next = new int[tLen];        // 创建next数组        // 初始化next数组        int j = -1;        next[0] = j;        for (int i = 1; i &lt; tLen; ++i) {            while (j &gt;= 0 &amp;&amp; t.charAt(i) != t.charAt(j+1)) {                j = next[j];            }            if (t.charAt(i) == t.charAt(j+1))                ++ j;            next[i] = j;        }        // 判断字符串t是否在字符串s中        j = -1;    // 与初始化next数组时对应        for (int i = 1; i &lt; sLen-1; ++i) {    // 只能判断子串t是否在字符串s[1:n-1)中            while (j &gt;= 0 &amp;&amp; s.charAt(i) != t.charAt(j+1)) {                j = next[j];            }            if (s.charAt(i) == t.charAt(j+1)) {                ++ j;            }            if (j == tLen-1) {                return true;            }        }        return false;    }}\n\n提交结果如下：\n解答成功:    执行耗时:15 ms,击败了49.46% 的Java用户    内存消耗:43.9 MB,击败了5.04% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，遍历字符串s和组成的字符串t\n\n空间复杂度：，next数组花费空间复杂度为\n\n\n解法四(优化解法三)思路分析：\n\n综合解法三和解法二的思路，可以发现 字符串由长度为i的前缀重复次构成，即设i为最小的起始位置，即gcd(n,i) = i\n\n且对于数组next[n-1]表示s具有长度为next[n-1]的相同的前缀和后缀，那么对于满足条件的字符串一定有next[n-1] = n-i即i = n-next[n-1]\n\n即满足条件则n是n-next[n-1]的倍数\n\n\n实现代码如下：\nclass Solution {    public boolean repeatedSubstringPattern(String s) {        int n = s.length();    // 字符串s的长度        int[] next = new int[n];    // next数组对应s的前缀表 右移        int j = -1;        next[0] = j;        for (int i = 1; i &lt; n; ++i) {            while (j &gt;= 0 &amp;&amp; s.charAt(i) != s.charAt(j+1)) {                j = next[j];            }            if (s.charAt(i) == s.charAt(j+1)) {                ++ j;            }            next[i] = j;        }        // 因为next数组对应s的前缀表右移一位        // 所以next[n-1]表示的是s具有长度为next[n-1]的相同前后缀的值-1        // 所以计算时字符串s相同前后缀的长度为 next[n-1]+1        // 所以判断 n 与 n-next[n-1]-1        // 且需要注意next[n-1]+1 应该大于等于0 保证字符串s具有相同的前后缀        return next[n-1] &gt;= 0 &amp;&amp; n % (n - next[n - 1] - 1) == 0;    }}\n\n提交结果如下：\n解答成功:    执行耗时:8 ms,击败了83.28% 的Java用户    内存消耗:44 MB,击败了5.04% 的Java用户\n\n复杂度分析：\n\n时间复杂度：，只需遍历一遍字符串s\n\n空间复杂度：，需要使用辅助数组next\n\n\n","categories":["leetcode"],"tags":["刷题","字符串","字符串匹配"]},{"title":"链表理论基础","url":"/2023/12/05/%E9%93%BE%E8%A1%A8%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/","content":"链表理论基础    链表：即通过指针串联在一起的线性结构，每个节点分为两部分：数据域和指针域(存放指向下一个节点的指针)，最后一个指针的指针域指向null\n链表的类型单链表    即链表的每个节点，分为两部分，数据域和指针域，指针域单向指向下一个节点\n\n双链表    双链表中，每个节点除了数据域外，有两个指针域，一个指向下一个节点，一个指向上一个节点\n    双链表 既可以向前查询也可以向后查询。\n\n循环链表    即链表的 首尾相连，构成循环链表，一般可以用来解决约瑟夫环的问题。\n\n链表的存储方式    数组在内存中是连续分布的，但是链表在内存中不是连续分布的。\n    因为链表是通过指针链接在内存中的各个节点，所以链表中的节点在内存中是不连续分布的，而是散乱分布在内存的某地址上，分配机制取决于操作系统的内存管理。\n如图：\n\n链表的定义(面试)一般链表定义如下：\nclass ListNode {    int val;    // 数据域 存储链表节点上的数据    ListNode next;      // 指针域 指向该节点的下一个节点    public ListNode(){  // 节点无参构造方法    }    public ListNode(int val) {  // 节点 有参(一个参数)构造方法        this.val = val;        next = null;    }    public ListNode(int val, ListNode next) {   // 节点 有参(两个参数)构造方法        this.val = val;        this.next = next;    }}\n\n链表的操作删除节点如图，若要删除D节点：\n\n即只需将C节点的next指针指向E节点即可，在Java中，会有内存回收机制来释放D节点占有的内存，且删除节点操作的时间复杂度为O(1)，即只需C.next == D.next\n添加节点如图所示：\n\n即实现该操作只需F.next = C.next; C.next = F即可，时间复杂度为O(1)\n性能分析将数据与链表进行对比，如图所示：\n\n    因为数组定义时，长度是固定的，添加新元素时，需要改变数组长度，重新定义一个数组，而链表的长度不固定，可以动态增删，只需修改节点指向的位置即可。\n例题移除链表元素题目链接\n使用原来链表进行删除操作    即直接使用原来链表进行操作，对于头节点的操作，与其他操作节点不一样，需要对头节点进行特殊判断。\n代码如下：\nclass Solution {    public ListNode removeElements(ListNode head, int val) {        // 对头节点作特殊判断        while (head != null &amp;&amp; head.val == val)            head = head.next;        // 经过head判断后 head可能已经指向了空值 需要进行判断        // 或链表原本就为 空 同样直接返回null        if (head == null)     // 链表为空时 直接返回空            return null;        // 排除头节点后 对其他节点进行判断 是否删除        ListNode cur = head;    // 保留头节点head        while (cur.next != null) {    // 注意此时cur不能为空            if (cur.next.val == val)                cur.next = cur.next.next;            else                cur = cur.next;        }        return head;    }} \n\n\n时间复杂度：O(1)\n\n空间复杂度：O(1)\n\n\n设置虚拟头节点进行删除操作       设置一个虚拟头节点，即dummy.next = head，则不在需要对原来的头节点进行特殊判断，使原链表中的所有节点都可以按照统一的方式进行移除。\n代码如下：\nclass Solution {    public ListNode removeElements(ListNode head, int val) {        if (head == null)     // 链表为空时 直接返回空            return null;        ListNode dummy = new ListNode();        dummy.next = head;        // 用新节点指向头节点 则在进行遍历检查时 可以检查到头节点        ListNode nHead = dummy;    // 保存p节点        while (dummy.next != null) {    // 保证p的下一个节点不为空            if (dummy.next.val == val) {    // 若p节点的下一个节点的值为val 则删除                dummy.next = dummy.next.next;    // 删除p节点的下一个节点            } else {    // 若p节点的下一个节点值不为val 则继续遍历                dummy = dummy.next;            }        }        return nHead.next;    // nHead保存的是p节点 则应该返回其指向的下一个节点 才是新头节点    }}\n\n\n时间复杂度：O(1)\n\n空间复杂度：O(1)\n\n\n使用递归的方式    链表的定义具有递归的性质，所以该题可以使用递归的方式求解。\n\n 对于头节点，若头节点的值等于val则需要删除头节点，返回头节点的下一个节点，下一个节点又变成了一个新的头节点\n\n若头节点的值不等于val，则不需要删除头节点，将head保留\n\n\n代码如下：\nclass Solution {    // 递归    public ListNode removeElements(ListNode head, int val) {        if (head == null) {            return null;    // 若当前节点为空 则直接返回null        }        head.next = removeElements(head.next, val);        if (head.val == val) {    // 若当前节点需要被删除 则返回当前节点的下一个节点            return head.next;        } else {            // 当前节点不需要被删除 则直接返回            return head;        }    }}\n\n\n时间复杂度：O(1)\n\n空间复杂度：O(1)\n\n\n设计链表原题链接\n链表有两种操作方式：\n\n使用原来的链表进行操作\n\n设置一个虚拟头节点再进行操作\n\n\n单链表+虚拟头节点代码如下：\n//单链表class ListNode {    int val;    ListNode next;    ListNode(){}    ListNode(int val) {        this.val=val;    }}class MyLinkedList {    //size存储链表元素的个数    int size;    //虚拟头结点    ListNode head;    //初始化链表    public MyLinkedList() {        size = 0;        head = new ListNode(0);    }    //获取第index个节点的数值，注意index是从0开始的，第0个节点就是头结点    public int get(int index) {        //如果index非法，返回-1        if (index &lt; 0 || index &gt;= size) {            return -1;        }        ListNode currentNode = head;        //包含一个虚拟头节点，所以查找第 index+1 个节点        for (int i = 0; i &lt;= index; i++) {            currentNode = currentNode.next;        }        return currentNode.val;    }    //在链表最前面插入一个节点，等价于在第0个元素前添加    public void addAtHead(int val) {        addAtIndex(0, val);    }    //在链表的最后插入一个节点，等价于在(末尾+1)个元素前添加    public void addAtTail(int val) {        addAtIndex(size, val);    }    // 在第 index 个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。    // 如果 index 等于链表的长度，则说明是新插入的节点为链表的尾结点    // 如果 index 大于链表的长度，则返回空    public void addAtIndex(int index, int val) {        if (index &gt; size) {            return;        }        if (index &lt; 0) {            index = 0;        }        size++;        //找到要插入节点的前驱        ListNode pred = head;        for (int i = 0; i &lt; index; i++) {            pred = pred.next;        }        ListNode toAdd = new ListNode(val);        toAdd.next = pred.next;        pred.next = toAdd;    }    //删除第index个节点    public void deleteAtIndex(int index) {        if (index &lt; 0 || index &gt;= size) {            return;        }        size--;        if (index == 0) {            head = head.next;        return;        }        ListNode pred = head;        for (int i = 0; i &lt; index ; i++) {            pred = pred.next;        }        pred.next = pred.next.next;    }}\n\n\n时间复杂度：和index有关的操作时间复杂度为O(n)，其余为O(1)\n\n空间复杂度： O(n)\n\n\n双链表    双链表可以从两端遍历链表，因此再对链表进行遍历查询时，可以通过比较哪边距离更短，来提高查询的速度，同时相关的代码块也可以提取出一个专门查询链表索引对应节点的接口。\n代码如下：\nclass MyLinkedList {    int size;   // 记录节点个数    ListNode preNode;   // 虚拟头节点    ListNode tailNode;  // 虚拟尾节点    public MyLinkedList() {     // 初始化双链表        this.size = 0;        preNode = new ListNode();        tailNode = new ListNode();        preNode.next = tailNode;        tailNode.prev = preNode;    }    public int get(int index) {        if (index &lt; 0 || index &gt;= size) {   // 判断索引是否越界            return -1;        }        ListNode cur;        // 根据索引的位置 判断两边遍历时间        if (index &lt; size/2) {   // 索引更靠近左边            cur = preNode;            for (int i = 0; i &lt;= index; ++ i) {     // 寻找索引对应的节点                cur = cur.next;            }        } else {     // 说明索引更靠近右边 使用虚拟尾节点查找更快            cur = tailNode;            for (int i = 0; i &lt; size-index; ++i) {                cur = cur.prev;            }        }        return cur.val;    }    public void addAtHead(int val) {        addAtIndex(0, val);    }    public void addAtTail(int val) {        addAtIndex(size, val);    }    public void addAtIndex(int index, int val) {        if (index &gt; size) {            return ;    // 索引越界 不添加到链表中        }        if (index &lt; 0) index = 0;        // 快速寻找索引对应节点        ListNode cur;        // 根据索引的位置 判断两边遍历时间        if (index &lt; size/2) {   // 索引更靠近左边            cur = preNode;            for (int i = 0; i &lt;= index; ++ i) {     // 寻找索引对应的节点                cur = cur.next;            }        } else {     // 说明索引更靠近右边 使用虚拟尾节点查找更快            cur = tailNode;            for (int i = 0; i &lt; size-index; ++i) {                cur = cur.prev;            }        }        // 在索引对应节点前添加节点        ListNode newNode = new ListNode(val);        newNode.prev = cur.prev;        cur.prev.next = newNode;        newNode.next = cur;        cur.prev = newNode;        // 链表节点个数增加        ++ size;    }    public void deleteAtIndex(int index) {        if (index &lt; 0 || index &gt;= size) {   // 数组越界            return;        }        // 快速寻找索引对应节点        ListNode cur;        // 根据索引的位置 判断两边遍历时间        if (index &lt; size/2) {   // 索引更靠近左边            cur = preNode;            for (int i = 0; i &lt;= index; ++ i) {     // 寻找索引对应的节点                cur = cur.next;            }        } else {     // 说明索引更靠近右边 使用虚拟尾节点查找更快            cur = tailNode;            for (int i = 0; i &lt; size-index; ++i) {                cur = cur.prev;            }        }        // 删除索引对应的节点        cur.prev.next = cur.next;        cur.next.prev = cur.prev;        -- size;    }}// 双链表节点class ListNode {    int val;    ListNode prev;    ListNode next;    public ListNode() {    }    public ListNode(int val) {        this.val = val;    }}\n\n反转链表原题链接\n双指针法\n首先定义一个指针cur，指向头节点，再定义一个pre指针，初始化为null，\n\n然后进行反转；先将cur的下一个节点进行保存为temp，然后再将cur的指向改为指向指针pre，此时已完成反转\n\n然后继续移动指针，反转下一个节点，即pre = cur，然后cur=temp\n\n直到指针cur=null说明链表已经反转完成，此时pre指针指向新链表的头节点。\n\n\n代码如下：\n// 双指针class Solution {    public ListNode reverseList(ListNode head) {        ListNode prev = null;        ListNode cur = head;        ListNode temp = null;        while (cur != null) {            temp = cur.next;// 保存下一个节点            cur.next = prev;            prev = cur;            cur = temp;        }        return prev;    }}\n\n递归法\n创建一个新的反转函数reverse(cur, pre)，根据双指针法，cur==null时，反转结束，且pre刚好指向新链表的头节点\n\n同时，实现反转只需cur.next = pre即可，然后继续反转剩下的节点\n\n\n代码如下：\n// 递归 class Solution {    public ListNode reverseList(ListNode head) {        return reverse(null, head);    }    private ListNode reverse(ListNode prev, ListNode cur) {        if (cur == null) {            return prev;        }        ListNode temp = null;        temp = cur.next;// 先保存下一个节点        cur.next = prev;// 反转        // 更新prev、cur位置        // prev = cur;        // cur = temp;        return reverse(cur, temp);    }}\n\n从后向前递归代码如下：\n// 从后向前递归class Solution {    ListNode reverseList(ListNode head) {        // 边缘条件判断        if(head == null ||  if (head.next == null)             return head;        // 递归调用，翻转第二个节点开始往后的链表        ListNode last = reverseList(head.next);        // 翻转头节点与第二个节点的指向        head.next.next = head;        // 此时的 head 节点为尾节点，next 需要指向 NULL        head.next = null;        return last;    } }\n\n使用虚拟头结点解决链表反转使用虚拟头结点，通过头插法实现链表的反转（不需要栈）\n// 迭代方法：增加虚头结点，使用头插法实现链表翻转public static ListNode reverseList1(ListNode head) {    // 创建虚头结点    ListNode dumpyHead = new ListNode(-1);    dumpyHead.next = null;    // 遍历所有节点    ListNode cur = head;    while(cur != null){        ListNode temp = cur.next;        // 头插法        cur.next = dumpyHead.next;        dumpyHead.next = cur;        cur = temp;    }    return dumpyHead.next;}\n\n使用栈解决反转链表的问题\n首先将所有的结点入栈\n然后创建一个虚拟虚拟头结点，让cur指向虚拟头结点。然后开始循环出栈，每出来一个元素，就把它加入到以虚拟头结点为头结点的链表当中，最后返回即可。\n\npublic ListNode reverseList(ListNode head) {    // 如果链表为空，则返回空    if (head == null) return null;    // 如果链表中只有只有一个元素，则直接返回    if (head.next == null) return head;    // 创建栈 每一个结点都入栈    Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;();    ListNode cur = head;    while (cur != null) {        stack.push(cur);        cur = cur.next;    }    // 创建一个虚拟头结点    ListNode pHead = new ListNode(0);    cur = pHead;    while (!stack.isEmpty()) {        ListNode node = stack.pop();        cur.next = node;        cur = cur.next;    }    // 最后一个元素的next要赋值为空    cur.next = null;    return pHead.next;}\n\n注意：\n        当整个出栈循环结束以后，cur正好指向原来链表的第一个结点，而此时结点1中的next指向的是结点2，因此最后还需要cur.next = null\n两两交换链表中的节点原题链接\n使用虚拟头节点+模拟交换代码如下：\nclass Solution {  public ListNode swapPairs(ListNode head) {        ListNode dumyhead = new ListNode(-1); // 设置一个虚拟头结点        dumyhead.next = head; // 将虚拟头结点指向head，这样方便后面做删除操作        ListNode cur = dumyhead;        ListNode temp; // 临时节点，保存两个节点后面的节点        ListNode firstnode; // 临时节点，保存两个节点之中的第一个节点        ListNode secondnode; // 临时节点，保存两个节点之中的第二个节点        while (cur.next != null &amp;&amp; cur.next.next != null) {            temp = cur.next.next.next;            firstnode = cur.next;            secondnode = cur.next.next;            cur.next = secondnode;       // 步骤一            secondnode.next = firstnode; // 步骤二            firstnode.next = temp;      // 步骤三            cur = firstnode; // cur移动，准备下一轮交换        }        return dumyhead.next;      }}\n\n递归代码如下：\n// 递归版本class Solution {    public ListNode swapPairs(ListNode head) {        // base case 退出提交        if(head == null || head.next == null) return head;        // 获取当前节点的下一个节点        ListNode next = head.next;        // 进行递归        ListNode newNode = swapPairs(next.next);        // 这里进行交换        next.next = head;        head.next = newNode;        return next;    }} \n\n删除链表的倒数第 N 个结点原题链接\n双指针+虚拟头节点    该题为双指针的经典应用，先让fast，移动n步，然后移动慢指针slow与快指针fast同时移动，直到fast指向链表末尾，此时slow指向的即为需要删除的节点。\n代码如下：\n注意：下列代码中快指针fast走了n+1步。\npublic ListNode removeNthFromEnd(ListNode head, int n){    ListNode dummyNode = new ListNode(0);    dummyNode.next = head;    ListNode fastIndex = dummyNode;    ListNode slowIndex = dummyNode;    // 只要快慢指针相差 n 个结点即可    for (int i = 0; i &lt;= n  ; i++){         fastIndex = fastIndex.next;    }    while (fastIndex != null){        fastIndex = fastIndex.next;        slowIndex = slowIndex.next;    }    //此时 slowIndex 的位置就是待删除元素的前一个位置。    //具体情况可自己画一个链表长度为 3 的图来模拟代码来理解    slowIndex.next = slowIndex.next.next;    return dummyNode.next;}\n\n链表相交题目链接\n    求两个链表交点节点的指针，交点不是数值相等，而是指针相等。\n双指针思路：\n\n求出两个链表长度的差值，然后两个指针移动到距离末尾距离相等的位置\n\n再让两个指针同时遍历，并比较是否指向节点相同\n\n\n代码如下：\npublic class Solution {    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {        if (headA == null || headB == null)            return null;    // 若任意一个链表为空 则说明两个链表没有交点        int lenA = 0;    // 链表headA的长度        int lenB = 0;    // 链表headB的长度        ListNode curA = headA;        ListNode curB = headB;        // 统计headA的节点数        while (curA != null) {            ++ lenA;            curA = curA.next;        }        // 统计headB的节点数        while (curB != null) {            ++ lenB;            curB = curB.next;        }        // 重新初始化curA和curB        curA = headA;        curB = headB;        // 保证两个链表中最长的链表为curA指向的链表        if (lenA &lt; lenB) {            // 交换长度            int t = lenB;            lenB = lenA;            lenA = t;            // 交换指向的链表            curA = headB;            curB = headA;        }        int gap = lenA-lenB;    // 两个链表的长度差        // 移动curA        // 使得curA到链表末尾长度 与 curB到链表末尾长度 一致        while (gap &gt; 0) {            -- gap;            curA = curA.next;        }        // 同时遍历两个链表 并判断是否相等        while (curA != null) {            if (curA == curB) {                return curA;            }            curA = curA.next;            curB = curB.next;        }        return null;    }}\n\n\n时间复杂度：O(n + m)\n空间复杂度：O(1)\n\n环形链表 II题目链接\n思路：\n\n判断链表是否有环\n\n有环，如何找到环的入口\n\n\n快慢指针法    首先fast指针每次移动两个节点，slow指针每次移动一个节点，当fast和slow相遇时，则说明链表中有环，且一定是在环中相遇。\n    当确定链表中有环时，设链表头部到环入口距离为a，环长度为b，则链表长度为，且快指针与慢指针第一次相遇时，两个指针所走步数有以下关系：\n表示走过的环的圈数\n    得出，则说明快慢指针第一次相遇时，慢指针走过步数，同时有从链表头部出发，到达环的入口所走步数关系为，所以快慢指针相遇时，只需慢指针再继续走a步即可找到环的入口。\n    因此，我们可以新声明一个指针ptr来从链表头部出发，且与slow指针同时移动，当ptr的步数为a时，慢指针步数也为a，此时两个指针均指向链表的环入口节点，且slow==ptr，即找到环的入口节点，直接返回即可。\n代码如下：\nclass Solution {    public ListNode detectCycle(ListNode head) {        ListNode fast = head;        ListNode slow = head;        // 若fast为空则说明不含有环 退出循环        while (fast != null &amp;&amp; fast.next != null) {            fast = fast.next.next;            slow = slow.next;            if (fast == slow) {        // 当fast与slow相遇                ListNode ptr = head;                while (ptr != slow) {    // 寻找环入口处节点                    slow = slow.next;                    ptr = ptr.next;                }                return ptr;            }        }        return null;    }}\n\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)\n\n\n总结\n学习文章代码随想录 (programmercarl.com)\n","categories":["代码随想录","链表"],"tags":["链表","算法"]},{"title":"长度最小的子数组_209","url":"/2023/11/30/%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84-209/","content":"长度最小的子数组209. 长度最小的子数组 - 力扣（LeetCode）\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n示例 1：\n输入：target = 7, nums = [2,3,1,2,4,3]输出：2解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n示例 2：\n输入：target = 4, nums = [1,4,4]输出：1\n\n示例 3：\n输入：target = 11, nums = [1,1,1,1,1,1,1,1]输出：0\n\n提示：\n\n1 &lt;= target &lt;= 10^9\n1 &lt;= nums.length &lt;= 10^5\n1 &lt;= nums[i] &lt;= 10^5\n\n进阶：\n\n如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。\n\n解题解法一(滑动窗口)思路分析：\n\n首先由提示可得数组长度为1 &lt;= nums.length &lt;= 10^5则如果使用暴力求解则时间会出现超时，因此我们需要考虑降低时间复杂度为O(n)\n我们可以考虑先找到一个满足条件的子数组，然后确定子数组的区间范围，在此区间范围上对子数组元素右端进行增加元素，增加完元素后再尝试对数组元素左端尝试减少元素，以此来找到长度最小的子数组\n在实现的过程中，需要注意区间的变化，同时也要注意找到的第一个满足条件的子数组的边界(e==nums.length)可能导致无法进入对子数组进行增减元素的循环，需要另外再建立一个循环来对子数组左端尝试减少元素，并时刻更新最小长度\n\n实现代码如下：\nclass Solution {    public int minSubArrayLen(int target, int[] nums) {       int sum = 0;       int min = nums.length;       int s = 0;       int e = 0;       // 判断是否存在符合条件的子数组       while (e &lt; nums.length &amp;&amp; sum &lt; target) {          sum += nums[e++];       }       if (e == nums.length) {       // 当子数组和父数组相等时          if (sum &lt; target)             return 0;     // 数组和依然小于目标值 则不存在符合条件的子数组       }       // 找到满足条件的第一个子数组 [s, e)       min = Math.min(min, e-s);       // 继续寻找其他子数组 并寻找长度最小的子数组       while (e &lt; nums.length) {          // 将指针e指向的数组元素加入到子数组中          sum = sum + nums[e];   // 此时 sum &gt; target 肯定成立 且子数组变为[s, e]          // 对子数组从左往右进行缩短          while (s &lt; e &amp;&amp; sum &gt;= target) {             sum -= nums[s];       // 将s指向的元素移出子数组             s ++;          }          // 进行回退 保证此时sum刚好满足 sum&gt;=target          s -= 1;          sum += nums[s];          // 此时子数组[s, e]刚好满足条件          min = Math.min(min, e-s+1);          e++;       }       // 此时子数组为[s, e)       // 对子数组进行进一步缩减 避免因为指针e指向数组末尾导致无法对指针s进行移动的情况       while (s &lt; e &amp;&amp; sum &gt;= target) {          sum -= nums[s];          s ++;       }       // 回退 保证子数组[s, e)满足条件       s-=1;       sum += nums[s];       min = Math.min(min, e-s);       return min;    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了99.87% 的Java用户    内存消耗:52.8 MB,击败了10.25% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，对数组进行遍历寻找子数组\n空间复杂度：O(1)\n\n优化解法一(滑动窗口代码简洁)思路分析：\n\n即创建两个指针；分别指向子数组的起始位置和子数组的末尾位置，初始均为0，每次子数组末尾指针添加元素后，则尝试在起始位置减少元素，并时刻更新子数组最短长度。\n\n实现代码如下：\nclass Solution {    public int minSubArrayLen(int target, int[] nums) {        int sum = 0;                // 统计子数组元素和        int min = nums.length+1;    // 子数组最大长度为nums.length        int s = 0;        // 指向子数组起始位置        int e = 0;        // 指向子数组末尾位置        while (e &lt; nums.length) {            sum += nums[e];        // 末尾指针添加元素到子数组中            while (sum &gt;= target) {                min = Math.min(min, e - s + 1);        // 此时区间为[s,e] 更新最小长度                // 此时含有s指针指向元素的子数组已经计算过长度 则                sum -= nums[s];        // 将起始指针指向元素踢出子数组                s ++;        // 更新区间起始位置            }            e++;        }        if (min == nums.length + 1) return 0;    // 若不存在则返回 0        return min;    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了99.87% 的Java用户    内存消耗:53 MB,击败了6.09% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n)，对数组进行遍历寻找子数组\n空间复杂度：O(1)\n\n","categories":["leetcode"],"tags":["刷题","数组","二分查找","滑动窗口","前缀和"]},{"title":"面试问题(一)","url":"/2024/03/12/%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-%E4%B8%80/","content":"自我介绍控制时间、与岗位相关的经历、为什么你能够胜任、为什么要应聘满足岗位的优势和亮点表现对岗位的理解和职业规划\nJDBC连接数据库怎么实现的(用的哪些类)\nDataSource数据源类\nConnection数据库连接类\nString类，用于写动态sql语句\nPreparedStatement，接收连接类，并用于设置动态sql的参数\nResultSet，查询数据时，用于接收查询结果\n\n参考文章\n对Java语言怎么理解的Java是一种面向对象的编程语言，具有跨平台、安全性高、稳定性好等特点。与C++等编程语言相比，Java拥有更简洁的语法和更好的跨平台性，而且Java的自动内存管理和垃圾回收机制减轻了程序员的负担，降低了程序出错的可能性。\nJava虚拟机（JVM）是Java的核心，它负责将Java源代码编译成字节码，并在不同平台上运行。JVM通过将字节码翻译成本地机器码，实现了Java的跨平台特性。而Java运行时环境（JRE）则包含JVM和运行Java程序所需的核心类库，提供了Java程序运行的基本环境.\n参考文章1参考文章2\njvm怎么运行的首先根据系统版本，加载jvm.cfg配置文件，然后根据配置文件找到jvm.dll文件，并初始化jvm，获取JNI接口，然后找到Java程序字节码文件的main方法并运行。\nJNI接口：是Java本地接口，通过JNI接口才能装载class文件，常用于和操作系统、硬件交互。\n参考文章\n你是怎么学习Java的你觉得作为一名Java程序员需要具备哪些素质你是如何理解面向对象的1、面向过程与面向对象对比理解；\n2、举生活案例\n3、讲述面向对象与面向过程的特点\n\n面向过程；注重于系统的一系列过程或函数，通过调用这些过程来完成任务；强调算法和流程，修改过程的一个地方，可能会影响到其他调用改过程的地方；一般是简单的、线性的任务。\n面向对象；更注重事情的参与者，先抽象出具有状态、行为的对象，然后通过对象执行方法的方式解决问题，强调封装、继承和多态；更易于维护和拓展，因为修改一个对象不会影响到其他对象；适合复杂的系统\n\n4、介绍面向对象的三个特性；封装、继承、多态\n（1）、封装\n就是通过访问修饰符private将对象内部的字段、属性隐藏起来，并通过定义公共接口来对其进行访问，从而提高代码安全性，隐藏对象的内部细节\n（2）、继承\n在Java中，子类通过extend关键字继承父类，然后子类可以重用父类的代码，并通过添加新的方法或重写已有的方法来扩展或改进功能；提高了代码的重用性和可扩展性\n（3）、多态\n多态是指相同的操作或方法可以在不同的对象上产生不同的行为，通过方法的重写和重载实现，多态允许一致的式处理不同类型的对象，提高了代码的灵活性。\n参考文章\n你在学校有没有参加过社团和学生会有\n你为什么选择Java这个行业个人爱好看好前景\n","categories":["面试题","实习"],"tags":["面试"]},{"title":"面试题_02_07_链表相交","url":"/2023/12/09/%E9%9D%A2%E8%AF%95%E9%A2%98-02-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/","content":"[面试题02.07] 链表相交面试题 02.07. 链表相交 - 力扣（LeetCode）\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n图示两个链表在节点 c1 开始相交 ：\n\n题目数据 保证 整个链式结构中不存在环。\n注意，函数返回结果后，链表必须 保持其原始结构 。\n示例 1：\n\n输入： intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出： Intersected at ‘8’解释： 相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n示例 2：\n\n输入： intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出： Intersected at ‘2’解释： 相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n示例 3：\n\n输入： intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出： null解释： 从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null 。\n提示：\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n0 &lt;= m, n &lt;= 3 * 10^4\n1 &lt;= Node.val &lt;= 10^5\n0 &lt;= skipA &lt;= m\n0 &lt;= skipB &lt;= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]\n\n进阶： 你能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？\n解题解法一(哈希表)思路分析：\n\n定义一个哈希表hashNode，用来存储链表headA的节点，\n\n再对链表headB进行遍历，若hashNode中存在headB的节点，则说明两个链表相交\n\n并返回第一个相交的点\n\n\n实现代码如下：\npublic class Solution {    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {        if (headA == null || headB == null)            return null;    // 若任意一个链表为空 则说明两个链表没有交点        // 存储记录 headA 中的节点        HashMap&lt;ListNode, Integer&gt; hashNode = new HashMap&lt;&gt;();        ListNode curA = headA;        while (curA != null) {            // 将headA的节点保存到哈希表中            hashNode.put(curA, 1);            curA = curA.next;   // 继续遍历headA        }        // 判断两个链表是否相交        ListNode curB = headB;        while (curB != null) {            if (hashNode.containsKey(curB)) {   // 若哈希表中存在节点                return curB;    // 直接返回第一个相交的节点            }            curB = curB.next;   // 继续遍历headB        }        return null;    }}\n\n提交结果如下：\n解答成功:    执行耗时:6 ms,击败了9.32% 的Java用户    内存消耗:45.7 MB,击败了6.07% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(n+m)，需要遍历链表headA和链表headB\n\n空间复杂度：O(m)，需要将链表headA的节点存储到哈希表中\n\n\n解法二(双指针)思路分析：\n\n两个链表存在两种情况，即相交或不相交\n\n两个链表相交时，假设链表headA的不相交部分有a个节点，链表headB不相交部分有b个节点，则相交部分有c个节点，则a+c = m，b+c = n\n\n如果a=b，则两个指针同时遍历两个链表，会同时到达相交的节点，此时返回相交的节点\n\n如果a!=b，则指针pA会遍历完链表headA，指针pB会遍历完链表headB，两个指针不会同时遍历完两个链表，此时由上述关系是可以得出m + b == n + a，即pA遍历完headA后，接着遍历headB，pB遍历完headB后接着遍历headA，此时两个指针会同时遍历结束，也会同时到达两个链表相交的第一个节点，此时返回相交的节点\n\n\n\n两个链表不相交时：\n\n如果m = n，则两个指针同时遍历结束两个链表，并返回null\n\n如果m != n，则两个指针各自遍历一遍两个链表，并同时结束遍历，返回null\n\n\n\n\n实现代码如下：\npublic class Solution {    // 双指针    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {        if (headA == null || headB == null)            return null;    // 若任意一个链表为空 则说明两个链表没有交点        ListNode pA = headA;        ListNode pB = headB;        while (pA != pB) {  // 两个指针分别进行遍历 并判断            pA = pA==null? headB : pA.next;            pB = pB==null? headA : pB.next;        }        return pA;    }}\n\n提交结果如下：\n解答成功:    执行耗时:1 ms,击败了99.24% 的Java用户    内存消耗:45.3 MB,击败了55.50% 的Java用户\n\n复杂度分析：\n\n时间复杂度：O(m+n)，两个指针同时对两个链表进行遍历，极端时，两个指针分别遍历一次两个链表\n\n空间复杂度：O(1)，使用了两个指针\n\n\n","categories":["leetcode","面试题"],"tags":["刷题","哈希表","链表","双指针"]}]